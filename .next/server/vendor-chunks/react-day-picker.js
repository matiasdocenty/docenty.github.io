"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-day-picker";
exports.ids = ["vendor-chunks/react-day-picker"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-day-picker/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-day-picker/dist/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Caption: () => (/* binding */ Caption),\n/* harmony export */   CaptionDropdowns: () => (/* binding */ CaptionDropdowns),\n/* harmony export */   CaptionLabel: () => (/* binding */ CaptionLabel),\n/* harmony export */   CaptionNavigation: () => (/* binding */ CaptionNavigation),\n/* harmony export */   Day: () => (/* binding */ Day),\n/* harmony export */   DayContent: () => (/* binding */ DayContent),\n/* harmony export */   DayPicker: () => (/* binding */ DayPicker),\n/* harmony export */   DayPickerContext: () => (/* binding */ DayPickerContext),\n/* harmony export */   DayPickerProvider: () => (/* binding */ DayPickerProvider),\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown),\n/* harmony export */   FocusContext: () => (/* binding */ FocusContext),\n/* harmony export */   FocusProvider: () => (/* binding */ FocusProvider),\n/* harmony export */   Footer: () => (/* binding */ Footer),\n/* harmony export */   Head: () => (/* binding */ Head),\n/* harmony export */   HeadRow: () => (/* binding */ HeadRow),\n/* harmony export */   IconDropdown: () => (/* binding */ IconDropdown),\n/* harmony export */   IconLeft: () => (/* binding */ IconLeft),\n/* harmony export */   IconRight: () => (/* binding */ IconRight),\n/* harmony export */   InternalModifier: () => (/* binding */ InternalModifier),\n/* harmony export */   Months: () => (/* binding */ Months),\n/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   NavigationProvider: () => (/* binding */ NavigationProvider),\n/* harmony export */   RootProvider: () => (/* binding */ RootProvider),\n/* harmony export */   Row: () => (/* binding */ Row),\n/* harmony export */   SelectMultipleContext: () => (/* binding */ SelectMultipleContext),\n/* harmony export */   SelectMultipleProvider: () => (/* binding */ SelectMultipleProvider),\n/* harmony export */   SelectMultipleProviderInternal: () => (/* binding */ SelectMultipleProviderInternal),\n/* harmony export */   SelectRangeContext: () => (/* binding */ SelectRangeContext),\n/* harmony export */   SelectRangeProvider: () => (/* binding */ SelectRangeProvider),\n/* harmony export */   SelectRangeProviderInternal: () => (/* binding */ SelectRangeProviderInternal),\n/* harmony export */   SelectSingleContext: () => (/* binding */ SelectSingleContext),\n/* harmony export */   SelectSingleProvider: () => (/* binding */ SelectSingleProvider),\n/* harmony export */   SelectSingleProviderInternal: () => (/* binding */ SelectSingleProviderInternal),\n/* harmony export */   WeekNumber: () => (/* binding */ WeekNumber),\n/* harmony export */   addToRange: () => (/* binding */ addToRange),\n/* harmony export */   isDateAfterType: () => (/* binding */ isDateAfterType),\n/* harmony export */   isDateBeforeType: () => (/* binding */ isDateBeforeType),\n/* harmony export */   isDateInterval: () => (/* binding */ isDateInterval),\n/* harmony export */   isDateRange: () => (/* binding */ isDateRange),\n/* harmony export */   isDayOfWeekType: () => (/* binding */ isDayOfWeekType),\n/* harmony export */   isDayPickerDefault: () => (/* binding */ isDayPickerDefault),\n/* harmony export */   isDayPickerMultiple: () => (/* binding */ isDayPickerMultiple),\n/* harmony export */   isDayPickerRange: () => (/* binding */ isDayPickerRange),\n/* harmony export */   isDayPickerSingle: () => (/* binding */ isDayPickerSingle),\n/* harmony export */   isMatch: () => (/* binding */ isMatch),\n/* harmony export */   useActiveModifiers: () => (/* binding */ useActiveModifiers),\n/* harmony export */   useDayPicker: () => (/* binding */ useDayPicker),\n/* harmony export */   useDayRender: () => (/* binding */ useDayRender),\n/* harmony export */   useFocusContext: () => (/* binding */ useFocusContext),\n/* harmony export */   useInput: () => (/* binding */ useInput),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useSelectMultiple: () => (/* binding */ useSelectMultiple),\n/* harmony export */   useSelectRange: () => (/* binding */ useSelectRange),\n/* harmony export */   useSelectSingle: () => (/* binding */ useSelectSingle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var date_fns_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns/format */ \"(ssr)/./node_modules/date-fns/esm/format/index.js\");\n/* harmony import */ var date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns/startOfMonth */ \"(ssr)/./node_modules/date-fns/esm/startOfMonth/index.js\");\n/* harmony import */ var date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns/endOfMonth */ \"(ssr)/./node_modules/date-fns/esm/endOfMonth/index.js\");\n/* harmony import */ var date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns/startOfDay */ \"(ssr)/./node_modules/date-fns/esm/startOfDay/index.js\");\n/* harmony import */ var date_fns_isSameYear__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns/isSameYear */ \"(ssr)/./node_modules/date-fns/esm/isSameYear/index.js\");\n/* harmony import */ var date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns/setMonth */ \"(ssr)/./node_modules/date-fns/esm/setMonth/index.js\");\n/* harmony import */ var date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns/setYear */ \"(ssr)/./node_modules/date-fns/esm/setYear/index.js\");\n/* harmony import */ var date_fns_startOfYear__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns/startOfYear */ \"(ssr)/./node_modules/date-fns/esm/startOfYear/index.js\");\n/* harmony import */ var date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns/differenceInCalendarMonths */ \"(ssr)/./node_modules/date-fns/esm/differenceInCalendarMonths/index.js\");\n/* harmony import */ var date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns/addMonths */ \"(ssr)/./node_modules/date-fns/esm/addMonths/index.js\");\n/* harmony import */ var date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns/isSameMonth */ \"(ssr)/./node_modules/date-fns/esm/isSameMonth/index.js\");\n/* harmony import */ var date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns/isBefore */ \"(ssr)/./node_modules/date-fns/esm/isBefore/index.js\");\n/* harmony import */ var date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns/startOfISOWeek */ \"(ssr)/./node_modules/date-fns/esm/startOfISOWeek/index.js\");\n/* harmony import */ var date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns/startOfWeek */ \"(ssr)/./node_modules/date-fns/esm/startOfWeek/index.js\");\n/* harmony import */ var date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns/addDays */ \"(ssr)/./node_modules/date-fns/esm/addDays/index.js\");\n/* harmony import */ var date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns/isSameDay */ \"(ssr)/./node_modules/date-fns/esm/isSameDay/index.js\");\n/* harmony import */ var date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! date-fns/isAfter */ \"(ssr)/./node_modules/date-fns/esm/isAfter/index.js\");\n/* harmony import */ var date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! date-fns/subDays */ \"(ssr)/./node_modules/date-fns/esm/subDays/index.js\");\n/* harmony import */ var date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! date-fns/differenceInCalendarDays */ \"(ssr)/./node_modules/date-fns/esm/differenceInCalendarDays/index.js\");\n/* harmony import */ var date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! date-fns/isDate */ \"(ssr)/./node_modules/date-fns/esm/isDate/index.js\");\n/* harmony import */ var date_fns_max__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! date-fns/max */ \"(ssr)/./node_modules/date-fns/esm/max/index.js\");\n/* harmony import */ var date_fns_min__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! date-fns/min */ \"(ssr)/./node_modules/date-fns/esm/min/index.js\");\n/* harmony import */ var date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns/addWeeks */ \"(ssr)/./node_modules/date-fns/esm/addWeeks/index.js\");\n/* harmony import */ var date_fns_addYears__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns/addYears */ \"(ssr)/./node_modules/date-fns/esm/addYears/index.js\");\n/* harmony import */ var date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns/endOfISOWeek */ \"(ssr)/./node_modules/date-fns/esm/endOfISOWeek/index.js\");\n/* harmony import */ var date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! date-fns/endOfWeek */ \"(ssr)/./node_modules/date-fns/esm/endOfWeek/index.js\");\n/* harmony import */ var date_fns_getUnixTime__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! date-fns/getUnixTime */ \"(ssr)/./node_modules/date-fns/esm/getUnixTime/index.js\");\n/* harmony import */ var date_fns_getISOWeek__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! date-fns/getISOWeek */ \"(ssr)/./node_modules/date-fns/esm/getISOWeek/index.js\");\n/* harmony import */ var date_fns_getWeek__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! date-fns/getWeek */ \"(ssr)/./node_modules/date-fns/esm/getWeek/index.js\");\n/* harmony import */ var date_fns_getWeeksInMonth__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! date-fns/getWeeksInMonth */ \"(ssr)/./node_modules/date-fns/esm/getWeeksInMonth/index.js\");\n/* harmony import */ var date_fns_parse__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! date-fns/parse */ \"(ssr)/./node_modules/date-fns/esm/parse/index.js\");\n/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns/locale */ \"(ssr)/./node_modules/date-fns/esm/locale/en-US/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar jsxRuntime = {\n    exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_production_min;\nfunction requireReactJsxRuntime_production_min() {\n    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;\n    hasRequiredReactJsxRuntime_production_min = 1;\n    var f = (react__WEBPACK_IMPORTED_MODULE_0___default()), k = Symbol.for(\"react.element\"), l = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {\n        key: !0,\n        ref: !0,\n        __self: !0,\n        __source: !0\n    };\n    function q(c, a, g) {\n        var b, d = {}, e = null, h = null;\n        void 0 !== g && (e = \"\" + g);\n        void 0 !== a.key && (e = \"\" + a.key);\n        void 0 !== a.ref && (h = a.ref);\n        for(b in a)m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n        if (c && c.defaultProps) for(b in a = c.defaultProps, a)void 0 === d[b] && (d[b] = a[b]);\n        return {\n            $$typeof: k,\n            type: c,\n            key: e,\n            ref: h,\n            props: d,\n            _owner: n.current\n        };\n    }\n    reactJsxRuntime_production_min.Fragment = l;\n    reactJsxRuntime_production_min.jsx = q;\n    reactJsxRuntime_production_min.jsxs = q;\n    return reactJsxRuntime_production_min;\n}\nvar reactJsxRuntime_development = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_development;\nfunction requireReactJsxRuntime_development() {\n    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;\n    hasRequiredReactJsxRuntime_development = 1;\n    if (true) {\n        (function() {\n            var React = (react__WEBPACK_IMPORTED_MODULE_0___default());\n            // ATTENTION\n            // When adding new symbols to this file,\n            // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n            // The Symbol used to tag the ReactElement-like types.\n            var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n            var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n            var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n            var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n            var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n            var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n            var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n            var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n            var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n            var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n            var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n            var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n            var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n            var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n            var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n            function getIteratorFn(maybeIterable) {\n                if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                    return null;\n                }\n                var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n                if (typeof maybeIterator === \"function\") {\n                    return maybeIterator;\n                }\n                return null;\n            }\n            var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n            function error(format) {\n                {\n                    {\n                        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                            args[_key2 - 1] = arguments[_key2];\n                        }\n                        printWarning(\"error\", format, args);\n                    }\n                }\n            }\n            function printWarning(level, format, args) {\n                // When changing this logic, you might want to also\n                // update consoleWithStackDev.www.js as well.\n                {\n                    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                    var stack = ReactDebugCurrentFrame.getStackAddendum();\n                    if (stack !== \"\") {\n                        format += \"%s\";\n                        args = args.concat([\n                            stack\n                        ]);\n                    } // eslint-disable-next-line react-internal/safe-string-coercion\n                    var argsWithFormat = args.map(function(item) {\n                        return String(item);\n                    }); // Careful: RN currently depends on this prefix\n                    argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                    // breaks IE9: https://github.com/facebook/react/issues/13610\n                    // eslint-disable-next-line react-internal/no-production-logging\n                    Function.prototype.apply.call(console[level], console, argsWithFormat);\n                }\n            }\n            // -----------------------------------------------------------------------------\n            var enableScopeAPI = false; // Experimental Create Event Handle API.\n            var enableCacheElement = false;\n            var enableTransitionTracing = false; // No known bugs, but needs performance testing\n            var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n            // stuff. Intended to enable React core members to more easily debug scheduling\n            // issues in DEV builds.\n            var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n            var REACT_MODULE_REFERENCE;\n            {\n                REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n            }\n            function isValidElementType(type) {\n                if (typeof type === \"string\" || typeof type === \"function\") {\n                    return true;\n                } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n                if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                    return true;\n                }\n                if (typeof type === \"object\" && type !== null) {\n                    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                    // types supported by any Flight configuration anywhere since\n                    // we don't know which Flight build this will end up being used\n                    // with.\n                    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function getWrappedName(outerType, innerType, wrapperName) {\n                var displayName = outerType.displayName;\n                if (displayName) {\n                    return displayName;\n                }\n                var functionName = innerType.displayName || innerType.name || \"\";\n                return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n            } // Keep in sync with react-reconciler/getComponentNameFromFiber\n            function getContextName(type) {\n                return type.displayName || \"Context\";\n            } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n            function getComponentNameFromType(type) {\n                if (type == null) {\n                    // Host root, text node or just invalid type.\n                    return null;\n                }\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                if (typeof type === \"function\") {\n                    return type.displayName || type.name || null;\n                }\n                if (typeof type === \"string\") {\n                    return type;\n                }\n                switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return \"Fragment\";\n                    case REACT_PORTAL_TYPE:\n                        return \"Portal\";\n                    case REACT_PROFILER_TYPE:\n                        return \"Profiler\";\n                    case REACT_STRICT_MODE_TYPE:\n                        return \"StrictMode\";\n                    case REACT_SUSPENSE_TYPE:\n                        return \"Suspense\";\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return \"SuspenseList\";\n                }\n                if (typeof type === \"object\") {\n                    switch(type.$$typeof){\n                        case REACT_CONTEXT_TYPE:\n                            var context = type;\n                            return getContextName(context) + \".Consumer\";\n                        case REACT_PROVIDER_TYPE:\n                            var provider = type;\n                            return getContextName(provider._context) + \".Provider\";\n                        case REACT_FORWARD_REF_TYPE:\n                            return getWrappedName(type, type.render, \"ForwardRef\");\n                        case REACT_MEMO_TYPE:\n                            var outerName = type.displayName || null;\n                            if (outerName !== null) {\n                                return outerName;\n                            }\n                            return getComponentNameFromType(type.type) || \"Memo\";\n                        case REACT_LAZY_TYPE:\n                            {\n                                var lazyComponent = type;\n                                var payload = lazyComponent._payload;\n                                var init = lazyComponent._init;\n                                try {\n                                    return getComponentNameFromType(init(payload));\n                                } catch (x) {\n                                    return null;\n                                }\n                            }\n                    }\n                }\n                return null;\n            }\n            var assign = Object.assign;\n            // Helpers to patch console.logs to avoid logging during side-effect free\n            // replaying on render function. This currently only patches the object\n            // lazily which won't cover if the log function was extracted eagerly.\n            // We could also eagerly patch the method.\n            var disabledDepth = 0;\n            var prevLog;\n            var prevInfo;\n            var prevWarn;\n            var prevError;\n            var prevGroup;\n            var prevGroupCollapsed;\n            var prevGroupEnd;\n            function disabledLog() {}\n            disabledLog.__reactDisabledLog = true;\n            function disableLogs() {\n                {\n                    if (disabledDepth === 0) {\n                        /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                        prevInfo = console.info;\n                        prevWarn = console.warn;\n                        prevError = console.error;\n                        prevGroup = console.group;\n                        prevGroupCollapsed = console.groupCollapsed;\n                        prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                        var props = {\n                            configurable: true,\n                            enumerable: true,\n                            value: disabledLog,\n                            writable: true\n                        }; // $FlowFixMe Flow thinks console is immutable.\n                        Object.defineProperties(console, {\n                            info: props,\n                            log: props,\n                            warn: props,\n                            error: props,\n                            group: props,\n                            groupCollapsed: props,\n                            groupEnd: props\n                        });\n                    /* eslint-enable react-internal/no-production-logging */ }\n                    disabledDepth++;\n                }\n            }\n            function reenableLogs() {\n                {\n                    disabledDepth--;\n                    if (disabledDepth === 0) {\n                        /* eslint-disable react-internal/no-production-logging */ var props = {\n                            configurable: true,\n                            enumerable: true,\n                            writable: true\n                        }; // $FlowFixMe Flow thinks console is immutable.\n                        Object.defineProperties(console, {\n                            log: assign({}, props, {\n                                value: prevLog\n                            }),\n                            info: assign({}, props, {\n                                value: prevInfo\n                            }),\n                            warn: assign({}, props, {\n                                value: prevWarn\n                            }),\n                            error: assign({}, props, {\n                                value: prevError\n                            }),\n                            group: assign({}, props, {\n                                value: prevGroup\n                            }),\n                            groupCollapsed: assign({}, props, {\n                                value: prevGroupCollapsed\n                            }),\n                            groupEnd: assign({}, props, {\n                                value: prevGroupEnd\n                            })\n                        });\n                    /* eslint-enable react-internal/no-production-logging */ }\n                    if (disabledDepth < 0) {\n                        error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                    }\n                }\n            }\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n            var prefix;\n            function describeBuiltInComponentFrame(name, source, ownerFn) {\n                {\n                    if (prefix === undefined) {\n                        // Extract the VM specific prefix used by each line.\n                        try {\n                            throw Error();\n                        } catch (x) {\n                            var match = x.stack.trim().match(/\\n( *(at )?)/);\n                            prefix = match && match[1] || \"\";\n                        }\n                    } // We use the prefix to ensure our stacks line up with native stack frames.\n                    return \"\\n\" + prefix + name;\n                }\n            }\n            var reentry = false;\n            var componentFrameCache;\n            {\n                var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n                componentFrameCache = new PossiblyWeakMap();\n            }\n            function describeNativeComponentFrame(fn, construct) {\n                // If something asked for a stack inside a fake render, it should get ignored.\n                if (!fn || reentry) {\n                    return \"\";\n                }\n                {\n                    var frame = componentFrameCache.get(fn);\n                    if (frame !== undefined) {\n                        return frame;\n                    }\n                }\n                var control;\n                reentry = true;\n                var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n                Error.prepareStackTrace = undefined;\n                var previousDispatcher;\n                {\n                    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                    // for warnings.\n                    ReactCurrentDispatcher.current = null;\n                    disableLogs();\n                }\n                try {\n                    // This should throw.\n                    if (construct) {\n                        // Something should be setting the props in the constructor.\n                        var Fake = function() {\n                            throw Error();\n                        }; // $FlowFixMe\n                        Object.defineProperty(Fake.prototype, \"props\", {\n                            set: function() {\n                                // We use a throwing setter instead of frozen or non-writable props\n                                // because that won't throw in a non-strict mode function.\n                                throw Error();\n                            }\n                        });\n                        if (typeof Reflect === \"object\" && Reflect.construct) {\n                            // We construct a different control for this case to include any extra\n                            // frames added by the construct call.\n                            try {\n                                Reflect.construct(Fake, []);\n                            } catch (x) {\n                                control = x;\n                            }\n                            Reflect.construct(fn, [], Fake);\n                        } else {\n                            try {\n                                Fake.call();\n                            } catch (x) {\n                                control = x;\n                            }\n                            fn.call(Fake.prototype);\n                        }\n                    } else {\n                        try {\n                            throw Error();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn();\n                    }\n                } catch (sample) {\n                    // This is inlined manually because closure doesn't do it for us.\n                    if (sample && control && typeof sample.stack === \"string\") {\n                        // This extracts the first frame from the sample that isn't also in the control.\n                        // Skipping one frame that we assume is the frame that calls the two.\n                        var sampleLines = sample.stack.split(\"\\n\");\n                        var controlLines = control.stack.split(\"\\n\");\n                        var s = sampleLines.length - 1;\n                        var c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                        for(; s >= 1 && c >= 0; s--, c--){\n                            // Next we find the first one that isn't the same which should be the\n                            // frame that called our sample function and the control.\n                            if (sampleLines[s] !== controlLines[c]) {\n                                // In V8, the first line is describing the message but other VMs don't.\n                                // If we're about to return the first line, and the control is also on the same\n                                // line, that's a pretty good indicator that our sample threw at same line as\n                                // the control. I.e. before we entered the sample frame. So we ignore this result.\n                                // This can happen if you passed a class to function component, or non-function.\n                                if (s !== 1 || c !== 1) {\n                                    do {\n                                        s--;\n                                        c--; // We may still have similar intermediate frames from the construct call.\n                                        // The next one that isn't the same should be our match though.\n                                        if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                            // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                            var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                            // but we have a user-provided \"displayName\"\n                                            // splice it in to make the stack more readable.\n                                            if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                                _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                            }\n                                            {\n                                                if (typeof fn === \"function\") {\n                                                    componentFrameCache.set(fn, _frame);\n                                                }\n                                            }\n                                            return _frame;\n                                        }\n                                    }while (s >= 1 && c >= 0);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                } finally{\n                    reentry = false;\n                    {\n                        ReactCurrentDispatcher.current = previousDispatcher;\n                        reenableLogs();\n                    }\n                    Error.prepareStackTrace = previousPrepareStackTrace;\n                } // Fallback to just using the name if we couldn't make it throw.\n                var name = fn ? fn.displayName || fn.name : \"\";\n                var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n                {\n                    if (typeof fn === \"function\") {\n                        componentFrameCache.set(fn, syntheticFrame);\n                    }\n                }\n                return syntheticFrame;\n            }\n            function describeFunctionComponentFrame(fn, source, ownerFn) {\n                {\n                    return describeNativeComponentFrame(fn, false);\n                }\n            }\n            function shouldConstruct(Component) {\n                var prototype = Component.prototype;\n                return !!(prototype && prototype.isReactComponent);\n            }\n            function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n                if (type == null) {\n                    return \"\";\n                }\n                if (typeof type === \"function\") {\n                    {\n                        return describeNativeComponentFrame(type, shouldConstruct(type));\n                    }\n                }\n                if (typeof type === \"string\") {\n                    return describeBuiltInComponentFrame(type);\n                }\n                switch(type){\n                    case REACT_SUSPENSE_TYPE:\n                        return describeBuiltInComponentFrame(\"Suspense\");\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return describeBuiltInComponentFrame(\"SuspenseList\");\n                }\n                if (typeof type === \"object\") {\n                    switch(type.$$typeof){\n                        case REACT_FORWARD_REF_TYPE:\n                            return describeFunctionComponentFrame(type.render);\n                        case REACT_MEMO_TYPE:\n                            // Memo may contain any component type so we recursively resolve it.\n                            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                        case REACT_LAZY_TYPE:\n                            {\n                                var lazyComponent = type;\n                                var payload = lazyComponent._payload;\n                                var init = lazyComponent._init;\n                                try {\n                                    // Lazy may contain any component type so we recursively resolve it.\n                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                                } catch (x) {}\n                            }\n                    }\n                }\n                return \"\";\n            }\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var loggedTypeFailures = {};\n            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n            function setCurrentlyValidatingElement(element) {\n                {\n                    if (element) {\n                        var owner = element._owner;\n                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                        ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                    } else {\n                        ReactDebugCurrentFrame.setExtraStackFrame(null);\n                    }\n                }\n            }\n            function checkPropTypes(typeSpecs, values, location, componentName, element) {\n                {\n                    // $FlowFixMe This is okay but Flow doesn't know it.\n                    var has = Function.call.bind(hasOwnProperty);\n                    for(var typeSpecName in typeSpecs){\n                        if (has(typeSpecs, typeSpecName)) {\n                            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                    // eslint-disable-next-line react-internal/prod-error-codes\n                                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                    err.name = \"Invariant Violation\";\n                                    throw err;\n                                }\n                                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                            } catch (ex) {\n                                error$1 = ex;\n                            }\n                            if (error$1 && !(error$1 instanceof Error)) {\n                                setCurrentlyValidatingElement(element);\n                                error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                                setCurrentlyValidatingElement(null);\n                            }\n                            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error$1.message] = true;\n                                setCurrentlyValidatingElement(element);\n                                error(\"Failed %s type: %s\", location, error$1.message);\n                                setCurrentlyValidatingElement(null);\n                            }\n                        }\n                    }\n                }\n            }\n            var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n            function isArray(a) {\n                return isArrayImpl(a);\n            }\n            /*\n\t * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t *\n\t * The functions in this module will throw an easier-to-understand,\n\t * easier-to-debug exception with a clear errors message message explaining the\n\t * problem. (Instead of a confusing exception thrown inside the implementation\n\t * of the `value` object).\n\t */ // $FlowFixMe only called in DEV, so void return is not possible.\n            function typeName(value) {\n                {\n                    // toStringTag is needed for namespaced types like Temporal.Instant\n                    var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                    return type;\n                }\n            } // $FlowFixMe only called in DEV, so void return is not possible.\n            function willCoercionThrow(value) {\n                {\n                    try {\n                        testStringCoercion(value);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n            }\n            function testStringCoercion(value) {\n                // If you ended up here by following an exception call stack, here's what's\n                // happened: you supplied an object or symbol value to React (as a prop, key,\n                // DOM attribute, CSS property, string ref, etc.) and when React tried to\n                // coerce it to a string using `'' + value`, an exception was thrown.\n                //\n                // The most common types that will cause this exception are `Symbol` instances\n                // and Temporal objects like `Temporal.Instant`. But any object that has a\n                // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n                // exception. (Library authors do this to prevent users from using built-in\n                // numeric operators like `+` or comparison operators like `>=` because custom\n                // methods are needed to perform accurate arithmetic or comparison.)\n                //\n                // To fix the problem, coerce this object or symbol value to a string before\n                // passing it to React. The most reliable way is usually `String(value)`.\n                //\n                // To find which value is throwing, check the browser or debugger console.\n                // Before this exception was thrown, there should be `console.error` output\n                // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n                // problem and how that type was used: key, atrribute, input value prop, etc.\n                // In most cases, this console output also shows the component and its\n                // ancestor components where the exception happened.\n                //\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                return \"\" + value;\n            }\n            function checkKeyStringCoercion(value) {\n                {\n                    if (willCoercionThrow(value)) {\n                        error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                    }\n                }\n            }\n            var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n            var RESERVED_PROPS = {\n                key: true,\n                ref: true,\n                __self: true,\n                __source: true\n            };\n            var specialPropKeyWarningShown;\n            var specialPropRefWarningShown;\n            var didWarnAboutStringRefs;\n            {\n                didWarnAboutStringRefs = {};\n            }\n            function hasValidRef(config) {\n                {\n                    if (hasOwnProperty.call(config, \"ref\")) {\n                        var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                        if (getter && getter.isReactWarning) {\n                            return false;\n                        }\n                    }\n                }\n                return config.ref !== undefined;\n            }\n            function hasValidKey(config) {\n                {\n                    if (hasOwnProperty.call(config, \"key\")) {\n                        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                        if (getter && getter.isReactWarning) {\n                            return false;\n                        }\n                    }\n                }\n                return config.key !== undefined;\n            }\n            function warnIfStringRefCannotBeAutoConverted(config, self) {\n                {\n                    if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n                        var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                        if (!didWarnAboutStringRefs[componentName]) {\n                            error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                            didWarnAboutStringRefs[componentName] = true;\n                        }\n                    }\n                }\n            }\n            function defineKeyPropWarningGetter(props, displayName) {\n                {\n                    var warnAboutAccessingKey = function() {\n                        if (!specialPropKeyWarningShown) {\n                            specialPropKeyWarningShown = true;\n                            error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                        }\n                    };\n                    warnAboutAccessingKey.isReactWarning = true;\n                    Object.defineProperty(props, \"key\", {\n                        get: warnAboutAccessingKey,\n                        configurable: true\n                    });\n                }\n            }\n            function defineRefPropWarningGetter(props, displayName) {\n                {\n                    var warnAboutAccessingRef = function() {\n                        if (!specialPropRefWarningShown) {\n                            specialPropRefWarningShown = true;\n                            error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                        }\n                    };\n                    warnAboutAccessingRef.isReactWarning = true;\n                    Object.defineProperty(props, \"ref\", {\n                        get: warnAboutAccessingRef,\n                        configurable: true\n                    });\n                }\n            }\n            /**\n\t * Factory method to create a new React element. This no longer adheres to\n\t * the class pattern, so do not use new to call it. Also, instanceof check\n\t * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n\t * if something is a React Element.\n\t *\n\t * @param {*} type\n\t * @param {*} props\n\t * @param {*} key\n\t * @param {string|object} ref\n\t * @param {*} owner\n\t * @param {*} self A *temporary* helper to detect places where `this` is\n\t * different from the `owner` when React.createElement is called, so that we\n\t * can warn. We want to get rid of owner and replace string `ref`s with arrow\n\t * functions, and as long as `this` and owner are the same, there will be no\n\t * change in behavior.\n\t * @param {*} source An annotation object (added by a transpiler or otherwise)\n\t * indicating filename, line number, and/or other information.\n\t * @internal\n\t */ var ReactElement = function(type, key, ref, self, source, owner, props) {\n                var element = {\n                    // This tag allows us to uniquely identify this as a React Element\n                    $$typeof: REACT_ELEMENT_TYPE,\n                    // Built-in properties that belong on the element\n                    type: type,\n                    key: key,\n                    ref: ref,\n                    props: props,\n                    // Record the component responsible for creating this element.\n                    _owner: owner\n                };\n                {\n                    // The validation flag is currently mutative. We put it on\n                    // an external backing store so that we can freeze the whole object.\n                    // This can be replaced with a WeakMap once they are implemented in\n                    // commonly used development environments.\n                    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                    // the validation flag non-enumerable (where possible, which should\n                    // include every environment we run tests in), so the test framework\n                    // ignores it.\n                    Object.defineProperty(element._store, \"validated\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: true,\n                        value: false\n                    }); // self and source are DEV only properties.\n                    Object.defineProperty(element, \"_self\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: false,\n                        value: self\n                    }); // Two elements created in two different places should be considered\n                    // equal for testing purposes and therefore we hide it from enumeration.\n                    Object.defineProperty(element, \"_source\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: false,\n                        value: source\n                    });\n                    if (Object.freeze) {\n                        Object.freeze(element.props);\n                        Object.freeze(element);\n                    }\n                }\n                return element;\n            };\n            /**\n\t * https://github.com/reactjs/rfcs/pull/107\n\t * @param {*} type\n\t * @param {object} props\n\t * @param {string} key\n\t */ function jsxDEV(type, config, maybeKey, source, self) {\n                {\n                    var propName; // Reserved names are extracted\n                    var props = {};\n                    var key = null;\n                    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                    // but as an intermediary step, we will use jsxDEV for everything except\n                    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                    // key is explicitly declared to be undefined or not.\n                    if (maybeKey !== undefined) {\n                        {\n                            checkKeyStringCoercion(maybeKey);\n                        }\n                        key = \"\" + maybeKey;\n                    }\n                    if (hasValidKey(config)) {\n                        {\n                            checkKeyStringCoercion(config.key);\n                        }\n                        key = \"\" + config.key;\n                    }\n                    if (hasValidRef(config)) {\n                        ref = config.ref;\n                        warnIfStringRefCannotBeAutoConverted(config, self);\n                    } // Remaining properties are added to a new props object\n                    for(propName in config){\n                        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                            props[propName] = config[propName];\n                        }\n                    } // Resolve default props\n                    if (type && type.defaultProps) {\n                        var defaultProps = type.defaultProps;\n                        for(propName in defaultProps){\n                            if (props[propName] === undefined) {\n                                props[propName] = defaultProps[propName];\n                            }\n                        }\n                    }\n                    if (key || ref) {\n                        var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                        if (key) {\n                            defineKeyPropWarningGetter(props, displayName);\n                        }\n                        if (ref) {\n                            defineRefPropWarningGetter(props, displayName);\n                        }\n                    }\n                    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n                }\n            }\n            var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n            var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n            function setCurrentlyValidatingElement$1(element) {\n                {\n                    if (element) {\n                        var owner = element._owner;\n                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                    } else {\n                        ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                    }\n                }\n            }\n            var propTypesMisspellWarningShown;\n            {\n                propTypesMisspellWarningShown = false;\n            }\n            /**\n\t * Verifies the object is a ReactElement.\n\t * See https://reactjs.org/docs/react-api.html#isvalidelement\n\t * @param {?object} object\n\t * @return {boolean} True if `object` is a ReactElement.\n\t * @final\n\t */ function isValidElement(object) {\n                {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                }\n            }\n            function getDeclarationErrorAddendum() {\n                {\n                    if (ReactCurrentOwner$1.current) {\n                        var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                        if (name) {\n                            return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                        }\n                    }\n                    return \"\";\n                }\n            }\n            function getSourceInfoErrorAddendum(source) {\n                {\n                    if (source !== undefined) {\n                        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                        var lineNumber = source.lineNumber;\n                        return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                    }\n                    return \"\";\n                }\n            }\n            /**\n\t * Warn if there's no key explicitly set on dynamic arrays of children or\n\t * object keys are not valid. This allows us to keep track of children between\n\t * updates.\n\t */ var ownerHasKeyUseWarning = {};\n            function getCurrentComponentErrorInfo(parentType) {\n                {\n                    var info = getDeclarationErrorAddendum();\n                    if (!info) {\n                        var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                        if (parentName) {\n                            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                        }\n                    }\n                    return info;\n                }\n            }\n            /**\n\t * Warn if the element doesn't have an explicit key assigned to it.\n\t * This element is in an array. The array could grow and shrink or be\n\t * reordered. All children that haven't already been validated are required to\n\t * have a \"key\" property assigned to it. Error statuses are cached so a warning\n\t * will only be shown once.\n\t *\n\t * @internal\n\t * @param {ReactElement} element Element that requires a key.\n\t * @param {*} parentType element's parent's type.\n\t */ function validateExplicitKey(element, parentType) {\n                {\n                    if (!element._store || element._store.validated || element.key != null) {\n                        return;\n                    }\n                    element._store.validated = true;\n                    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                        return;\n                    }\n                    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                    // property, it may be the creator of the child that's responsible for\n                    // assigning it a key.\n                    var childOwner = \"\";\n                    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n                        // Give the component that originally created this child.\n                        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                    }\n                    setCurrentlyValidatingElement$1(element);\n                    error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                    setCurrentlyValidatingElement$1(null);\n                }\n            }\n            /**\n\t * Ensure that every element either is passed in a static location, in an\n\t * array with an explicit keys property defined, or in an object literal\n\t * with valid key property.\n\t *\n\t * @internal\n\t * @param {ReactNode} node Statically passed child of any type.\n\t * @param {*} parentType node's parent's type.\n\t */ function validateChildKeys(node, parentType) {\n                {\n                    if (typeof node !== \"object\") {\n                        return;\n                    }\n                    if (isArray(node)) {\n                        for(var i = 0; i < node.length; i++){\n                            var child = node[i];\n                            if (isValidElement(child)) {\n                                validateExplicitKey(child, parentType);\n                            }\n                        }\n                    } else if (isValidElement(node)) {\n                        // This element was passed in a valid location.\n                        if (node._store) {\n                            node._store.validated = true;\n                        }\n                    } else if (node) {\n                        var iteratorFn = getIteratorFn(node);\n                        if (typeof iteratorFn === \"function\") {\n                            // Entry iterators used to provide implicit keys,\n                            // but now we print a separate warning for them later.\n                            if (iteratorFn !== node.entries) {\n                                var iterator = iteratorFn.call(node);\n                                var step;\n                                while(!(step = iterator.next()).done){\n                                    if (isValidElement(step.value)) {\n                                        validateExplicitKey(step.value, parentType);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            /**\n\t * Given an element, validate that its props follow the propTypes definition,\n\t * provided by the type.\n\t *\n\t * @param {ReactElement} element\n\t */ function validatePropTypes(element) {\n                {\n                    var type = element.type;\n                    if (type === null || type === undefined || typeof type === \"string\") {\n                        return;\n                    }\n                    var propTypes;\n                    if (typeof type === \"function\") {\n                        propTypes = type.propTypes;\n                    } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                    // Inner props are checked in the reconciler.\n                    type.$$typeof === REACT_MEMO_TYPE)) {\n                        propTypes = type.propTypes;\n                    } else {\n                        return;\n                    }\n                    if (propTypes) {\n                        // Intentionally inside to avoid triggering lazy initializers:\n                        var name = getComponentNameFromType(type);\n                        checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                        propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                        var _name = getComponentNameFromType(type);\n                        error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                    }\n                    if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                        error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                    }\n                }\n            }\n            /**\n\t * Given a fragment, validate that it can only be provided with fragment props\n\t * @param {ReactElement} fragment\n\t */ function validateFragmentProps(fragment) {\n                {\n                    var keys = Object.keys(fragment.props);\n                    for(var i = 0; i < keys.length; i++){\n                        var key = keys[i];\n                        if (key !== \"children\" && key !== \"key\") {\n                            setCurrentlyValidatingElement$1(fragment);\n                            error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                            setCurrentlyValidatingElement$1(null);\n                            break;\n                        }\n                    }\n                    if (fragment.ref !== null) {\n                        setCurrentlyValidatingElement$1(fragment);\n                        error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                        setCurrentlyValidatingElement$1(null);\n                    }\n                }\n            }\n            function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n                {\n                    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                    // succeed and there will likely be errors in render.\n                    if (!validType) {\n                        var info = \"\";\n                        if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                            info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                        }\n                        var sourceInfo = getSourceInfoErrorAddendum(source);\n                        if (sourceInfo) {\n                            info += sourceInfo;\n                        } else {\n                            info += getDeclarationErrorAddendum();\n                        }\n                        var typeString;\n                        if (type === null) {\n                            typeString = \"null\";\n                        } else if (isArray(type)) {\n                            typeString = \"array\";\n                        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                            typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                            info = \" Did you accidentally export a JSX literal instead of a component?\";\n                        } else {\n                            typeString = typeof type;\n                        }\n                        error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                    }\n                    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                    // TODO: Drop this when these are no longer allowed as the type argument.\n                    if (element == null) {\n                        return element;\n                    } // Skip key warning if the type isn't valid since our key validation logic\n                    // doesn't expect a non-string/function type and can throw confusing errors.\n                    // We don't want exception behavior to differ between dev and prod.\n                    // (Rendering will throw with a helpful message and as soon as the type is\n                    // fixed, the key warnings will appear.)\n                    if (validType) {\n                        var children = props.children;\n                        if (children !== undefined) {\n                            if (isStaticChildren) {\n                                if (isArray(children)) {\n                                    for(var i = 0; i < children.length; i++){\n                                        validateChildKeys(children[i], type);\n                                    }\n                                    if (Object.freeze) {\n                                        Object.freeze(children);\n                                    }\n                                } else {\n                                    error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                                }\n                            } else {\n                                validateChildKeys(children, type);\n                            }\n                        }\n                    }\n                    if (type === REACT_FRAGMENT_TYPE) {\n                        validateFragmentProps(element);\n                    } else {\n                        validatePropTypes(element);\n                    }\n                    return element;\n                }\n            } // These two functions exist to still get child warnings in dev\n            // even with the prod transform. This means that jsxDEV is purely\n            // opt-in behavior for better messages but that we won't stop\n            // giving you warnings if you use production apis.\n            function jsxWithValidationStatic(type, props, key) {\n                {\n                    return jsxWithValidation(type, props, key, true);\n                }\n            }\n            function jsxWithValidationDynamic(type, props, key) {\n                {\n                    return jsxWithValidation(type, props, key, false);\n                }\n            }\n            var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n            // for now we can ship identical prod functions\n            var jsxs = jsxWithValidationStatic;\n            reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;\n            reactJsxRuntime_development.jsx = jsx;\n            reactJsxRuntime_development.jsxs = jsxs;\n        })();\n    }\n    return reactJsxRuntime_development;\n}\nif (false) {} else {\n    jsxRuntime.exports = requireReactJsxRuntime_development();\n}\nvar jsxRuntimeExports = jsxRuntime.exports;\n/** Returns true when the props are of type {@link DayPickerMultipleProps}. */ function isDayPickerMultiple(props) {\n    return props.mode === \"multiple\";\n}\n/** Returns true when the props are of type {@link DayPickerRangeProps}. */ function isDayPickerRange(props) {\n    return props.mode === \"range\";\n}\n/** Returns true when the props are of type {@link DayPickerSingleProps}. */ function isDayPickerSingle(props) {\n    return props.mode === \"single\";\n}\n/**\n * The name of the default CSS classes.\n */ var defaultClassNames = {\n    root: \"rdp\",\n    multiple_months: \"rdp-multiple_months\",\n    with_weeknumber: \"rdp-with_weeknumber\",\n    vhidden: \"rdp-vhidden\",\n    button_reset: \"rdp-button_reset\",\n    button: \"rdp-button\",\n    caption: \"rdp-caption\",\n    caption_start: \"rdp-caption_start\",\n    caption_end: \"rdp-caption_end\",\n    caption_between: \"rdp-caption_between\",\n    caption_label: \"rdp-caption_label\",\n    caption_dropdowns: \"rdp-caption_dropdowns\",\n    dropdown: \"rdp-dropdown\",\n    dropdown_month: \"rdp-dropdown_month\",\n    dropdown_year: \"rdp-dropdown_year\",\n    dropdown_icon: \"rdp-dropdown_icon\",\n    months: \"rdp-months\",\n    month: \"rdp-month\",\n    table: \"rdp-table\",\n    tbody: \"rdp-tbody\",\n    tfoot: \"rdp-tfoot\",\n    head: \"rdp-head\",\n    head_row: \"rdp-head_row\",\n    head_cell: \"rdp-head_cell\",\n    nav: \"rdp-nav\",\n    nav_button: \"rdp-nav_button\",\n    nav_button_previous: \"rdp-nav_button_previous\",\n    nav_button_next: \"rdp-nav_button_next\",\n    nav_icon: \"rdp-nav_icon\",\n    row: \"rdp-row\",\n    weeknumber: \"rdp-weeknumber\",\n    cell: \"rdp-cell\",\n    day: \"rdp-day\",\n    day_today: \"rdp-day_today\",\n    day_outside: \"rdp-day_outside\",\n    day_selected: \"rdp-day_selected\",\n    day_disabled: \"rdp-day_disabled\",\n    day_hidden: \"rdp-day_hidden\",\n    day_range_start: \"rdp-day_range_start\",\n    day_range_end: \"rdp-day_range_end\",\n    day_range_middle: \"rdp-day_range_middle\"\n};\n/**\n * The default formatter for the caption.\n */ function formatCaption(month, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(month, \"LLLL y\", options);\n}\n/**\n * The default formatter for the Day button.\n */ function formatDay(day, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"d\", options);\n}\n/**\n * The default formatter for the Month caption.\n */ function formatMonthCaption(month, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(month, \"LLLL\", options);\n}\n/**\n * The default formatter for the week number.\n */ function formatWeekNumber(weekNumber) {\n    return \"\".concat(weekNumber);\n}\n/**\n * The default formatter for the name of the weekday.\n */ function formatWeekdayName(weekday, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(weekday, \"cccccc\", options);\n}\n/**\n * The default formatter for the Year caption.\n */ function formatYearCaption(year, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(year, \"yyyy\", options);\n}\nvar formatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    formatCaption: formatCaption,\n    formatDay: formatDay,\n    formatMonthCaption: formatMonthCaption,\n    formatWeekNumber: formatWeekNumber,\n    formatWeekdayName: formatWeekdayName,\n    formatYearCaption: formatYearCaption\n});\n/**\n * The default ARIA label for the day button.\n */ var labelDay = function(day, activeModifiers, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"do MMMM (EEEE)\", options);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelMonthDropdown = function() {\n    return \"Month: \";\n};\n/**\n * The default ARIA label for next month button in navigation\n */ var labelNext = function() {\n    return \"Go to next month\";\n};\n/**\n * The default ARIA label for previous month button in navigation\n */ var labelPrevious = function() {\n    return \"Go to previous month\";\n};\n/**\n * The default ARIA label for the Weekday element.\n */ var labelWeekday = function(day, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"cccc\", options);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelWeekNumber = function(n) {\n    return \"Week n. \".concat(n);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelYearDropdown = function() {\n    return \"Year: \";\n};\nvar labels = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    labelDay: labelDay,\n    labelMonthDropdown: labelMonthDropdown,\n    labelNext: labelNext,\n    labelPrevious: labelPrevious,\n    labelWeekNumber: labelWeekNumber,\n    labelWeekday: labelWeekday,\n    labelYearDropdown: labelYearDropdown\n});\n/**\n * Returns the default values to use in the DayPickerContext, in case they are\n * not passed down with the DayPicker initial props.\n */ function getDefaultContextValues() {\n    var captionLayout = \"buttons\";\n    var classNames = defaultClassNames;\n    var locale = date_fns_locale__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n    var modifiersClassNames = {};\n    var modifiers = {};\n    var numberOfMonths = 1;\n    var styles = {};\n    var today = new Date();\n    return {\n        captionLayout: captionLayout,\n        classNames: classNames,\n        formatters: formatters,\n        labels: labels,\n        locale: locale,\n        modifiersClassNames: modifiersClassNames,\n        modifiers: modifiers,\n        numberOfMonths: numberOfMonths,\n        styles: styles,\n        today: today,\n        mode: \"default\"\n    };\n}\n/** Return the `fromDate` and `toDate` prop values values parsing the DayPicker props. */ function parseFromToProps(props) {\n    var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;\n    var fromDate = props.fromDate, toDate = props.toDate;\n    if (fromMonth) {\n        fromDate = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(fromMonth);\n    } else if (fromYear) {\n        fromDate = new Date(fromYear, 0, 1);\n    }\n    if (toMonth) {\n        toDate = (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(toMonth);\n    } else if (toYear) {\n        toDate = new Date(toYear, 11, 31);\n    }\n    return {\n        fromDate: fromDate ? (0,date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fromDate) : undefined,\n        toDate: toDate ? (0,date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(toDate) : undefined\n    };\n}\n/**\n * The DayPicker context shares the props passed to DayPicker within internal\n * and custom components. It is used to set the default values and perform\n * one-time calculations required to render the days.\n *\n * Access to this context from the {@link useDayPicker} hook.\n */ var DayPickerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/**\n * The provider for the {@link DayPickerContext}, assigning the defaults from the\n * initial DayPicker props.\n */ function DayPickerProvider(props) {\n    var _a;\n    var initialProps = props.initialProps;\n    var defaultContextValues = getDefaultContextValues();\n    var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate = _b.toDate;\n    var captionLayout = (_a = initialProps.captionLayout) !== null && _a !== void 0 ? _a : defaultContextValues.captionLayout;\n    if (captionLayout !== \"buttons\" && (!fromDate || !toDate)) {\n        // When no from/to dates are set, the caption is always buttons\n        captionLayout = \"buttons\";\n    }\n    var onSelect;\n    if (isDayPickerSingle(initialProps) || isDayPickerMultiple(initialProps) || isDayPickerRange(initialProps)) {\n        onSelect = initialProps.onSelect;\n    }\n    var value = __assign(__assign(__assign({}, defaultContextValues), initialProps), {\n        captionLayout: captionLayout,\n        classNames: __assign(__assign({}, defaultContextValues.classNames), initialProps.classNames),\n        components: __assign({}, initialProps.components),\n        formatters: __assign(__assign({}, defaultContextValues.formatters), initialProps.formatters),\n        fromDate: fromDate,\n        labels: __assign(__assign({}, defaultContextValues.labels), initialProps.labels),\n        mode: initialProps.mode || defaultContextValues.mode,\n        modifiers: __assign(__assign({}, defaultContextValues.modifiers), initialProps.modifiers),\n        modifiersClassNames: __assign(__assign({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames),\n        onSelect: onSelect,\n        styles: __assign(__assign({}, defaultContextValues.styles), initialProps.styles),\n        toDate: toDate\n    });\n    return jsxRuntimeExports.jsx(DayPickerContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link DayPickerContextValue}.\n *\n * Use the DayPicker context to access to the props passed to DayPicker inside\n * internal or custom components.\n */ function useDayPicker() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DayPickerContext);\n    if (!context) {\n        throw new Error(\"useDayPicker must be used within a DayPickerProvider.\");\n    }\n    return context;\n}\n/** Render the caption for the displayed month. This component is used when `captionLayout=\"buttons\"`. */ function CaptionLabel(props) {\n    var _a = useDayPicker(), locale = _a.locale, classNames = _a.classNames, styles = _a.styles, formatCaption = _a.formatters.formatCaption;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.caption_label,\n        style: styles.caption_label,\n        \"aria-live\": \"polite\",\n        role: \"presentation\",\n        id: props.id\n    }, {\n        children: formatCaption(props.displayMonth, {\n            locale: locale\n        })\n    }));\n}\n/**\n * Render the icon in the styled drop-down.\n */ function IconDropdown(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"8px\",\n        height: \"8px\",\n        viewBox: \"0 0 120 120\",\n        \"data-testid\": \"iconDropdown\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z\",\n            fill: \"currentColor\",\n            fillRule: \"nonzero\"\n        })\n    }));\n}\n/**\n * Render a styled select component – displaying a caption and a custom\n * drop-down icon.\n */ function Dropdown(props) {\n    var _a, _b;\n    var onChange = props.onChange, value = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;\n    var dayPicker = useDayPicker();\n    var IconDropdownComponent = (_b = (_a = dayPicker.components) === null || _a === void 0 ? void 0 : _a.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: className,\n        style: style\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(\"span\", __assign({\n                className: dayPicker.classNames.vhidden\n            }, {\n                children: props[\"aria-label\"]\n            })),\n            jsxRuntimeExports.jsx(\"select\", __assign({\n                name: props.name,\n                \"aria-label\": props[\"aria-label\"],\n                className: dayPicker.classNames.dropdown,\n                style: dayPicker.styles.dropdown,\n                value: value,\n                onChange: onChange\n            }, {\n                children: children\n            })),\n            jsxRuntimeExports.jsxs(\"div\", __assign({\n                className: dayPicker.classNames.caption_label,\n                style: dayPicker.styles.caption_label,\n                \"aria-hidden\": \"true\"\n            }, {\n                children: [\n                    caption,\n                    jsxRuntimeExports.jsx(IconDropdownComponent, {\n                        className: dayPicker.classNames.dropdown_icon,\n                        style: dayPicker.styles.dropdown_icon\n                    })\n                ]\n            }))\n        ]\n    }));\n}\n/** Render the dropdown to navigate between months. */ function MonthsDropdown(props) {\n    var _a;\n    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown = _b.labels.labelMonthDropdown;\n    // Dropdown should appear only when both from/toDate is set\n    if (!fromDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    if (!toDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    var dropdownMonths = [];\n    if ((0,date_fns_isSameYear__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(fromDate, toDate)) {\n        // only display the months included in the range\n        var date = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(fromDate);\n        for(var month = fromDate.getMonth(); month <= toDate.getMonth(); month++){\n            dropdownMonths.push((0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(date, month));\n        }\n    } else {\n        // display all the 12 months\n        var date = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date()); // Any date should be OK, as we just need the year\n        for(var month = 0; month <= 11; month++){\n            dropdownMonths.push((0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(date, month));\n        }\n    }\n    var handleChange = function(e) {\n        var selectedMonth = Number(e.target.value);\n        var newMonth = (0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(props.displayMonth), selectedMonth);\n        props.onChange(newMonth);\n    };\n    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;\n    return jsxRuntimeExports.jsx(DropdownComponent, __assign({\n        name: \"months\",\n        \"aria-label\": labelMonthDropdown(),\n        className: classNames.dropdown_month,\n        style: styles.dropdown_month,\n        onChange: handleChange,\n        value: props.displayMonth.getMonth(),\n        caption: formatMonthCaption(props.displayMonth, {\n            locale: locale\n        })\n    }, {\n        children: dropdownMonths.map(function(m) {\n            return jsxRuntimeExports.jsx(\"option\", __assign({\n                value: m.getMonth()\n            }, {\n                children: formatMonthCaption(m, {\n                    locale: locale\n                })\n            }), m.getMonth());\n        })\n    }));\n}\n/**\n * Render a dropdown to change the year. Take in account the `nav.fromDate` and\n * `toDate` from context.\n */ function YearsDropdown(props) {\n    var _a;\n    var displayMonth = props.displayMonth;\n    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption = _b.formatters.formatYearCaption, labelYearDropdown = _b.labels.labelYearDropdown;\n    var years = [];\n    // Dropdown should appear only when both from/toDate is set\n    if (!fromDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    if (!toDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    var fromYear = fromDate.getFullYear();\n    var toYear = toDate.getFullYear();\n    for(var year = fromYear; year <= toYear; year++){\n        years.push((0,date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__[\"default\"])((0,date_fns_startOfYear__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(new Date()), year));\n    }\n    var handleChange = function(e) {\n        var newMonth = (0,date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__[\"default\"])((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(displayMonth), Number(e.target.value));\n        props.onChange(newMonth);\n    };\n    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;\n    return jsxRuntimeExports.jsx(DropdownComponent, __assign({\n        name: \"years\",\n        \"aria-label\": labelYearDropdown(),\n        className: classNames.dropdown_year,\n        style: styles.dropdown_year,\n        onChange: handleChange,\n        value: displayMonth.getFullYear(),\n        caption: formatYearCaption(displayMonth, {\n            locale: locale\n        })\n    }, {\n        children: years.map(function(year) {\n            return jsxRuntimeExports.jsx(\"option\", __assign({\n                value: year.getFullYear()\n            }, {\n                children: formatYearCaption(year, {\n                    locale: locale\n                })\n            }), year.getFullYear());\n        })\n    }));\n}\n/**\n * Helper hook for using controlled/uncontrolled values from a component props.\n *\n * When the value is not controlled, pass `undefined` as `controlledValue` and\n * use the returned setter to update it.\n *\n * When the value is controlled, pass the controlled value as second\n * argument, which will be always returned as `value`.\n */ function useControlledValue(defaultValue, controlledValue) {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue), uncontrolledValue = _a[0], setValue = _a[1];\n    var value = controlledValue === undefined ? uncontrolledValue : controlledValue;\n    return [\n        value,\n        setValue\n    ];\n}\n/** Return the initial month according to the given options. */ function getInitialMonth(context) {\n    var month = context.month, defaultMonth = context.defaultMonth, today = context.today;\n    var initialMonth = month || defaultMonth || today || new Date();\n    var toDate = context.toDate, fromDate = context.fromDate, _a = context.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    // Fix the initialMonth if is after the to-date\n    if (toDate && (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(toDate, initialMonth) < 0) {\n        var offset = -1 * (numberOfMonths - 1);\n        initialMonth = (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(toDate, offset);\n    }\n    // Fix the initialMonth if is before the from-date\n    if (fromDate && (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(initialMonth, fromDate) < 0) {\n        initialMonth = fromDate;\n    }\n    return (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(initialMonth);\n}\n/** Controls the navigation state. */ function useNavigationState() {\n    var context = useDayPicker();\n    var initialMonth = getInitialMonth(context);\n    var _a = useControlledValue(initialMonth, context.month), month = _a[0], setMonth = _a[1];\n    var goToMonth = function(date) {\n        var _a;\n        if (context.disableNavigation) return;\n        var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(date);\n        setMonth(month);\n        (_a = context.onMonthChange) === null || _a === void 0 ? void 0 : _a.call(context, month);\n    };\n    return [\n        month,\n        goToMonth\n    ];\n}\n/**\n * Return the months to display in the component according to the number of\n * months and the from/to date.\n */ function getDisplayMonths(month, _a) {\n    var reverseMonths = _a.reverseMonths, numberOfMonths = _a.numberOfMonths;\n    var start = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(month);\n    var end = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(start, numberOfMonths));\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(end, start);\n    var months = [];\n    for(var i = 0; i < monthsDiff; i++){\n        var nextMonth = (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(start, i);\n        months.push(nextMonth);\n    }\n    if (reverseMonths) months = months.reverse();\n    return months;\n}\n/**\n * Returns the next month the user can navigate to according to the given\n * options.\n *\n * Please note that the next month is not always the next calendar month:\n *\n * - if after the `toDate` range, is undefined;\n * - if the navigation is paged, is the number of months displayed ahead.\n *\n */ function getNextMonth(startingMonth, options) {\n    if (options.disableNavigation) {\n        return undefined;\n    }\n    var toDate = options.toDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    var offset = pagedNavigation ? numberOfMonths : 1;\n    var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(startingMonth);\n    if (!toDate) {\n        return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, offset);\n    }\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(toDate, startingMonth);\n    if (monthsDiff < numberOfMonths) {\n        return undefined;\n    }\n    // Jump forward as the number of months when paged navigation\n    return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, offset);\n}\n/**\n * Returns the next previous the user can navigate to, according to the given\n * options.\n *\n * Please note that the previous month is not always the previous calendar\n * month:\n *\n * - if before the `fromDate` date, is `undefined`;\n * - if the navigation is paged, is the number of months displayed before.\n *\n */ function getPreviousMonth(startingMonth, options) {\n    if (options.disableNavigation) {\n        return undefined;\n    }\n    var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    var offset = pagedNavigation ? numberOfMonths : 1;\n    var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(startingMonth);\n    if (!fromDate) {\n        return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, -offset);\n    }\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(month, fromDate);\n    if (monthsDiff <= 0) {\n        return undefined;\n    }\n    // Jump back as the number of months when paged navigation\n    return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, -offset);\n}\n/**\n * The Navigation context shares details and methods to navigate the months in DayPicker.\n * Access this context from the {@link useNavigation} hook.\n */ var NavigationContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link NavigationContext}. */ function NavigationProvider(props) {\n    var dayPicker = useDayPicker();\n    var _a = useNavigationState(), currentMonth = _a[0], goToMonth = _a[1];\n    var displayMonths = getDisplayMonths(currentMonth, dayPicker);\n    var nextMonth = getNextMonth(currentMonth, dayPicker);\n    var previousMonth = getPreviousMonth(currentMonth, dayPicker);\n    var isDateDisplayed = function(date) {\n        return displayMonths.some(function(displayMonth) {\n            return (0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(date, displayMonth);\n        });\n    };\n    var goToDate = function(date, refDate) {\n        if (isDateDisplayed(date)) {\n            return;\n        }\n        if (refDate && (0,date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(date, refDate)) {\n            goToMonth((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(date, 1 + dayPicker.numberOfMonths * -1));\n        } else {\n            goToMonth(date);\n        }\n    };\n    var value = {\n        currentMonth: currentMonth,\n        displayMonths: displayMonths,\n        goToMonth: goToMonth,\n        goToDate: goToDate,\n        previousMonth: previousMonth,\n        nextMonth: nextMonth,\n        isDateDisplayed: isDateDisplayed\n    };\n    return jsxRuntimeExports.jsx(NavigationContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link NavigationContextValue}. Use this hook to navigate\n * between months or years in DayPicker.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useNavigation() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);\n    if (!context) {\n        throw new Error(\"useNavigation must be used within a NavigationProvider\");\n    }\n    return context;\n}\n/**\n * Render a caption with the dropdowns to navigate between months and years.\n */ function CaptionDropdowns(props) {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;\n    var goToMonth = useNavigation().goToMonth;\n    var handleMonthChange = function(newMonth) {\n        goToMonth((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(newMonth, props.displayIndex ? -props.displayIndex : 0));\n    };\n    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;\n    var captionLabel = jsxRuntimeExports.jsx(CaptionLabelComponent, {\n        id: props.id,\n        displayMonth: props.displayMonth\n    });\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: classNames.caption_dropdowns,\n        style: styles.caption_dropdowns\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(\"div\", __assign({\n                className: classNames.vhidden\n            }, {\n                children: captionLabel\n            })),\n            jsxRuntimeExports.jsx(MonthsDropdown, {\n                onChange: handleMonthChange,\n                displayMonth: props.displayMonth\n            }),\n            jsxRuntimeExports.jsx(YearsDropdown, {\n                onChange: handleMonthChange,\n                displayMonth: props.displayMonth\n            })\n        ]\n    }));\n}\n/**\n * Render the \"previous month\" button in the navigation.\n */ function IconLeft(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"16px\",\n        height: \"16px\",\n        viewBox: \"0 0 120 120\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z\",\n            fill: \"currentColor\",\n            fillRule: \"nonzero\"\n        })\n    }));\n}\n/**\n * Render the \"next month\" button in the navigation.\n */ function IconRight(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"16px\",\n        height: \"16px\",\n        viewBox: \"0 0 120 120\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z\",\n            fill: \"currentColor\"\n        })\n    }));\n}\n/** Render a button HTML element applying the reset class name. */ var Button = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(props, ref) {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;\n    var classNamesArr = [\n        classNames.button_reset,\n        classNames.button\n    ];\n    if (props.className) {\n        classNamesArr.push(props.className);\n    }\n    var className = classNamesArr.join(\" \");\n    var style = __assign(__assign({}, styles.button_reset), styles.button);\n    if (props.style) {\n        Object.assign(style, props.style);\n    }\n    return jsxRuntimeExports.jsx(\"button\", __assign({}, props, {\n        ref: ref,\n        type: \"button\",\n        className: className,\n        style: style\n    }));\n});\n/** A component rendering the navigation buttons or the drop-downs. */ function Navigation(props) {\n    var _a, _b;\n    var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious = _d.labelPrevious, labelNext = _d.labelNext, components = _c.components;\n    if (!props.nextMonth && !props.previousMonth) {\n        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    }\n    var previousLabel = labelPrevious(props.previousMonth, {\n        locale: locale\n    });\n    var previousClassName = [\n        classNames.nav_button,\n        classNames.nav_button_previous\n    ].join(\" \");\n    var nextLabel = labelNext(props.nextMonth, {\n        locale: locale\n    });\n    var nextClassName = [\n        classNames.nav_button,\n        classNames.nav_button_next\n    ].join(\" \");\n    var IconRightComponent = (_a = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a !== void 0 ? _a : IconRight;\n    var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : IconLeft;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: classNames.nav,\n        style: styles.nav\n    }, {\n        children: [\n            !props.hidePrevious && jsxRuntimeExports.jsx(Button, __assign({\n                name: \"previous-month\",\n                \"aria-label\": previousLabel,\n                className: previousClassName,\n                style: styles.nav_button_previous,\n                disabled: !props.previousMonth,\n                onClick: props.onPreviousClick\n            }, {\n                children: dir === \"rtl\" ? jsxRuntimeExports.jsx(IconRightComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                }) : jsxRuntimeExports.jsx(IconLeftComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                })\n            })),\n            !props.hideNext && jsxRuntimeExports.jsx(Button, __assign({\n                name: \"next-month\",\n                \"aria-label\": nextLabel,\n                className: nextClassName,\n                style: styles.nav_button_next,\n                disabled: !props.nextMonth,\n                onClick: props.onNextClick\n            }, {\n                children: dir === \"rtl\" ? jsxRuntimeExports.jsx(IconLeftComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                }) : jsxRuntimeExports.jsx(IconRightComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                })\n            }))\n        ]\n    }));\n}\n/**\n * Render a caption with a button-based navigation.\n */ function CaptionNavigation(props) {\n    var numberOfMonths = useDayPicker().numberOfMonths;\n    var _a = useNavigation(), previousMonth = _a.previousMonth, nextMonth = _a.nextMonth, goToMonth = _a.goToMonth, displayMonths = _a.displayMonths;\n    var displayIndex = displayMonths.findIndex(function(month) {\n        return (0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(props.displayMonth, month);\n    });\n    var isFirst = displayIndex === 0;\n    var isLast = displayIndex === displayMonths.length - 1;\n    var hideNext = numberOfMonths > 1 && (isFirst || !isLast);\n    var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);\n    var handlePreviousClick = function() {\n        if (!previousMonth) return;\n        goToMonth(previousMonth);\n    };\n    var handleNextClick = function() {\n        if (!nextMonth) return;\n        goToMonth(nextMonth);\n    };\n    return jsxRuntimeExports.jsx(Navigation, {\n        displayMonth: props.displayMonth,\n        hideNext: hideNext,\n        hidePrevious: hidePrevious,\n        nextMonth: nextMonth,\n        previousMonth: previousMonth,\n        onPreviousClick: handlePreviousClick,\n        onNextClick: handleNextClick\n    });\n}\n/**\n * Render the caption of a month. The caption has a different layout when\n * setting the {@link DayPickerBase.captionLayout} prop.\n */ function Caption(props) {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;\n    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;\n    var caption;\n    if (disableNavigation) {\n        caption = jsxRuntimeExports.jsx(CaptionLabelComponent, {\n            id: props.id,\n            displayMonth: props.displayMonth\n        });\n    } else if (captionLayout === \"dropdown\") {\n        caption = jsxRuntimeExports.jsx(CaptionDropdowns, {\n            displayMonth: props.displayMonth,\n            id: props.id\n        });\n    } else if (captionLayout === \"dropdown-buttons\") {\n        caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {\n            children: [\n                jsxRuntimeExports.jsx(CaptionDropdowns, {\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex,\n                    id: props.id\n                }),\n                jsxRuntimeExports.jsx(CaptionNavigation, {\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex,\n                    id: props.id\n                })\n            ]\n        });\n    } else {\n        caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {\n            children: [\n                jsxRuntimeExports.jsx(CaptionLabelComponent, {\n                    id: props.id,\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex\n                }),\n                jsxRuntimeExports.jsx(CaptionNavigation, {\n                    displayMonth: props.displayMonth,\n                    id: props.id\n                })\n            ]\n        });\n    }\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.caption,\n        style: styles.caption\n    }, {\n        children: caption\n    }));\n}\n/** Render the Footer component (empty as default).*/ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction Footer(props) {\n    var _a = useDayPicker(), footer = _a.footer, styles = _a.styles, tfoot = _a.classNames.tfoot;\n    if (!footer) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    return jsxRuntimeExports.jsx(\"tfoot\", __assign({\n        className: tfoot,\n        style: styles.tfoot\n    }, {\n        children: jsxRuntimeExports.jsx(\"tr\", {\n            children: jsxRuntimeExports.jsx(\"td\", __assign({\n                colSpan: 8\n            }, {\n                children: footer\n            }))\n        })\n    }));\n}\n/**\n * Generate a series of 7 days, starting from the week, to use for formatting\n * the weekday names (Monday, Tuesday, etc.).\n */ function getWeekdays(locale, /** The index of the first day of the week (0 - Sunday). */ weekStartsOn, /** Use ISOWeek instead of locale/ */ ISOWeek) {\n    var start = ISOWeek ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(new Date()) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(new Date(), {\n        locale: locale,\n        weekStartsOn: weekStartsOn\n    });\n    var days = [];\n    for(var i = 0; i < 7; i++){\n        var day = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(start, i);\n        days.push(day);\n    }\n    return days;\n}\n/**\n * Render the HeadRow component - i.e. the table head row with the weekday names.\n */ function HeadRow() {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles, showWeekNumber = _a.showWeekNumber, locale = _a.locale, weekStartsOn = _a.weekStartsOn, ISOWeek = _a.ISOWeek, formatWeekdayName = _a.formatters.formatWeekdayName, labelWeekday = _a.labels.labelWeekday;\n    var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);\n    return jsxRuntimeExports.jsxs(\"tr\", __assign({\n        style: styles.head_row,\n        className: classNames.head_row\n    }, {\n        children: [\n            showWeekNumber && jsxRuntimeExports.jsx(\"td\", {\n                style: styles.head_cell,\n                className: classNames.head_cell\n            }),\n            weekdays.map(function(weekday, i) {\n                return jsxRuntimeExports.jsx(\"th\", __assign({\n                    scope: \"col\",\n                    className: classNames.head_cell,\n                    style: styles.head_cell,\n                    \"aria-label\": labelWeekday(weekday, {\n                        locale: locale\n                    })\n                }, {\n                    children: formatWeekdayName(weekday, {\n                        locale: locale\n                    })\n                }), i);\n            })\n        ]\n    }));\n}\n/** Render the table head. */ function Head() {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;\n    var HeadRowComponent = (_a = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a !== void 0 ? _a : HeadRow;\n    return jsxRuntimeExports.jsx(\"thead\", __assign({\n        style: styles.head,\n        className: classNames.head\n    }, {\n        children: jsxRuntimeExports.jsx(HeadRowComponent, {})\n    }));\n}\n/** Render the content of the day cell. */ function DayContent(props) {\n    var _a = useDayPicker(), locale = _a.locale, formatDay = _a.formatters.formatDay;\n    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {\n        children: formatDay(props.date, {\n            locale: locale\n        })\n    });\n}\n/**\n * The SelectMultiple context shares details about the selected days when in\n * multiple selection mode.\n *\n * Access this context from the {@link useSelectMultiple} hook.\n */ var SelectMultipleContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectMultipleContext}. */ function SelectMultipleProvider(props) {\n    if (!isDayPickerMultiple(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined,\n            modifiers: {\n                disabled: []\n            }\n        };\n        return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectMultipleProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectMultipleProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var selected = initialProps.selected, min = initialProps.min, max = initialProps.max;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        var isMinSelected = Boolean(activeModifiers.selected && min && (selected === null || selected === void 0 ? void 0 : selected.length) === min);\n        if (isMinSelected) {\n            return;\n        }\n        var isMaxSelected = Boolean(!activeModifiers.selected && max && (selected === null || selected === void 0 ? void 0 : selected.length) === max);\n        if (isMaxSelected) {\n            return;\n        }\n        var selectedDays = selected ? __spreadArray([], selected, true) : [];\n        if (activeModifiers.selected) {\n            var index = selectedDays.findIndex(function(selectedDay) {\n                return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(day, selectedDay);\n            });\n            selectedDays.splice(index, 1);\n        } else {\n            selectedDays.push(day);\n        }\n        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day, activeModifiers, e);\n    };\n    var modifiers = {\n        disabled: []\n    };\n    if (selected) {\n        modifiers.disabled.push(function(day) {\n            var isMaxSelected = max && selected.length > max - 1;\n            var isSelected = selected.some(function(selectedDay) {\n                return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(selectedDay, day);\n            });\n            return Boolean(isMaxSelected && !isSelected);\n        });\n    }\n    var contextValue = {\n        selected: selected,\n        onDayClick: onDayClick,\n        modifiers: modifiers\n    };\n    return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, __assign({\n        value: contextValue\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectMultipleContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectMultiple() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectMultipleContext);\n    if (!context) {\n        throw new Error(\"useSelectMultiple must be used within a SelectMultipleProvider\");\n    }\n    return context;\n}\n/**\n * Add a day to an existing range.\n *\n * The returned range takes in account the `undefined` values and if the added\n * day is already present in the range.\n */ function addToRange(day, range) {\n    var _a = range || {}, from = _a.from, to = _a.to;\n    if (from && to) {\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, day) && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, day)) {\n            return undefined;\n        }\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, day)) {\n            return {\n                from: to,\n                to: undefined\n            };\n        }\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, day)) {\n            return undefined;\n        }\n        if ((0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(from, day)) {\n            return {\n                from: day,\n                to: to\n            };\n        }\n        return {\n            from: from,\n            to: day\n        };\n    }\n    if (to) {\n        if ((0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(day, to)) {\n            return {\n                from: to,\n                to: day\n            };\n        }\n        return {\n            from: day,\n            to: to\n        };\n    }\n    if (from) {\n        if ((0,date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(day, from)) {\n            return {\n                from: day,\n                to: from\n            };\n        }\n        return {\n            from: from,\n            to: day\n        };\n    }\n    return {\n        from: day,\n        to: undefined\n    };\n}\n/**\n * The SelectRange context shares details about the selected days when in\n * range selection mode.\n *\n * Access this context from the {@link useSelectRange} hook.\n */ var SelectRangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectRangeProvider}. */ function SelectRangeProvider(props) {\n    if (!isDayPickerRange(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined,\n            modifiers: {\n                range_start: [],\n                range_end: [],\n                range_middle: [],\n                disabled: []\n            }\n        };\n        return jsxRuntimeExports.jsx(SelectRangeContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectRangeProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectRangeProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var selected = initialProps.selected;\n    var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;\n    var min = initialProps.min;\n    var max = initialProps.max;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        var newRange = addToRange(day, selected);\n        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, newRange, day, activeModifiers, e);\n    };\n    var modifiers = {\n        range_start: [],\n        range_end: [],\n        range_middle: [],\n        disabled: []\n    };\n    if (selectedFrom) {\n        modifiers.range_start = [\n            selectedFrom\n        ];\n        if (!selectedTo) {\n            modifiers.range_end = [\n                selectedFrom\n            ];\n        } else {\n            modifiers.range_end = [\n                selectedTo\n            ];\n            if (!(0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(selectedFrom, selectedTo)) {\n                modifiers.range_middle = [\n                    {\n                        after: selectedFrom,\n                        before: selectedTo\n                    }\n                ];\n            }\n        }\n    } else if (selectedTo) {\n        modifiers.range_start = [\n            selectedTo\n        ];\n        modifiers.range_end = [\n            selectedTo\n        ];\n    }\n    if (min) {\n        if (selectedFrom && !selectedTo) {\n            modifiers.disabled.push({\n                after: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedFrom, min - 1),\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, min - 1)\n            });\n        }\n        if (selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                after: selectedFrom,\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, min - 1)\n            });\n        }\n        if (!selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                after: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedTo, min - 1),\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, min - 1)\n            });\n        }\n    }\n    if (max) {\n        if (selectedFrom && !selectedTo) {\n            modifiers.disabled.push({\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, -max + 1)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, max - 1)\n            });\n        }\n        if (selectedFrom && selectedTo) {\n            var selectedCount = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(selectedTo, selectedFrom) + 1;\n            var offset = max - selectedCount;\n            modifiers.disabled.push({\n                before: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedFrom, offset)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, offset)\n            });\n        }\n        if (!selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, -max + 1)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, max - 1)\n            });\n        }\n    }\n    return jsxRuntimeExports.jsx(SelectRangeContext.Provider, __assign({\n        value: {\n            selected: selected,\n            onDayClick: onDayClick,\n            modifiers: modifiers\n        }\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectRangeContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectRange() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectRangeContext);\n    if (!context) {\n        throw new Error(\"useSelectRange must be used within a SelectRangeProvider\");\n    }\n    return context;\n}\n/** Normalize to array a matcher input. */ function matcherToArray(matcher) {\n    if (Array.isArray(matcher)) {\n        return __spreadArray([], matcher, true);\n    } else if (matcher !== undefined) {\n        return [\n            matcher\n        ];\n    } else {\n        return [];\n    }\n}\n/** Create CustomModifiers from dayModifiers */ function getCustomModifiers(dayModifiers) {\n    var customModifiers = {};\n    Object.entries(dayModifiers).forEach(function(_a) {\n        var modifier = _a[0], matcher = _a[1];\n        customModifiers[modifier] = matcherToArray(matcher);\n    });\n    return customModifiers;\n}\n/** The name of the modifiers that are used internally by DayPicker. */ var InternalModifier;\n(function(InternalModifier) {\n    InternalModifier[\"Outside\"] = \"outside\";\n    /** Name of the modifier applied to the disabled days, using the `disabled` prop. */ InternalModifier[\"Disabled\"] = \"disabled\";\n    /** Name of the modifier applied to the selected days using the `selected` prop). */ InternalModifier[\"Selected\"] = \"selected\";\n    /** Name of the modifier applied to the hidden days using the `hidden` prop). */ InternalModifier[\"Hidden\"] = \"hidden\";\n    /** Name of the modifier applied to the day specified using the `today` prop). */ InternalModifier[\"Today\"] = \"today\";\n    /** The modifier applied to the day starting a selected range, when in range selection mode.  */ InternalModifier[\"RangeStart\"] = \"range_start\";\n    /** The modifier applied to the day ending a selected range, when in range selection mode.  */ InternalModifier[\"RangeEnd\"] = \"range_end\";\n    /** The modifier applied to the days between the start and the end of a selected range, when in range selection mode.  */ InternalModifier[\"RangeMiddle\"] = \"range_middle\";\n})(InternalModifier || (InternalModifier = {}));\nvar Selected = InternalModifier.Selected, Disabled = InternalModifier.Disabled, Hidden = InternalModifier.Hidden, Today = InternalModifier.Today, RangeEnd = InternalModifier.RangeEnd, RangeMiddle = InternalModifier.RangeMiddle, RangeStart = InternalModifier.RangeStart, Outside = InternalModifier.Outside;\n/** Return the {@link InternalModifiers} from the DayPicker and select contexts. */ function getInternalModifiers(dayPicker, selectMultiple, selectRange) {\n    var _a;\n    var internalModifiers = (_a = {}, _a[Selected] = matcherToArray(dayPicker.selected), _a[Disabled] = matcherToArray(dayPicker.disabled), _a[Hidden] = matcherToArray(dayPicker.hidden), _a[Today] = [\n        dayPicker.today\n    ], _a[RangeEnd] = [], _a[RangeMiddle] = [], _a[RangeStart] = [], _a[Outside] = [], _a);\n    if (dayPicker.fromDate) {\n        internalModifiers[Disabled].push({\n            before: dayPicker.fromDate\n        });\n    }\n    if (dayPicker.toDate) {\n        internalModifiers[Disabled].push({\n            after: dayPicker.toDate\n        });\n    }\n    if (isDayPickerMultiple(dayPicker)) {\n        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);\n    } else if (isDayPickerRange(dayPicker)) {\n        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);\n        internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];\n        internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];\n        internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];\n    }\n    return internalModifiers;\n}\n/** The Modifiers context store the modifiers used in DayPicker. To access the value of this context, use {@link useModifiers}. */ var ModifiersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provide the value for the {@link ModifiersContext}. */ function ModifiersProvider(props) {\n    var dayPicker = useDayPicker();\n    var selectMultiple = useSelectMultiple();\n    var selectRange = useSelectRange();\n    var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);\n    var customModifiers = getCustomModifiers(dayPicker.modifiers);\n    var modifiers = __assign(__assign({}, internalModifiers), customModifiers);\n    return jsxRuntimeExports.jsx(ModifiersContext.Provider, __assign({\n        value: modifiers\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Return the modifiers used by DayPicker.\n *\n * This hook is meant to be used inside internal or custom components.\n * Requires to be wrapped into {@link ModifiersProvider}.\n *\n */ function useModifiers() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ModifiersContext);\n    if (!context) {\n        throw new Error(\"useModifiers must be used within a ModifiersProvider\");\n    }\n    return context;\n}\n/** Returns true if `matcher` is of type {@link DateInterval}. */ function isDateInterval(matcher) {\n    return Boolean(matcher && typeof matcher === \"object\" && \"before\" in matcher && \"after\" in matcher);\n}\n/** Returns true if `value` is a {@link DateRange} type. */ function isDateRange(value) {\n    return Boolean(value && typeof value === \"object\" && \"from\" in value);\n}\n/** Returns true if `value` is of type {@link DateAfter}. */ function isDateAfterType(value) {\n    return Boolean(value && typeof value === \"object\" && \"after\" in value);\n}\n/** Returns true if `value` is of type {@link DateBefore}. */ function isDateBeforeType(value) {\n    return Boolean(value && typeof value === \"object\" && \"before\" in value);\n}\n/** Returns true if `value` is a {@link DayOfWeek} type. */ function isDayOfWeekType(value) {\n    return Boolean(value && typeof value === \"object\" && \"dayOfWeek\" in value);\n}\n/** Return `true` whether `date` is inside `range`. */ function isDateInRange(date, range) {\n    var _a;\n    var from = range.from, to = range.to;\n    if (from && to) {\n        var isRangeInverted = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(to, from) < 0;\n        if (isRangeInverted) {\n            _a = [\n                to,\n                from\n            ], from = _a[0], to = _a[1];\n        }\n        var isInRange = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(date, from) >= 0 && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(to, date) >= 0;\n        return isInRange;\n    }\n    if (to) {\n        return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, date);\n    }\n    if (from) {\n        return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, date);\n    }\n    return false;\n}\n/** Returns true if `value` is a Date type. */ function isDateType(value) {\n    return (0,date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__[\"default\"])(value);\n}\n/** Returns true if `value` is an array of valid dates. */ function isArrayOfDates(value) {\n    return Array.isArray(value) && value.every(date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__[\"default\"]);\n}\n/**\n * Returns whether a day matches against at least one of the given Matchers.\n *\n * ```\n * const day = new Date(2022, 5, 19);\n * const matcher1: DateRange = {\n *    from: new Date(2021, 12, 21),\n *    to: new Date(2021, 12, 30)\n * }\n * const matcher2: DateRange = {\n *    from: new Date(2022, 5, 1),\n *    to: new Date(2022, 5, 23)\n * }\n *\n * const isMatch(day, [matcher1, matcher2]); // true, since day is in the matcher1 range.\n * ```\n * */ function isMatch(day, matchers) {\n    return matchers.some(function(matcher) {\n        if (typeof matcher === \"boolean\") {\n            return matcher;\n        }\n        if (isDateType(matcher)) {\n            return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(day, matcher);\n        }\n        if (isArrayOfDates(matcher)) {\n            return matcher.includes(day);\n        }\n        if (isDateRange(matcher)) {\n            return isDateInRange(day, matcher);\n        }\n        if (isDayOfWeekType(matcher)) {\n            return matcher.dayOfWeek.includes(day.getDay());\n        }\n        if (isDateInterval(matcher)) {\n            var diffBefore = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.before, day);\n            var diffAfter = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.after, day);\n            var isDayBefore = diffBefore > 0;\n            var isDayAfter = diffAfter < 0;\n            var isClosedInterval = (0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(matcher.before, matcher.after);\n            if (isClosedInterval) {\n                return isDayAfter && isDayBefore;\n            } else {\n                return isDayBefore || isDayAfter;\n            }\n        }\n        if (isDateAfterType(matcher)) {\n            return (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(day, matcher.after) > 0;\n        }\n        if (isDateBeforeType(matcher)) {\n            return (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.before, day) > 0;\n        }\n        if (typeof matcher === \"function\") {\n            return matcher(day);\n        }\n        return false;\n    });\n}\n/** Return the active modifiers for the given day. */ function getActiveModifiers(day, /** The modifiers to match for the given date. */ modifiers, /** The month where the day is displayed, to add the \"outside\" modifiers.  */ displayMonth) {\n    var matchedModifiers = Object.keys(modifiers).reduce(function(result, key) {\n        var modifier = modifiers[key];\n        if (isMatch(day, modifier)) {\n            result.push(key);\n        }\n        return result;\n    }, []);\n    var activeModifiers = {};\n    matchedModifiers.forEach(function(modifier) {\n        return activeModifiers[modifier] = true;\n    });\n    if (displayMonth && !(0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(day, displayMonth)) {\n        activeModifiers.outside = true;\n    }\n    return activeModifiers;\n}\n/**\n * Returns the day that should be the target of the focus when DayPicker is\n * rendered the first time.\n *\n * TODO: this function doesn't consider if the day is outside the month. We\n * implemented this check in `useDayRender` but it should probably go here. See\n * https://github.com/gpbl/react-day-picker/pull/1576\n */ function getInitialFocusTarget(displayMonths, modifiers) {\n    var firstDayInMonth = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(displayMonths[0]);\n    var lastDayInMonth = (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(displayMonths[displayMonths.length - 1]);\n    // TODO: cleanup code\n    var firstFocusableDay;\n    var today;\n    var date = firstDayInMonth;\n    while(date <= lastDayInMonth){\n        var activeModifiers = getActiveModifiers(date, modifiers);\n        var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;\n        if (!isFocusable) {\n            date = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(date, 1);\n            continue;\n        }\n        if (activeModifiers.selected) {\n            return date;\n        }\n        if (activeModifiers.today && !today) {\n            today = date;\n        }\n        if (!firstFocusableDay) {\n            firstFocusableDay = date;\n        }\n        date = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(date, 1);\n    }\n    if (today) {\n        return today;\n    } else {\n        return firstFocusableDay;\n    }\n}\nvar MAX_RETRY = 365;\n/** Return the next date to be focused. */ function getNextFocus(focusedDay, options) {\n    var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a = options.retry, retry = _a === void 0 ? {\n        count: 0,\n        lastFocused: focusedDay\n    } : _a;\n    var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate = context.toDate, locale = context.locale;\n    var moveFns = {\n        day: date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n        week: date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n        month: date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        year: date_fns_addYears__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n        startOfWeek: function(date) {\n            return context.ISOWeek ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(date) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(date, {\n                locale: locale,\n                weekStartsOn: weekStartsOn\n            });\n        },\n        endOfWeek: function(date) {\n            return context.ISOWeek ? (0,date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(date) : (0,date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(date, {\n                locale: locale,\n                weekStartsOn: weekStartsOn\n            });\n        }\n    };\n    var newFocusedDay = moveFns[moveBy](focusedDay, direction === \"after\" ? 1 : -1);\n    if (direction === \"before\" && fromDate) {\n        newFocusedDay = (0,date_fns_max__WEBPACK_IMPORTED_MODULE_26__[\"default\"])([\n            fromDate,\n            newFocusedDay\n        ]);\n    } else if (direction === \"after\" && toDate) {\n        newFocusedDay = (0,date_fns_min__WEBPACK_IMPORTED_MODULE_27__[\"default\"])([\n            toDate,\n            newFocusedDay\n        ]);\n    }\n    var isFocusable = true;\n    if (modifiers) {\n        var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);\n        isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;\n    }\n    if (isFocusable) {\n        return newFocusedDay;\n    } else {\n        if (retry.count > MAX_RETRY) {\n            return retry.lastFocused;\n        }\n        return getNextFocus(newFocusedDay, {\n            moveBy: moveBy,\n            direction: direction,\n            context: context,\n            modifiers: modifiers,\n            retry: __assign(__assign({}, retry), {\n                count: retry.count + 1\n            })\n        });\n    }\n}\n/**\n * The Focus context shares details about the focused day for the keyboard\n *\n * Access this context from the {@link useFocusContext} hook.\n */ var FocusContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** The provider for the {@link FocusContext}. */ function FocusProvider(props) {\n    var navigation = useNavigation();\n    var modifiers = useModifiers();\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), focusedDay = _a[0], setFocusedDay = _a[1];\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), lastFocused = _b[0], setLastFocused = _b[1];\n    var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);\n    // TODO: cleanup and test obscure code below\n    var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : lastFocused && navigation.isDateDisplayed(lastFocused)) ? lastFocused : initialFocusTarget;\n    var blur = function() {\n        setLastFocused(focusedDay);\n        setFocusedDay(undefined);\n    };\n    var focus = function(date) {\n        setFocusedDay(date);\n    };\n    var context = useDayPicker();\n    var moveFocus = function(moveBy, direction) {\n        if (!focusedDay) return;\n        var nextFocused = getNextFocus(focusedDay, {\n            moveBy: moveBy,\n            direction: direction,\n            context: context,\n            modifiers: modifiers\n        });\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusedDay, nextFocused)) return undefined;\n        navigation.goToDate(nextFocused, focusedDay);\n        focus(nextFocused);\n    };\n    var value = {\n        focusedDay: focusedDay,\n        focusTarget: focusTarget,\n        blur: blur,\n        focus: focus,\n        focusDayAfter: function() {\n            return moveFocus(\"day\", \"after\");\n        },\n        focusDayBefore: function() {\n            return moveFocus(\"day\", \"before\");\n        },\n        focusWeekAfter: function() {\n            return moveFocus(\"week\", \"after\");\n        },\n        focusWeekBefore: function() {\n            return moveFocus(\"week\", \"before\");\n        },\n        focusMonthBefore: function() {\n            return moveFocus(\"month\", \"before\");\n        },\n        focusMonthAfter: function() {\n            return moveFocus(\"month\", \"after\");\n        },\n        focusYearBefore: function() {\n            return moveFocus(\"year\", \"before\");\n        },\n        focusYearAfter: function() {\n            return moveFocus(\"year\", \"after\");\n        },\n        focusStartOfWeek: function() {\n            return moveFocus(\"startOfWeek\", \"before\");\n        },\n        focusEndOfWeek: function() {\n            return moveFocus(\"endOfWeek\", \"after\");\n        }\n    };\n    return jsxRuntimeExports.jsx(FocusContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link FocusContextValue}. Use this hook to handle the\n * focus state of the elements.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useFocusContext() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FocusContext);\n    if (!context) {\n        throw new Error(\"useFocusContext must be used within a FocusProvider\");\n    }\n    return context;\n}\n/**\n * Return the active modifiers for the specified day.\n *\n * This hook is meant to be used inside internal or custom components.\n *\n * @param day\n * @param displayMonth\n */ function useActiveModifiers(day, /**\n * The month where the date is displayed. If not the same as `date`, the day\n * is an \"outside day\".\n */ displayMonth) {\n    var modifiers = useModifiers();\n    var activeModifiers = getActiveModifiers(day, modifiers, displayMonth);\n    return activeModifiers;\n}\n/**\n * The SelectSingle context shares details about the selected days when in\n * single selection mode.\n *\n * Access this context from the {@link useSelectSingle} hook.\n */ var SelectSingleContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectSingleProvider}. */ function SelectSingleProvider(props) {\n    if (!isDayPickerSingle(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined\n        };\n        return jsxRuntimeExports.jsx(SelectSingleContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectSingleProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectSingleProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b, _c;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        if (activeModifiers.selected && !initialProps.required) {\n            (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, undefined, day, activeModifiers, e);\n            return;\n        }\n        (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day, day, activeModifiers, e);\n    };\n    var contextValue = {\n        selected: initialProps.selected,\n        onDayClick: onDayClick\n    };\n    return jsxRuntimeExports.jsx(SelectSingleContext.Provider, __assign({\n        value: contextValue\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectSingleContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectSingle() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectSingleContext);\n    if (!context) {\n        throw new Error(\"useSelectSingle must be used within a SelectSingleProvider\");\n    }\n    return context;\n}\n/**\n * This hook returns details about the content to render in the day cell.\n *\n *\n * When a day cell is rendered in the table, DayPicker can either:\n *\n * - render nothing: when the day is outside the month or has matched the\n *   \"hidden\" modifier.\n * - render a button when `onDayClick` or a selection mode is set.\n * - render a non-interactive element: when no selection mode is set, the day\n *   cell shouldn’t respond to any interaction. DayPicker should render a `div`\n *   or a `span`.\n *\n * ### Usage\n *\n * Use this hook to customize the behavior of the {@link Day} component. Create a\n * new `Day` component using this hook and pass it to the `components` prop.\n * The source of {@link Day} can be a good starting point.\n *\n */ function useDayEventHandlers(date, activeModifiers) {\n    var dayPicker = useDayPicker();\n    var single = useSelectSingle();\n    var multiple = useSelectMultiple();\n    var range = useSelectRange();\n    var _a = useFocusContext(), focusDayAfter = _a.focusDayAfter, focusDayBefore = _a.focusDayBefore, focusWeekAfter = _a.focusWeekAfter, focusWeekBefore = _a.focusWeekBefore, blur = _a.blur, focus = _a.focus, focusMonthBefore = _a.focusMonthBefore, focusMonthAfter = _a.focusMonthAfter, focusYearBefore = _a.focusYearBefore, focusYearAfter = _a.focusYearAfter, focusStartOfWeek = _a.focusStartOfWeek, focusEndOfWeek = _a.focusEndOfWeek;\n    var onClick = function(e) {\n        var _a, _b, _c, _d;\n        if (isDayPickerSingle(dayPicker)) {\n            (_a = single.onDayClick) === null || _a === void 0 ? void 0 : _a.call(single, date, activeModifiers, e);\n        } else if (isDayPickerMultiple(dayPicker)) {\n            (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e);\n        } else if (isDayPickerRange(dayPicker)) {\n            (_c = range.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range, date, activeModifiers, e);\n        } else {\n            (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e);\n        }\n    };\n    var onFocus = function(e) {\n        var _a;\n        focus(date);\n        (_a = dayPicker.onDayFocus) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onBlur = function(e) {\n        var _a;\n        blur();\n        (_a = dayPicker.onDayBlur) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onMouseEnter = function(e) {\n        var _a;\n        (_a = dayPicker.onDayMouseEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onMouseLeave = function(e) {\n        var _a;\n        (_a = dayPicker.onDayMouseLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onPointerEnter = function(e) {\n        var _a;\n        (_a = dayPicker.onDayPointerEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onPointerLeave = function(e) {\n        var _a;\n        (_a = dayPicker.onDayPointerLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchCancel = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchCancel) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchEnd = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchEnd) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchMove = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchMove) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchStart = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchStart) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onKeyUp = function(e) {\n        var _a;\n        (_a = dayPicker.onDayKeyUp) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onKeyDown = function(e) {\n        var _a;\n        switch(e.key){\n            case \"ArrowLeft\":\n                e.preventDefault();\n                e.stopPropagation();\n                dayPicker.dir === \"rtl\" ? focusDayAfter() : focusDayBefore();\n                break;\n            case \"ArrowRight\":\n                e.preventDefault();\n                e.stopPropagation();\n                dayPicker.dir === \"rtl\" ? focusDayBefore() : focusDayAfter();\n                break;\n            case \"ArrowDown\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusWeekAfter();\n                break;\n            case \"ArrowUp\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusWeekBefore();\n                break;\n            case \"PageUp\":\n                e.preventDefault();\n                e.stopPropagation();\n                e.shiftKey ? focusYearBefore() : focusMonthBefore();\n                break;\n            case \"PageDown\":\n                e.preventDefault();\n                e.stopPropagation();\n                e.shiftKey ? focusYearAfter() : focusMonthAfter();\n                break;\n            case \"Home\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusStartOfWeek();\n                break;\n            case \"End\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusEndOfWeek();\n                break;\n        }\n        (_a = dayPicker.onDayKeyDown) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var eventHandlers = {\n        onClick: onClick,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        onKeyDown: onKeyDown,\n        onKeyUp: onKeyUp,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onPointerEnter: onPointerEnter,\n        onPointerLeave: onPointerLeave,\n        onTouchCancel: onTouchCancel,\n        onTouchEnd: onTouchEnd,\n        onTouchMove: onTouchMove,\n        onTouchStart: onTouchStart\n    };\n    return eventHandlers;\n}\n/**\n * Return the current selected days when DayPicker is in selection mode. Days\n * selected by the custom selection mode are not returned.\n *\n * This hook is meant to be used inside internal or custom components.\n *\n */ function useSelectedDays() {\n    var dayPicker = useDayPicker();\n    var single = useSelectSingle();\n    var multiple = useSelectMultiple();\n    var range = useSelectRange();\n    var selectedDays = isDayPickerSingle(dayPicker) ? single.selected : isDayPickerMultiple(dayPicker) ? multiple.selected : isDayPickerRange(dayPicker) ? range.selected : undefined;\n    return selectedDays;\n}\nfunction isInternalModifier(modifier) {\n    return Object.values(InternalModifier).includes(modifier);\n}\n/**\n * Return the class names for the Day element, according to the given active\n * modifiers.\n *\n * Custom class names are set via `modifiersClassNames` or `classNames`,\n * where the first have the precedence.\n */ function getDayClassNames(dayPicker, activeModifiers) {\n    var classNames = [\n        dayPicker.classNames.day\n    ];\n    Object.keys(activeModifiers).forEach(function(modifier) {\n        var customClassName = dayPicker.modifiersClassNames[modifier];\n        if (customClassName) {\n            classNames.push(customClassName);\n        } else if (isInternalModifier(modifier)) {\n            var internalClassName = dayPicker.classNames[\"day_\".concat(modifier)];\n            if (internalClassName) {\n                classNames.push(internalClassName);\n            }\n        }\n    });\n    return classNames;\n}\n/** Return the style for the Day element, according to the given active modifiers. */ function getDayStyle(dayPicker, activeModifiers) {\n    var style = __assign({}, dayPicker.styles.day);\n    Object.keys(activeModifiers).forEach(function(modifier) {\n        var _a;\n        style = __assign(__assign({}, style), (_a = dayPicker.modifiersStyles) === null || _a === void 0 ? void 0 : _a[modifier]);\n    });\n    return style;\n}\n/**\n * Return props and data used to render the {@link Day} component.\n *\n * Use this hook when creating a component to replace the built-in `Day`\n * component.\n */ function useDayRender(/** The date to render. */ day, /** The month where the date is displayed (if not the same as `date`, it means it is an \"outside\" day). */ displayMonth, /** A ref to the button element that will be target of focus when rendered (if required). */ buttonRef) {\n    var _a;\n    var _b, _c;\n    var dayPicker = useDayPicker();\n    var focusContext = useFocusContext();\n    var activeModifiers = useActiveModifiers(day, displayMonth);\n    var eventHandlers = useDayEventHandlers(day, activeModifiers);\n    var selectedDays = useSelectedDays();\n    var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== \"default\");\n    // Focus the button if the day is focused according to the focus context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var _a;\n        if (activeModifiers.outside) return;\n        if (!focusContext.focusedDay) return;\n        if (!isButton) return;\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusedDay, day)) {\n            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n    }, [\n        focusContext.focusedDay,\n        day,\n        buttonRef,\n        isButton,\n        activeModifiers.outside\n    ]);\n    var className = getDayClassNames(dayPicker, activeModifiers).join(\" \");\n    var style = getDayStyle(dayPicker, activeModifiers);\n    var isHidden = Boolean(activeModifiers.outside && !dayPicker.showOutsideDays || activeModifiers.hidden);\n    var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;\n    var children = jsxRuntimeExports.jsx(DayContentComponent, {\n        date: day,\n        displayMonth: displayMonth,\n        activeModifiers: activeModifiers\n    });\n    var divProps = {\n        style: style,\n        className: className,\n        children: children,\n        role: \"gridcell\"\n    };\n    var isFocusTarget = focusContext.focusTarget && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusTarget, day) && !activeModifiers.outside;\n    var isFocused = focusContext.focusedDay && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusedDay, day);\n    var buttonProps = __assign(__assign(__assign({}, divProps), (_a = {\n        disabled: activeModifiers.disabled,\n        role: \"gridcell\"\n    }, _a[\"aria-selected\"] = activeModifiers.selected, _a.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a)), eventHandlers);\n    var dayRender = {\n        isButton: isButton,\n        isHidden: isHidden,\n        activeModifiers: activeModifiers,\n        selectedDays: selectedDays,\n        buttonProps: buttonProps,\n        divProps: divProps\n    };\n    return dayRender;\n}\n/**\n * The content of a day cell – as a button or span element according to its\n * modifiers.\n */ function Day(props) {\n    var buttonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);\n    if (dayRender.isHidden) {\n        return jsxRuntimeExports.jsx(\"div\", {\n            role: \"gridcell\"\n        });\n    }\n    if (!dayRender.isButton) {\n        return jsxRuntimeExports.jsx(\"div\", __assign({}, dayRender.divProps));\n    }\n    return jsxRuntimeExports.jsx(Button, __assign({\n        name: \"day\",\n        ref: buttonRef\n    }, dayRender.buttonProps));\n}\n/**\n * Render the week number element. If `onWeekNumberClick` is passed to DayPicker, it\n * renders a button, otherwise a span element.\n */ function WeekNumber(props) {\n    var weekNumber = props.number, dates = props.dates;\n    var _a = useDayPicker(), onWeekNumberClick = _a.onWeekNumberClick, styles = _a.styles, classNames = _a.classNames, locale = _a.locale, labelWeekNumber = _a.labels.labelWeekNumber, formatWeekNumber = _a.formatters.formatWeekNumber;\n    var content = formatWeekNumber(Number(weekNumber), {\n        locale: locale\n    });\n    if (!onWeekNumberClick) {\n        return jsxRuntimeExports.jsx(\"span\", __assign({\n            className: classNames.weeknumber,\n            style: styles.weeknumber\n        }, {\n            children: content\n        }));\n    }\n    var label = labelWeekNumber(Number(weekNumber), {\n        locale: locale\n    });\n    var handleClick = function(e) {\n        onWeekNumberClick(weekNumber, dates, e);\n    };\n    return jsxRuntimeExports.jsx(Button, __assign({\n        name: \"week-number\",\n        \"aria-label\": label,\n        className: classNames.weeknumber,\n        style: styles.weeknumber,\n        onClick: handleClick\n    }, {\n        children: content\n    }));\n}\n/** Render a row in the calendar, with the days and the week number. */ function Row(props) {\n    var _a, _b;\n    var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;\n    var DayComponent = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : Day;\n    var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;\n    var weekNumberCell;\n    if (showWeekNumber) {\n        weekNumberCell = jsxRuntimeExports.jsx(\"td\", __assign({\n            className: classNames.cell,\n            style: styles.cell\n        }, {\n            children: jsxRuntimeExports.jsx(WeeknumberComponent, {\n                number: props.weekNumber,\n                dates: props.dates\n            })\n        }));\n    }\n    return jsxRuntimeExports.jsxs(\"tr\", __assign({\n        className: classNames.row,\n        style: styles.row\n    }, {\n        children: [\n            weekNumberCell,\n            props.dates.map(function(date) {\n                return jsxRuntimeExports.jsx(\"td\", __assign({\n                    className: classNames.cell,\n                    style: styles.cell,\n                    role: \"presentation\"\n                }, {\n                    children: jsxRuntimeExports.jsx(DayComponent, {\n                        displayMonth: props.displayMonth,\n                        date: date\n                    })\n                }), (0,date_fns_getUnixTime__WEBPACK_IMPORTED_MODULE_28__[\"default\"])(date));\n            })\n        ]\n    }));\n}\n/** Return the weeks between two dates.  */ function daysToMonthWeeks(fromDate, toDate, options) {\n    var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(toDate) : (0,date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(toDate, options);\n    var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(fromDate) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(fromDate, options);\n    var nOfDays = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(toWeek, fromWeek);\n    var days = [];\n    for(var i = 0; i <= nOfDays; i++){\n        days.push((0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(fromWeek, i));\n    }\n    var weeksInMonth = days.reduce(function(result, date) {\n        var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_getISOWeek__WEBPACK_IMPORTED_MODULE_29__[\"default\"])(date) : (0,date_fns_getWeek__WEBPACK_IMPORTED_MODULE_30__[\"default\"])(date, options);\n        var existingWeek = result.find(function(value) {\n            return value.weekNumber === weekNumber;\n        });\n        if (existingWeek) {\n            existingWeek.dates.push(date);\n            return result;\n        }\n        result.push({\n            weekNumber: weekNumber,\n            dates: [\n                date\n            ]\n        });\n        return result;\n    }, []);\n    return weeksInMonth;\n}\n/**\n * Return the weeks belonging to the given month, adding the \"outside days\" to\n * the first and last week.\n */ function getMonthWeeks(month, options) {\n    var weeksInMonth = daysToMonthWeeks((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(month), (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(month), options);\n    if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {\n        // Add extra weeks to the month, up to 6 weeks\n        var nrOfMonthWeeks = (0,date_fns_getWeeksInMonth__WEBPACK_IMPORTED_MODULE_31__[\"default\"])(month, options);\n        if (nrOfMonthWeeks < 6) {\n            var lastWeek = weeksInMonth[weeksInMonth.length - 1];\n            var lastDate = lastWeek.dates[lastWeek.dates.length - 1];\n            var toDate = (0,date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"])(lastDate, 6 - nrOfMonthWeeks);\n            var extraWeeks = daysToMonthWeeks((0,date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"])(lastDate, 1), toDate, options);\n            weeksInMonth.push.apply(weeksInMonth, extraWeeks);\n        }\n    }\n    return weeksInMonth;\n}\n/** Render the table with the calendar. */ function Table(props) {\n    var _a, _b, _c;\n    var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;\n    var weeks = getMonthWeeks(props.displayMonth, {\n        useFixedWeeks: Boolean(fixedWeeks),\n        ISOWeek: ISOWeek,\n        locale: locale,\n        weekStartsOn: weekStartsOn,\n        firstWeekContainsDate: firstWeekContainsDate\n    });\n    var HeadComponent = (_a = components === null || components === void 0 ? void 0 : components.Head) !== null && _a !== void 0 ? _a : Head;\n    var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : Row;\n    var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;\n    return jsxRuntimeExports.jsxs(\"table\", __assign({\n        id: props.id,\n        className: classNames.table,\n        style: styles.table,\n        role: \"grid\",\n        \"aria-labelledby\": props[\"aria-labelledby\"]\n    }, {\n        children: [\n            !hideHead && jsxRuntimeExports.jsx(HeadComponent, {}),\n            jsxRuntimeExports.jsx(\"tbody\", __assign({\n                className: classNames.tbody,\n                style: styles.tbody\n            }, {\n                children: weeks.map(function(week) {\n                    return jsxRuntimeExports.jsx(RowComponent, {\n                        displayMonth: props.displayMonth,\n                        dates: week.dates,\n                        weekNumber: week.weekNumber\n                    }, week.weekNumber);\n                })\n            })),\n            jsxRuntimeExports.jsx(FooterComponent, {\n                displayMonth: props.displayMonth\n            })\n        ]\n    }));\n}\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2018-present, React Training LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ /* eslint-disable prefer-const */ /* eslint-disable @typescript-eslint/ban-ts-comment */ /*\n * Welcome to @reach/auto-id!\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibility APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */ function canUseDOM() {\n    return !!( false && 0);\n}\n/**\n * React currently throws a warning when using useLayoutEffect on the server. To\n * get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\n * ensure we don't get a render flash for certain operations, but we may also\n * need affected components to render on the server. One example is when setting\n * a component's descendants to retrieve their index values.\n *\n * Important to note that using this hook as an escape hatch will break the\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\n * any server/client mismatch.\n *\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\n * likely that the component in question shouldn't be rendered on the server at\n * all, so a better approach would be to lazily render those in a parent\n * component after client-side hydration.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n *\n * @param effect\n * @param deps\n */ var useIsomorphicLayoutEffect = canUseDOM() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar serverHandoffComplete = false;\nvar id = 0;\nfunction genId() {\n    return \"react-day-picker-\".concat(++id);\n}\nfunction useId(providedId) {\n    // TODO: Remove error flag when updating internal deps to React 18. None of\n    // our tricks will play well with concurrent rendering anyway.\n    var _a;\n    // If this instance isn't part of the initial render, we don't have to do the\n    // double render/patch-up dance. We can just generate the ID and return it.\n    var initialId = providedId !== null && providedId !== void 0 ? providedId : serverHandoffComplete ? genId() : null;\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialId), id = _b[0], setId = _b[1];\n    useIsomorphicLayoutEffect(function() {\n        if (id === null) {\n            // Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n            // rendering flicker, though it'll make the first render slower (unlikely\n            // to matter, but you're welcome to measure your app and let us know if\n            // it's a problem).\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (serverHandoffComplete === false) {\n            // Flag all future uses of `useId` to skip the update dance. This is in\n            // `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n            // accidentally bail out of the patch-up dance prematurely.\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return (_a = providedId !== null && providedId !== void 0 ? providedId : id) !== null && _a !== void 0 ? _a : undefined;\n}\n/** Render a month. */ function Month(props) {\n    var _a;\n    var _b;\n    var dayPicker = useDayPicker();\n    var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;\n    var displayMonths = useNavigation().displayMonths;\n    var captionId = useId(dayPicker.id ? \"\".concat(dayPicker.id, \"-\").concat(props.displayIndex) : undefined);\n    var tableId = dayPicker.id ? \"\".concat(dayPicker.id, \"-grid-\").concat(props.displayIndex) : undefined;\n    var className = [\n        classNames.month\n    ];\n    var style = styles.month;\n    var isStart = props.displayIndex === 0;\n    var isEnd = props.displayIndex === displayMonths.length - 1;\n    var isCenter = !isStart && !isEnd;\n    if (dir === \"rtl\") {\n        _a = [\n            isStart,\n            isEnd\n        ], isEnd = _a[0], isStart = _a[1];\n    }\n    if (isStart) {\n        className.push(classNames.caption_start);\n        style = __assign(__assign({}, style), styles.caption_start);\n    }\n    if (isEnd) {\n        className.push(classNames.caption_end);\n        style = __assign(__assign({}, style), styles.caption_end);\n    }\n    if (isCenter) {\n        className.push(classNames.caption_between);\n        style = __assign(__assign({}, style), styles.caption_between);\n    }\n    var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: className.join(\" \"),\n        style: style\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(CaptionComponent, {\n                id: captionId,\n                displayMonth: props.displayMonth,\n                displayIndex: props.displayIndex\n            }),\n            jsxRuntimeExports.jsx(Table, {\n                id: tableId,\n                \"aria-labelledby\": captionId,\n                displayMonth: props.displayMonth\n            })\n        ]\n    }), props.displayIndex);\n}\n/**\n * Render the wrapper for the month grids.\n */ function Months(props) {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.months,\n        style: styles.months\n    }, {\n        children: props.children\n    }));\n}\n/** Render the container with the months according to the number of months to display. */ function Root(_a) {\n    var _b, _c;\n    var initialProps = _a.initialProps;\n    var dayPicker = useDayPicker();\n    var focusContext = useFocusContext();\n    var navigation = useNavigation();\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), hasInitialFocus = _d[0], setHasInitialFocus = _d[1];\n    // Focus the focus target when initialFocus is passed in\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!dayPicker.initialFocus) return;\n        if (!focusContext.focusTarget) return;\n        if (hasInitialFocus) return;\n        focusContext.focus(focusContext.focusTarget);\n        setHasInitialFocus(true);\n    }, [\n        dayPicker.initialFocus,\n        hasInitialFocus,\n        focusContext.focus,\n        focusContext.focusTarget,\n        focusContext\n    ]);\n    // Apply classnames according to props\n    var classNames = [\n        dayPicker.classNames.root,\n        dayPicker.className\n    ];\n    if (dayPicker.numberOfMonths > 1) {\n        classNames.push(dayPicker.classNames.multiple_months);\n    }\n    if (dayPicker.showWeekNumber) {\n        classNames.push(dayPicker.classNames.with_weeknumber);\n    }\n    var style = __assign(__assign({}, dayPicker.styles.root), dayPicker.style);\n    var dataAttributes = Object.keys(initialProps).filter(function(key) {\n        return key.startsWith(\"data-\");\n    }).reduce(function(attrs, key) {\n        var _a;\n        return __assign(__assign({}, attrs), (_a = {}, _a[key] = initialProps[key], _a));\n    }, {});\n    var MonthsComponent = (_c = (_b = initialProps.components) === null || _b === void 0 ? void 0 : _b.Months) !== null && _c !== void 0 ? _c : Months;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.join(\" \"),\n        style: style,\n        dir: dayPicker.dir,\n        id: dayPicker.id,\n        nonce: initialProps.nonce,\n        title: initialProps.title,\n        lang: initialProps.lang\n    }, dataAttributes, {\n        children: jsxRuntimeExports.jsx(MonthsComponent, {\n            children: navigation.displayMonths.map(function(month, i) {\n                return jsxRuntimeExports.jsx(Month, {\n                    displayIndex: i,\n                    displayMonth: month\n                }, i);\n            })\n        })\n    }));\n}\n/** Provide the value for all the context providers. */ function RootProvider(props) {\n    var children = props.children, initialProps = __rest(props, [\n        \"children\"\n    ]);\n    return jsxRuntimeExports.jsx(DayPickerProvider, __assign({\n        initialProps: initialProps\n    }, {\n        children: jsxRuntimeExports.jsx(NavigationProvider, {\n            children: jsxRuntimeExports.jsx(SelectSingleProvider, __assign({\n                initialProps: initialProps\n            }, {\n                children: jsxRuntimeExports.jsx(SelectMultipleProvider, __assign({\n                    initialProps: initialProps\n                }, {\n                    children: jsxRuntimeExports.jsx(SelectRangeProvider, __assign({\n                        initialProps: initialProps\n                    }, {\n                        children: jsxRuntimeExports.jsx(ModifiersProvider, {\n                            children: jsxRuntimeExports.jsx(FocusProvider, {\n                                children: children\n                            })\n                        })\n                    }))\n                }))\n            }))\n        })\n    }));\n}\n/**\n * DayPicker render a date picker component to let users pick dates from a\n * calendar. See http://react-day-picker.js.org for updated documentation and\n * examples.\n *\n * ### Customization\n *\n * DayPicker offers different customization props. For example,\n *\n * - show multiple months using `numberOfMonths`\n * - display a dropdown to navigate the months via `captionLayout`\n * - display the week numbers with `showWeekNumbers`\n * - disable or hide days with `disabled` or `hidden`\n *\n * ### Controlling the months\n *\n * Change the initially displayed month using the `defaultMonth` prop. The\n * displayed months are controlled by DayPicker and stored in its internal\n * state. To control the months yourself, use `month` instead of `defaultMonth`\n * and use the `onMonthChange` event to set it.\n *\n * To limit the months the user can navigate to, use\n * `fromDate`/`fromMonth`/`fromYear` or `toDate`/`toMonth`/`toYear`.\n *\n * ### Selection modes\n *\n * DayPicker supports different selection mode that can be toggled using the\n * `mode` prop:\n *\n * - `mode=\"single\"`: only one day can be selected. Use `required` to make the\n *   selection required. Use the `onSelect` event handler to get the selected\n *   days.\n * - `mode=\"multiple\"`: users can select one or more days. Limit the amount of\n *   days that can be selected with the `min` or the `max` props.\n * - `mode=\"range\"`: users can select a range of days. Limit the amount of days\n *   in the range with the `min` or the `max` props.\n * - `mode=\"default\"` (default): the built-in selections are disabled. Implement\n *   your own selection mode with `onDayClick`.\n *\n * The selection modes should cover the most common use cases. In case you\n * need a more refined way of selecting days, use `mode=\"default\"`. Use the\n * `selected` props and add the day event handlers to add/remove days from the\n * selection.\n *\n * ### Modifiers\n *\n * A _modifier_ represents different styles or states for the days displayed in\n * the calendar (like \"selected\" or \"disabled\"). Define custom modifiers using\n * the `modifiers` prop.\n *\n * ### Formatters and custom component\n *\n * You can customize how the content is displayed in the date picker by using\n * either the formatters or replacing the internal components.\n *\n * For the most common cases you want to use the `formatters` prop to change how\n * the content is formatted in the calendar. Use the `components` prop to\n * replace the internal components, like the navigation icons.\n *\n * ### Styling\n *\n * DayPicker comes with a default, basic style in `react-day-picker/style` – use\n * it as template for your own style.\n *\n * If you are using CSS modules, pass the imported styles object the\n * `classNames` props.\n *\n * You can also style the elements via inline styles using the `styles` prop.\n *\n * ### Form fields\n *\n * If you need to bind the date picker to a form field, you can use the\n * `useInput` hooks for a basic behavior. See the `useInput` source as an\n * example to bind the date picker with form fields.\n *\n * ### Localization\n *\n * To localize DayPicker, import the locale from `date-fns` package and use the\n * `locale` prop.\n *\n * For example, to use Spanish locale:\n *\n * ```\n * import { es } from 'date-fns/locale';\n * <DayPicker locale={es} />\n * ```\n */ function DayPicker(props) {\n    return jsxRuntimeExports.jsx(RootProvider, __assign({}, props, {\n        children: jsxRuntimeExports.jsx(Root, {\n            initialProps: props\n        })\n    }));\n}\n/** @private */ function isValidDate(day) {\n    return !isNaN(day.getTime());\n}\n/** Return props and setters for binding an input field to DayPicker. */ function useInput(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.locale, locale = _a === void 0 ? date_fns_locale__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : _a, required = options.required, _b = options.format, format$1 = _b === void 0 ? \"PP\" : _b, defaultSelected = options.defaultSelected, _c = options.today, today = _c === void 0 ? new Date() : _c;\n    var _d = parseFromToProps(options), fromDate = _d.fromDate, toDate = _d.toDate;\n    // Shortcut to the DateFns functions\n    var parseValue = function(value) {\n        return (0,date_fns_parse__WEBPACK_IMPORTED_MODULE_32__[\"default\"])(value, format$1, today, {\n            locale: locale\n        });\n    };\n    // Initialize states\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today), month = _e[0], setMonth = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultSelected), selectedDay = _f[0], setSelectedDay = _f[1];\n    var defaultInputValue = defaultSelected ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(defaultSelected, format$1, {\n        locale: locale\n    }) : \"\";\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultInputValue), inputValue = _g[0], setInputValue = _g[1];\n    var reset = function() {\n        setSelectedDay(defaultSelected);\n        setMonth(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today);\n        setInputValue(defaultInputValue !== null && defaultInputValue !== void 0 ? defaultInputValue : \"\");\n    };\n    var setSelected = function(date) {\n        setSelectedDay(date);\n        setMonth(date !== null && date !== void 0 ? date : today);\n        setInputValue(date ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(date, format$1, {\n            locale: locale\n        }) : \"\");\n    };\n    var handleDayClick = function(day, _a) {\n        var selected = _a.selected;\n        if (!required && selected) {\n            setSelectedDay(undefined);\n            setInputValue(\"\");\n            return;\n        }\n        setSelectedDay(day);\n        setInputValue(day ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, format$1, {\n            locale: locale\n        }) : \"\");\n    };\n    var handleMonthChange = function(month) {\n        setMonth(month);\n    };\n    // When changing the input field, save its value in state and check if the\n    // string is a valid date. If it is a valid day, set it as selected and update\n    // the calendar’s month.\n    var handleChange = function(e) {\n        setInputValue(e.target.value);\n        var day = parseValue(e.target.value);\n        var isBefore = fromDate && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(fromDate, day) > 0;\n        var isAfter = toDate && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(day, toDate) > 0;\n        if (!isValidDate(day) || isBefore || isAfter) {\n            setSelectedDay(undefined);\n            return;\n        }\n        setSelectedDay(day);\n        setMonth(day);\n    };\n    // Special case for _required_ fields: on blur, if the value of the input is not\n    // a valid date, reset the calendar and the input value.\n    var handleBlur = function(e) {\n        var day = parseValue(e.target.value);\n        if (!isValidDate(day)) {\n            reset();\n        }\n    };\n    // When focusing, make sure DayPicker visualizes the month of the date in the\n    // input field.\n    var handleFocus = function(e) {\n        if (!e.target.value) {\n            reset();\n            return;\n        }\n        var day = parseValue(e.target.value);\n        if (isValidDate(day)) {\n            setMonth(day);\n        }\n    };\n    var dayPickerProps = {\n        month: month,\n        onDayClick: handleDayClick,\n        onMonthChange: handleMonthChange,\n        selected: selectedDay,\n        locale: locale,\n        fromDate: fromDate,\n        toDate: toDate,\n        today: today\n    };\n    var inputProps = {\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onFocus: handleFocus,\n        value: inputValue,\n        placeholder: (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Date(), format$1, {\n            locale: locale\n        })\n    };\n    return {\n        dayPickerProps: dayPickerProps,\n        inputProps: inputProps,\n        reset: reset,\n        setSelected: setSelected\n    };\n}\n/** Returns true when the props are of type {@link DayPickerDefaultProps}. */ function isDayPickerDefault(props) {\n    return props.mode === undefined || props.mode === \"default\";\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF5LXBpY2tlci9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3SDtBQUNnUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNqVztBQUV2Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsb0RBQW9ELEdBR3BELElBQUl3QyxXQUFXO0lBQ1hBLFdBQVdDLE9BQU9DLE1BQU0sSUFBSSxTQUFTRixTQUFTRyxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVILElBQUlDLEdBQUdELElBQUs7WUFDakRELElBQUlHLFNBQVMsQ0FBQ0YsRUFBRTtZQUNoQixJQUFLLElBQUlJLEtBQUtMLEVBQUcsSUFBSUgsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUNoRjtRQUNBLE9BQU9OO0lBQ1g7SUFDQSxPQUFPSCxTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFTjtBQUNoQztBQUVBLFNBQVNPLE9BQU9WLENBQUMsRUFBRVcsQ0FBQztJQUNoQixJQUFJWixJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlNLEtBQUtMLEVBQUcsSUFBSUgsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssTUFBTU0sRUFBRUMsT0FBTyxDQUFDUCxL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O0lBQ0o7SUFDQSxJQUFJNGEsaUJBQWlCO1FBQ2pCM2IsT0FBT0E7UUFDUDRMLFlBQVk0UDtRQUNadFUsZUFBZXVCO1FBQ2ZpRCxVQUFVUTtRQUNWbEosUUFBUUE7UUFDUlksVUFBVUE7UUFDVkMsUUFBUUE7UUFDUlIsT0FBT0E7SUFDWDtJQUNBLElBQUl1WSxhQUFhO1FBQ2JwSSxRQUFRaUk7UUFDUnBXLFVBQVVRO1FBQ1Z5TixTQUFTb0k7UUFDVHZsQixPQUFPaWxCO1FBQ1BTLGFBQWFweEIsMkRBQU1BLENBQUMsSUFBSTZZLFFBQVFzWCxVQUFVO1lBQUU1WCxRQUFRQTtRQUFPO0lBQy9EO0lBQ0EsT0FBTztRQUFFMlksZ0JBQWdCQTtRQUFnQkMsWUFBWUE7UUFBWU4sT0FBT0E7UUFBT0MsYUFBYUE7SUFBWTtBQUM1RztBQUVBLDJFQUEyRSxHQUMzRSxTQUFTTyxtQkFBbUJ6ckIsS0FBSztJQUM3QixPQUFPQSxNQUFNc08sSUFBSSxLQUFLaEwsYUFBYXRELE1BQU1zTyxJQUFJLEtBQUs7QUFDdEQ7QUFFZzNCLENBQ2gzQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9yeWJvb2stc2hhZGNuLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRheS1waWNrZXIvZGlzdC9pbmRleC5lc20uanM/NmYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWlyZSQkMCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgZm9yd2FyZFJlZiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZvcm1hdCwgc3RhcnRPZk1vbnRoLCBlbmRPZk1vbnRoLCBzdGFydE9mRGF5LCBpc1NhbWVZZWFyLCBzZXRNb250aCwgc2V0WWVhciwgc3RhcnRPZlllYXIsIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzLCBhZGRNb250aHMsIGlzU2FtZU1vbnRoLCBpc0JlZm9yZSwgc3RhcnRPZklTT1dlZWssIHN0YXJ0T2ZXZWVrLCBhZGREYXlzLCBpc1NhbWVEYXksIGlzQWZ0ZXIsIHN1YkRheXMsIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cywgaXNEYXRlLCBtYXgsIG1pbiwgYWRkV2Vla3MsIGFkZFllYXJzLCBlbmRPZklTT1dlZWssIGVuZE9mV2VlaywgZ2V0VW5peFRpbWUsIGdldElTT1dlZWssIGdldFdlZWssIGdldFdlZWtzSW5Nb250aCwgcGFyc2UgfSBmcm9tICdkYXRlLWZucyc7XG5pbXBvcnQgeyBlblVTIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIganN4UnVudGltZSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4gPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4pIHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG5cdGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluID0gMTtcbnZhciBmPXJlcXVpcmUkJDAsaz1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxsPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxtPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbj1mLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcblx0ZnVuY3Rpb24gcShjLGEsZyl7dmFyIGIsZD17fSxlPW51bGwsaD1udWxsO3ZvaWQgMCE9PWcmJihlPVwiXCIrZyk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYoaD1hLnJlZik7Zm9yKGIgaW4gYSltLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm4geyQkdHlwZW9mOmssdHlwZTpjLGtleTplLHJlZjpoLHByb3BzOmQsX293bmVyOm4uY3VycmVudH19cmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluLkZyYWdtZW50PWw7cmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluLmpzeD1xO3JlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbi5qc3hzPXE7XG5cdHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG59XG5cbnZhciByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQpIHJldHVybiByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQ7XG5cdGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50ID0gMTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBSZWFjdCA9IHJlcXVpcmUkJDA7XG5cblx0Ly8gQVRURU5USU9OXG5cdC8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcblx0Ly8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuXHQvLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cblx0dmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcblx0dmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG5cdHZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcblx0dmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuXHR2YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG5cdHZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcblx0dmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcblx0dmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuXHR2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG5cdHZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG5cdHZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG5cdHZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG5cdHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuXHR2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuXHR2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cdGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuXHQgIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG5cdCAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5cdGZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuXHQgIHtcblx0ICAgIHtcblx0ICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcblx0ICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcblx0ICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cblx0ICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cblx0ICB7XG5cdCAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cdCAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuXHQgICAgaWYgKHN0YWNrICE9PSAnJykge1xuXHQgICAgICBmb3JtYXQgKz0gJyVzJztcblx0ICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuXHQgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG5cdCAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuXHQgICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cblx0ICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuXHQgICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG5cdCAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuXHQgIH1cblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0dmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblx0dmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xuXHR2YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxuXHR2YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuXHQvLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG5cdC8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG5cdHZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cblx0dmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cblx0e1xuXHQgIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG5cdCAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuXHQgICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG5cdCAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG5cdCAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcblx0ICAgIC8vIHdpdGguXG5cdCAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcblx0ICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cblx0ICBpZiAoZGlzcGxheU5hbWUpIHtcblx0ICAgIHJldHVybiBkaXNwbGF5TmFtZTtcblx0ICB9XG5cblx0ICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuXHQgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG5cdH0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuXHRmdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG5cdCAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xuXHR9IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5cdGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG5cdCAgaWYgKHR5cGUgPT0gbnVsbCkge1xuXHQgICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuXHQgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHR5cGU7XG5cdCAgfVxuXG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG5cdCAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG5cdCAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cblx0ICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcblx0ICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cblx0ICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcblx0ICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG5cdCAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuXHQgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcblx0ICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG5cdCAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuXHQgICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG5cdCAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcblx0ICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG5cdCAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuXHQgICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcblx0ICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuXHQgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG5cdCAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG5cdCAgICAgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG5cdC8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcblx0Ly8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcblx0Ly8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuXHQvLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cblx0dmFyIGRpc2FibGVkRGVwdGggPSAwO1xuXHR2YXIgcHJldkxvZztcblx0dmFyIHByZXZJbmZvO1xuXHR2YXIgcHJldldhcm47XG5cdHZhciBwcmV2RXJyb3I7XG5cdHZhciBwcmV2R3JvdXA7XG5cdHZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG5cdHZhciBwcmV2R3JvdXBFbmQ7XG5cblx0ZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5cdGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5cdGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuXHQgIHtcblx0ICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG5cdCAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHQgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG5cdCAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuXHQgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2Fybjtcblx0ICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcblx0ICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcblx0ICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcblx0ICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG5cdCAgICAgIHZhciBwcm9wcyA9IHtcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG5cdCAgICAgICAgd3JpdGFibGU6IHRydWVcblx0ICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG5cdCAgICAgICAgaW5mbzogcHJvcHMsXG5cdCAgICAgICAgbG9nOiBwcm9wcyxcblx0ICAgICAgICB3YXJuOiBwcm9wcyxcblx0ICAgICAgICBlcnJvcjogcHJvcHMsXG5cdCAgICAgICAgZ3JvdXA6IHByb3BzLFxuXHQgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcblx0ICAgICAgICBncm91cEVuZDogcHJvcHNcblx0ICAgICAgfSk7XG5cdCAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG5cdCAgICB9XG5cblx0ICAgIGRpc2FibGVkRGVwdGgrKztcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuXHQgIHtcblx0ICAgIGRpc2FibGVkRGVwdGgtLTtcblxuXHQgICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcblx0ICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG5cdCAgICAgIHZhciBwcm9wcyA9IHtcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICB3cml0YWJsZTogdHJ1ZVxuXHQgICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcblx0ICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3Jcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcblx0ICAgICAgICB9KVxuXHQgICAgICB9KTtcblx0ICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cblx0ICAgIH1cblxuXHQgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG5cdCAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG5cdHZhciBwcmVmaXg7XG5cdGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuXHQgIHtcblx0ICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdGhyb3cgRXJyb3IoKTtcblx0ICAgICAgfSBjYXRjaCAoeCkge1xuXHQgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG5cdCAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuXHQgICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcblx0ICB9XG5cdH1cblx0dmFyIHJlZW50cnkgPSBmYWxzZTtcblx0dmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cblx0e1xuXHQgIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG5cdCAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuXHQgIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuXHQgIGlmICggIWZuIHx8IHJlZW50cnkpIHtcblx0ICAgIHJldHVybiAnJztcblx0ICB9XG5cblx0ICB7XG5cdCAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cblx0ICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHJldHVybiBmcmFtZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgY29udHJvbDtcblx0ICByZWVudHJ5ID0gdHJ1ZTtcblx0ICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuXHQgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuXHQgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cblx0ICB7XG5cdCAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuXHQgICAgLy8gZm9yIHdhcm5pbmdzLlxuXG5cdCAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuXHQgICAgZGlzYWJsZUxvZ3MoKTtcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG5cdCAgICBpZiAoY29uc3RydWN0KSB7XG5cdCAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuXHQgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHQgICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcblx0ICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cblx0ICAgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblxuXHQgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG5cdCAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuXHQgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcblx0ICAgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgICBjb250cm9sID0geDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBGYWtlLmNhbGwoKTtcblx0ICAgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgICBjb250cm9sID0geDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHQgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgY29udHJvbCA9IHg7XG5cdCAgICAgIH1cblxuXHQgICAgICBmbigpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKHNhbXBsZSkge1xuXHQgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cblx0ICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuXHQgICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuXHQgICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cblx0ICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcblx0ICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuXHQgICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG5cdCAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cblx0ICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuXHQgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuXHQgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcblx0ICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuXHQgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG5cdCAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cblx0ICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cblx0ICAgICAgICBjLS07XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcblx0ICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcblx0ICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cblx0ICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuXHQgICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cblx0ICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcblx0ICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG5cdCAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG5cdCAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuXHQgICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuXHQgICAgICAgICAgICBkbyB7XG5cdCAgICAgICAgICAgICAgcy0tO1xuXHQgICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuXHQgICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG5cdCAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcblx0ICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuXHQgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG5cdCAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG5cdCAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG5cdCAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBmaW5hbGx5IHtcblx0ICAgIHJlZW50cnkgPSBmYWxzZTtcblxuXHQgICAge1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cdCAgICAgIHJlZW5hYmxlTG9ncygpO1xuXHQgICAgfVxuXG5cdCAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG5cdCAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuXHQgIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG5cdCAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xuXHR9XG5cdGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG5cdCAge1xuXHQgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG5cdCAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cdCAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cblx0ICBpZiAodHlwZSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gJyc7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB7XG5cdCAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuXHQgIH1cblxuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuXHQgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cblx0ICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuXHQgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuXHQgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG5cdCAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG5cdCAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cblx0ICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuXHQgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG5cdCAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiAnJztcblx0fVxuXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0dmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXHR2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cblx0ZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuXHQgIHtcblx0ICAgIGlmIChlbGVtZW50KSB7XG5cdCAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXHQgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcblx0ICB7XG5cdCAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG5cdCAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuXHQgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuXHQgICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuXHQgICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuXHQgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cblx0ICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG5cdCAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG5cdCAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cdCAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuXHQgICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcblx0ICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcblx0ICAgICAgICB9IGNhdGNoIChleCkge1xuXHQgICAgICAgICAgZXJyb3IkMSA9IGV4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuXHQgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cblx0ICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG5cdCAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0ICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuXHQgICAgICAgICAgLy8gc2FtZSBlcnJvci5cblx0ICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcblx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG5cdCAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cblx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXHRmdW5jdGlvbiBpc0FycmF5KGEpIHtcblx0ICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG5cdH1cblxuXHQvKlxuXHQgKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcblx0ICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuXHQgKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG5cdCAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuXHQgKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuXHQgKi9cblx0Ly8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblx0ZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcblx0ICB7XG5cdCAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG5cdCAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcblx0ICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuXHQgICAgcmV0dXJuIHR5cGU7XG5cdCAgfVxuXHR9IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuXHRmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuXHQgIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG5cdCAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG5cdCAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcblx0ICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG5cdCAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG5cdCAgLy9cblx0ICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcblx0ICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuXHQgIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuXHQgIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuXHQgIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuXHQgIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG5cdCAgLy9cblx0ICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG5cdCAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuXHQgIC8vXG5cdCAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cblx0ICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcblx0ICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG5cdCAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cblx0ICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG5cdCAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuXHQgIC8vXG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cdCAgcmV0dXJuICcnICsgdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuXHQgIHtcblx0ICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcblx0ICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuXHQgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblx0dmFyIFJFU0VSVkVEX1BST1BTID0ge1xuXHQgIGtleTogdHJ1ZSxcblx0ICByZWY6IHRydWUsXG5cdCAgX19zZWxmOiB0cnVlLFxuXHQgIF9fc291cmNlOiB0cnVlXG5cdH07XG5cdHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcblx0dmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXHR2YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxuXHR7XG5cdCAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG5cdCAge1xuXHQgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcblx0ICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG5cdCAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuXHQgIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG5cdCAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuXHQgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuXHQgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcblx0ICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cblx0ICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuXHQgIHtcblx0ICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcblx0ICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cblx0ICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG5cdCAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuXHQgIHtcblx0ICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcblx0ICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cblx0ICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG5cdCAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cblx0ICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcblx0ICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG5cdCAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdHlwZVxuXHQgKiBAcGFyYW0geyp9IHByb3BzXG5cdCAqIEBwYXJhbSB7Kn0ga2V5XG5cdCAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG5cdCAqIEBwYXJhbSB7Kn0gb3duZXJcblx0ICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG5cdCAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2Vcblx0ICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcblx0ICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuXHQgKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuXHQgKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cblxuXHR2YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuXHQgIHZhciBlbGVtZW50ID0ge1xuXHQgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG5cdCAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXHQgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuXHQgICAgdHlwZTogdHlwZSxcblx0ICAgIGtleToga2V5LFxuXHQgICAgcmVmOiByZWYsXG5cdCAgICBwcm9wczogcHJvcHMsXG5cdCAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuXHQgICAgX293bmVyOiBvd25lclxuXHQgIH07XG5cblx0ICB7XG5cdCAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG5cdCAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuXHQgICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuXHQgICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG5cdCAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuXHQgICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuXHQgICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcblx0ICAgIC8vIGlnbm9yZXMgaXQuXG5cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcblx0ICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICB2YWx1ZTogZmFsc2Vcblx0ICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICAgIHZhbHVlOiBzZWxmXG5cdCAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcblx0ICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICAgIHZhbHVlOiBzb3VyY2Vcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuXHQgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuXHQgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBlbGVtZW50O1xuXHR9O1xuXHQvKipcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuXHQgKiBAcGFyYW0geyp9IHR5cGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcblx0ICovXG5cblx0ZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuXHQgIHtcblx0ICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cdCAgICB2YXIgcHJvcHMgPSB7fTtcblx0ICAgIHZhciBrZXkgPSBudWxsO1xuXHQgICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuXHQgICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG5cdCAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuXHQgICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG5cdCAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuXHQgICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuXHQgICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAge1xuXHQgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuXHQgICAgICB9XG5cblx0ICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcblx0ICAgICAge1xuXHQgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG5cdCAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cdCAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuXHQgICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuXHQgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcblx0ICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuXHQgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuXHQgICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0ICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG5cdCAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG5cdCAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoa2V5IHx8IHJlZikge1xuXHQgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cblx0ICAgICAgaWYgKGtleSkge1xuXHQgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocmVmKSB7XG5cdCAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXHR2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuXHRmdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcblx0ICB7XG5cdCAgICBpZiAoZWxlbWVudCkge1xuXHQgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblx0ICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcblx0ICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxuXHR7XG5cdCAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblx0fVxuXHQvKipcblx0ICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cblx0ICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuXHQgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuXHQgKiBAZmluYWxcblx0ICovXG5cblxuXHRmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcblx0ICB7XG5cdCAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcblx0ICB7XG5cdCAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG5cdCAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuXHQgICAgICBpZiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gJyc7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG5cdCAge1xuXHQgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG5cdCAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG5cdCAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAnJztcblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3Jcblx0ICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG5cdCAqIHVwZGF0ZXMuXG5cdCAqL1xuXG5cblx0dmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuXHQgIHtcblx0ICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cblx0ICAgIGlmICghaW5mbykge1xuXHQgICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuXHQgICAgICBpZiAocGFyZW50TmFtZSkge1xuXHQgICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaW5mbztcblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cblx0ICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG5cdCAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuXHQgKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcblx0ICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG5cdCAqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG5cdCAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cblx0ICovXG5cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcblx0ICB7XG5cdCAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblx0ICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuXHQgICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG5cdCAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG5cdCAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cblx0ICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cblx0ICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcblx0ICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG5cdCAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuXHQgICAgfVxuXG5cdCAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG5cdCAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuXHQgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cblx0ICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG5cdCAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuXHQgKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG5cdCAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cblx0ICovXG5cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cblx0ICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG5cdCAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcblx0ICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cblx0ICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG5cdCAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChub2RlKSB7XG5cdCAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuXHQgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG5cdCAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG5cdCAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuXHQgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuXHQgICAgICAgICAgdmFyIHN0ZXA7XG5cblx0ICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcblx0ICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHQvKipcblx0ICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcblx0ICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuXHQgIHtcblx0ICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG5cdCAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByb3BUeXBlcztcblxuXHQgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuXHQgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG5cdCAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG5cdCAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocHJvcFR5cGVzKSB7XG5cdCAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cdCAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXHQgICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG5cdCAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuXHQgICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cblx0ICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG5cdCAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcblx0ICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG5cdCAge1xuXHQgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuXHQgICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcblx0ICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuXHQgICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuXHQgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuXHQgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuXHQgICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuXHQgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuXHQgIHtcblx0ICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG5cdCAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG5cdCAgICBpZiAoIXZhbGlkVHlwZSkge1xuXHQgICAgICB2YXIgaW5mbyA9ICcnO1xuXG5cdCAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuXHQgICAgICBpZiAoc291cmNlSW5mbykge1xuXHQgICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cblx0ICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcblx0ICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuXHQgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcblx0ICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5Jztcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG5cdCAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuXHQgICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/Jztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuXHQgICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG5cdCAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBlbGVtZW50O1xuXHQgICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuXHQgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuXHQgICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuXHQgICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcblx0ICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG5cdCAgICBpZiAodmFsaWRUeXBlKSB7XG5cdCAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG5cdCAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcblx0ICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcblx0ICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcblx0ICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBlbGVtZW50O1xuXHQgIH1cblx0fSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblx0Ly8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcblx0Ly8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuXHQvLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5cdGZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcblx0ICB7XG5cdCAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG5cdCAge1xuXHQgICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHR2YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuXHQvLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG5cdHZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuXHRyZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuXHRyZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuanN4ID0ganN4O1xuXHRyZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuanN4cyA9IGpzeHM7XG5cdCAgfSkoKTtcblx0fVxuXHRyZXR1cm4gcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBqc3hSdW50aW1lLmV4cG9ydHMgPSByZXF1aXJlUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICBqc3hSdW50aW1lLmV4cG9ydHMgPSByZXF1aXJlUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50KCk7XG59XG5cbnZhciBqc3hSdW50aW1lRXhwb3J0cyA9IGpzeFJ1bnRpbWUuZXhwb3J0cztcblxuLyoqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwcm9wcyBhcmUgb2YgdHlwZSB7QGxpbmsgRGF5UGlja2VyTXVsdGlwbGVQcm9wc30uICovXG5mdW5jdGlvbiBpc0RheVBpY2tlck11bHRpcGxlKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLm1vZGUgPT09ICdtdWx0aXBsZSc7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcHJvcHMgYXJlIG9mIHR5cGUge0BsaW5rIERheVBpY2tlclJhbmdlUHJvcHN9LiAqL1xuZnVuY3Rpb24gaXNEYXlQaWNrZXJSYW5nZShwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5tb2RlID09PSAncmFuZ2UnO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHByb3BzIGFyZSBvZiB0eXBlIHtAbGluayBEYXlQaWNrZXJTaW5nbGVQcm9wc30uICovXG5mdW5jdGlvbiBpc0RheVBpY2tlclNpbmdsZShwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5tb2RlID09PSAnc2luZ2xlJztcbn1cblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBDU1MgY2xhc3Nlcy5cbiAqL1xudmFyIGRlZmF1bHRDbGFzc05hbWVzID0ge1xuICAgIHJvb3Q6ICdyZHAnLFxuICAgIG11bHRpcGxlX21vbnRoczogJ3JkcC1tdWx0aXBsZV9tb250aHMnLFxuICAgIHdpdGhfd2Vla251bWJlcjogJ3JkcC13aXRoX3dlZWtudW1iZXInLFxuICAgIHZoaWRkZW46ICdyZHAtdmhpZGRlbicsXG4gICAgYnV0dG9uX3Jlc2V0OiAncmRwLWJ1dHRvbl9yZXNldCcsXG4gICAgYnV0dG9uOiAncmRwLWJ1dHRvbicsXG4gICAgY2FwdGlvbjogJ3JkcC1jYXB0aW9uJyxcbiAgICBjYXB0aW9uX3N0YXJ0OiAncmRwLWNhcHRpb25fc3RhcnQnLFxuICAgIGNhcHRpb25fZW5kOiAncmRwLWNhcHRpb25fZW5kJyxcbiAgICBjYXB0aW9uX2JldHdlZW46ICdyZHAtY2FwdGlvbl9iZXR3ZWVuJyxcbiAgICBjYXB0aW9uX2xhYmVsOiAncmRwLWNhcHRpb25fbGFiZWwnLFxuICAgIGNhcHRpb25fZHJvcGRvd25zOiAncmRwLWNhcHRpb25fZHJvcGRvd25zJyxcbiAgICBkcm9wZG93bjogJ3JkcC1kcm9wZG93bicsXG4gICAgZHJvcGRvd25fbW9udGg6ICdyZHAtZHJvcGRvd25fbW9udGgnLFxuICAgIGRyb3Bkb3duX3llYXI6ICdyZHAtZHJvcGRvd25feWVhcicsXG4gICAgZHJvcGRvd25faWNvbjogJ3JkcC1kcm9wZG93bl9pY29uJyxcbiAgICBtb250aHM6ICdyZHAtbW9udGhzJyxcbiAgICBtb250aDogJ3JkcC1tb250aCcsXG4gICAgdGFibGU6ICdyZHAtdGFibGUnLFxuICAgIHRib2R5OiAncmRwLXRib2R5JyxcbiAgICB0Zm9vdDogJ3JkcC10Zm9vdCcsXG4gICAgaGVhZDogJ3JkcC1oZWFkJyxcbiAgICBoZWFkX3JvdzogJ3JkcC1oZWFkX3JvdycsXG4gICAgaGVhZF9jZWxsOiAncmRwLWhlYWRfY2VsbCcsXG4gICAgbmF2OiAncmRwLW5hdicsXG4gICAgbmF2X2J1dHRvbjogJ3JkcC1uYXZfYnV0dG9uJyxcbiAgICBuYXZfYnV0dG9uX3ByZXZpb3VzOiAncmRwLW5hdl9idXR0b25fcHJldmlvdXMnLFxuICAgIG5hdl9idXR0b25fbmV4dDogJ3JkcC1uYXZfYnV0dG9uX25leHQnLFxuICAgIG5hdl9pY29uOiAncmRwLW5hdl9pY29uJyxcbiAgICByb3c6ICdyZHAtcm93JyxcbiAgICB3ZWVrbnVtYmVyOiAncmRwLXdlZWtudW1iZXInLFxuICAgIGNlbGw6ICdyZHAtY2VsbCcsXG4gICAgZGF5OiAncmRwLWRheScsXG4gICAgZGF5X3RvZGF5OiAncmRwLWRheV90b2RheScsXG4gICAgZGF5X291dHNpZGU6ICdyZHAtZGF5X291dHNpZGUnLFxuICAgIGRheV9zZWxlY3RlZDogJ3JkcC1kYXlfc2VsZWN0ZWQnLFxuICAgIGRheV9kaXNhYmxlZDogJ3JkcC1kYXlfZGlzYWJsZWQnLFxuICAgIGRheV9oaWRkZW46ICdyZHAtZGF5X2hpZGRlbicsXG4gICAgZGF5X3JhbmdlX3N0YXJ0OiAncmRwLWRheV9yYW5nZV9zdGFydCcsXG4gICAgZGF5X3JhbmdlX2VuZDogJ3JkcC1kYXlfcmFuZ2VfZW5kJyxcbiAgICBkYXlfcmFuZ2VfbWlkZGxlOiAncmRwLWRheV9yYW5nZV9taWRkbGUnXG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZvcm1hdHRlciBmb3IgdGhlIGNhcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdENhcHRpb24obW9udGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0KG1vbnRoLCAnTExMTCB5Jywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgRGF5IGJ1dHRvbi5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF5KGRheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXQoZGF5LCAnZCcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZvcm1hdHRlciBmb3IgdGhlIE1vbnRoIGNhcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoQ2FwdGlvbihtb250aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXQobW9udGgsICdMTExMJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgd2VlayBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIod2Vla051bWJlcikge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh3ZWVrTnVtYmVyKTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXIgZm9yIHRoZSBuYW1lIG9mIHRoZSB3ZWVrZGF5LlxuICovXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TmFtZSh3ZWVrZGF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWVrZGF5LCAnY2NjY2NjJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgWWVhciBjYXB0aW9uLlxuICovXG5mdW5jdGlvbiBmb3JtYXRZZWFyQ2FwdGlvbih5ZWFyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh5ZWFyLCAneXl5eScsIG9wdGlvbnMpO1xufVxuXG52YXIgZm9ybWF0dGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZm9ybWF0Q2FwdGlvbjogZm9ybWF0Q2FwdGlvbixcbiAgICBmb3JtYXREYXk6IGZvcm1hdERheSxcbiAgICBmb3JtYXRNb250aENhcHRpb246IGZvcm1hdE1vbnRoQ2FwdGlvbixcbiAgICBmb3JtYXRXZWVrTnVtYmVyOiBmb3JtYXRXZWVrTnVtYmVyLFxuICAgIGZvcm1hdFdlZWtkYXlOYW1lOiBmb3JtYXRXZWVrZGF5TmFtZSxcbiAgICBmb3JtYXRZZWFyQ2FwdGlvbjogZm9ybWF0WWVhckNhcHRpb25cbn0pO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IEFSSUEgbGFiZWwgZm9yIHRoZSBkYXkgYnV0dG9uLlxuICovXG52YXIgbGFiZWxEYXkgPSBmdW5jdGlvbiAoZGF5LCBhY3RpdmVNb2RpZmllcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRheSwgJ2RvIE1NTU0gKEVFRUUpJywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IEFSSUEgbGFiZWwgZm9yIHRoZSBXZWVrTnVtYmVyIGVsZW1lbnQuXG4gKi9cbnZhciBsYWJlbE1vbnRoRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdNb250aDogJztcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgQVJJQSBsYWJlbCBmb3IgbmV4dCBtb250aCBidXR0b24gaW4gbmF2aWdhdGlvblxuICovXG52YXIgbGFiZWxOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnR28gdG8gbmV4dCBtb250aCc7XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IEFSSUEgbGFiZWwgZm9yIHByZXZpb3VzIG1vbnRoIGJ1dHRvbiBpbiBuYXZpZ2F0aW9uXG4gKi9cbnZhciBsYWJlbFByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnR28gdG8gcHJldmlvdXMgbW9udGgnO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBBUklBIGxhYmVsIGZvciB0aGUgV2Vla2RheSBlbGVtZW50LlxuICovXG52YXIgbGFiZWxXZWVrZGF5ID0gZnVuY3Rpb24gKGRheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXQoZGF5LCAnY2NjYycsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBBUklBIGxhYmVsIGZvciB0aGUgV2Vla051bWJlciBlbGVtZW50LlxuICovXG52YXIgbGFiZWxXZWVrTnVtYmVyID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCJXZWVrIG4uIFwiLmNvbmNhdChuKTtcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgQVJJQSBsYWJlbCBmb3IgdGhlIFdlZWtOdW1iZXIgZWxlbWVudC5cbiAqL1xudmFyIGxhYmVsWWVhckRyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnWWVhcjogJztcbn07XG5cbnZhciBsYWJlbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGxhYmVsRGF5OiBsYWJlbERheSxcbiAgICBsYWJlbE1vbnRoRHJvcGRvd246IGxhYmVsTW9udGhEcm9wZG93bixcbiAgICBsYWJlbE5leHQ6IGxhYmVsTmV4dCxcbiAgICBsYWJlbFByZXZpb3VzOiBsYWJlbFByZXZpb3VzLFxuICAgIGxhYmVsV2Vla051bWJlcjogbGFiZWxXZWVrTnVtYmVyLFxuICAgIGxhYmVsV2Vla2RheTogbGFiZWxXZWVrZGF5LFxuICAgIGxhYmVsWWVhckRyb3Bkb3duOiBsYWJlbFllYXJEcm9wZG93blxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgdG8gdXNlIGluIHRoZSBEYXlQaWNrZXJDb250ZXh0LCBpbiBjYXNlIHRoZXkgYXJlXG4gKiBub3QgcGFzc2VkIGRvd24gd2l0aCB0aGUgRGF5UGlja2VyIGluaXRpYWwgcHJvcHMuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRDb250ZXh0VmFsdWVzKCkge1xuICAgIHZhciBjYXB0aW9uTGF5b3V0ID0gJ2J1dHRvbnMnO1xuICAgIHZhciBjbGFzc05hbWVzID0gZGVmYXVsdENsYXNzTmFtZXM7XG4gICAgdmFyIGxvY2FsZSA9IGVuVVM7XG4gICAgdmFyIG1vZGlmaWVyc0NsYXNzTmFtZXMgPSB7fTtcbiAgICB2YXIgbW9kaWZpZXJzID0ge307XG4gICAgdmFyIG51bWJlck9mTW9udGhzID0gMTtcbiAgICB2YXIgc3R5bGVzID0ge307XG4gICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYXB0aW9uTGF5b3V0OiBjYXB0aW9uTGF5b3V0LFxuICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICBmb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzLFxuICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIG1vZGlmaWVyc0NsYXNzTmFtZXM6IG1vZGlmaWVyc0NsYXNzTmFtZXMsXG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgICBudW1iZXJPZk1vbnRoczogbnVtYmVyT2ZNb250aHMsXG4gICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICB0b2RheTogdG9kYXksXG4gICAgICAgIG1vZGU6ICdkZWZhdWx0J1xuICAgIH07XG59XG5cbi8qKiBSZXR1cm4gdGhlIGBmcm9tRGF0ZWAgYW5kIGB0b0RhdGVgIHByb3AgdmFsdWVzIHZhbHVlcyBwYXJzaW5nIHRoZSBEYXlQaWNrZXIgcHJvcHMuICovXG5mdW5jdGlvbiBwYXJzZUZyb21Ub1Byb3BzKHByb3BzKSB7XG4gICAgdmFyIGZyb21ZZWFyID0gcHJvcHMuZnJvbVllYXIsIHRvWWVhciA9IHByb3BzLnRvWWVhciwgZnJvbU1vbnRoID0gcHJvcHMuZnJvbU1vbnRoLCB0b01vbnRoID0gcHJvcHMudG9Nb250aDtcbiAgICB2YXIgZnJvbURhdGUgPSBwcm9wcy5mcm9tRGF0ZSwgdG9EYXRlID0gcHJvcHMudG9EYXRlO1xuICAgIGlmIChmcm9tTW9udGgpIHtcbiAgICAgICAgZnJvbURhdGUgPSBzdGFydE9mTW9udGgoZnJvbU1vbnRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJvbVllYXIpIHtcbiAgICAgICAgZnJvbURhdGUgPSBuZXcgRGF0ZShmcm9tWWVhciwgMCwgMSk7XG4gICAgfVxuICAgIGlmICh0b01vbnRoKSB7XG4gICAgICAgIHRvRGF0ZSA9IGVuZE9mTW9udGgodG9Nb250aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvWWVhcikge1xuICAgICAgICB0b0RhdGUgPSBuZXcgRGF0ZSh0b1llYXIsIDExLCAzMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21EYXRlOiBmcm9tRGF0ZSA/IHN0YXJ0T2ZEYXkoZnJvbURhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgICB0b0RhdGU6IHRvRGF0ZSA/IHN0YXJ0T2ZEYXkodG9EYXRlKSA6IHVuZGVmaW5lZFxuICAgIH07XG59XG5cbi8qKlxuICogVGhlIERheVBpY2tlciBjb250ZXh0IHNoYXJlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIERheVBpY2tlciB3aXRoaW4gaW50ZXJuYWxcbiAqIGFuZCBjdXN0b20gY29tcG9uZW50cy4gSXQgaXMgdXNlZCB0byBzZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGFuZCBwZXJmb3JtXG4gKiBvbmUtdGltZSBjYWxjdWxhdGlvbnMgcmVxdWlyZWQgdG8gcmVuZGVyIHRoZSBkYXlzLlxuICpcbiAqIEFjY2VzcyB0byB0aGlzIGNvbnRleHQgZnJvbSB0aGUge0BsaW5rIHVzZURheVBpY2tlcn0gaG9vay5cbiAqL1xudmFyIERheVBpY2tlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIFRoZSBwcm92aWRlciBmb3IgdGhlIHtAbGluayBEYXlQaWNrZXJDb250ZXh0fSwgYXNzaWduaW5nIHRoZSBkZWZhdWx0cyBmcm9tIHRoZVxuICogaW5pdGlhbCBEYXlQaWNrZXIgcHJvcHMuXG4gKi9cbmZ1bmN0aW9uIERheVBpY2tlclByb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBwcm9wcy5pbml0aWFsUHJvcHM7XG4gICAgdmFyIGRlZmF1bHRDb250ZXh0VmFsdWVzID0gZ2V0RGVmYXVsdENvbnRleHRWYWx1ZXMoKTtcbiAgICB2YXIgX2IgPSBwYXJzZUZyb21Ub1Byb3BzKGluaXRpYWxQcm9wcyksIGZyb21EYXRlID0gX2IuZnJvbURhdGUsIHRvRGF0ZSA9IF9iLnRvRGF0ZTtcbiAgICB2YXIgY2FwdGlvbkxheW91dCA9IChfYSA9IGluaXRpYWxQcm9wcy5jYXB0aW9uTGF5b3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0Q29udGV4dFZhbHVlcy5jYXB0aW9uTGF5b3V0O1xuICAgIGlmIChjYXB0aW9uTGF5b3V0ICE9PSAnYnV0dG9ucycgJiYgKCFmcm9tRGF0ZSB8fCAhdG9EYXRlKSkge1xuICAgICAgICAvLyBXaGVuIG5vIGZyb20vdG8gZGF0ZXMgYXJlIHNldCwgdGhlIGNhcHRpb24gaXMgYWx3YXlzIGJ1dHRvbnNcbiAgICAgICAgY2FwdGlvbkxheW91dCA9ICdidXR0b25zJztcbiAgICB9XG4gICAgdmFyIG9uU2VsZWN0O1xuICAgIGlmIChpc0RheVBpY2tlclNpbmdsZShpbml0aWFsUHJvcHMpIHx8XG4gICAgICAgIGlzRGF5UGlja2VyTXVsdGlwbGUoaW5pdGlhbFByb3BzKSB8fFxuICAgICAgICBpc0RheVBpY2tlclJhbmdlKGluaXRpYWxQcm9wcykpIHtcbiAgICAgICAgb25TZWxlY3QgPSBpbml0aWFsUHJvcHMub25TZWxlY3Q7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Q29udGV4dFZhbHVlcyksIGluaXRpYWxQcm9wcyksIHsgY2FwdGlvbkxheW91dDogY2FwdGlvbkxheW91dCwgY2xhc3NOYW1lczogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzLmNsYXNzTmFtZXMpLCBpbml0aWFsUHJvcHMuY2xhc3NOYW1lcyksIGNvbXBvbmVudHM6IF9fYXNzaWduKHt9LCBpbml0aWFsUHJvcHMuY29tcG9uZW50cyksIGZvcm1hdHRlcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Q29udGV4dFZhbHVlcy5mb3JtYXR0ZXJzKSwgaW5pdGlhbFByb3BzLmZvcm1hdHRlcnMpLCBmcm9tRGF0ZTogZnJvbURhdGUsIGxhYmVsczogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzLmxhYmVscyksIGluaXRpYWxQcm9wcy5sYWJlbHMpLCBtb2RlOiBpbml0aWFsUHJvcHMubW9kZSB8fCBkZWZhdWx0Q29udGV4dFZhbHVlcy5tb2RlLCBtb2RpZmllcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Q29udGV4dFZhbHVlcy5tb2RpZmllcnMpLCBpbml0aWFsUHJvcHMubW9kaWZpZXJzKSwgbW9kaWZpZXJzQ2xhc3NOYW1lczogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzLm1vZGlmaWVyc0NsYXNzTmFtZXMpLCBpbml0aWFsUHJvcHMubW9kaWZpZXJzQ2xhc3NOYW1lcyksIG9uU2VsZWN0OiBvblNlbGVjdCwgc3R5bGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdENvbnRleHRWYWx1ZXMuc3R5bGVzKSwgaW5pdGlhbFByb3BzLnN0eWxlcyksIHRvRGF0ZTogdG9EYXRlIH0pO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KERheVBpY2tlckNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG59XG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIHRoZSB7QGxpbmsgRGF5UGlja2VyQ29udGV4dFZhbHVlfS5cbiAqXG4gKiBVc2UgdGhlIERheVBpY2tlciBjb250ZXh0IHRvIGFjY2VzcyB0byB0aGUgcHJvcHMgcGFzc2VkIHRvIERheVBpY2tlciBpbnNpZGVcbiAqIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiB1c2VEYXlQaWNrZXIoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KERheVBpY2tlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VEYXlQaWNrZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIERheVBpY2tlclByb3ZpZGVyLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKiBSZW5kZXIgdGhlIGNhcHRpb24gZm9yIHRoZSBkaXNwbGF5ZWQgbW9udGguIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgd2hlbiBgY2FwdGlvbkxheW91dD1cImJ1dHRvbnNcImAuICovXG5mdW5jdGlvbiBDYXB0aW9uTGFiZWwocHJvcHMpIHtcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgbG9jYWxlID0gX2EubG9jYWxlLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Euc3R5bGVzLCBmb3JtYXRDYXB0aW9uID0gX2EuZm9ybWF0dGVycy5mb3JtYXRDYXB0aW9uO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNhcHRpb25fbGFiZWwsIHN0eWxlOiBzdHlsZXMuY2FwdGlvbl9sYWJlbCwgXCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIiwgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgaWQ6IHByb3BzLmlkIH0sIHsgY2hpbGRyZW46IGZvcm1hdENhcHRpb24ocHJvcHMuZGlzcGxheU1vbnRoLCB7IGxvY2FsZTogbG9jYWxlIH0pIH0pKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBpY29uIGluIHRoZSBzdHlsZWQgZHJvcC1kb3duLlxuICovXG5mdW5jdGlvbiBJY29uRHJvcGRvd24ocHJvcHMpIHtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCBfX2Fzc2lnbih7IHdpZHRoOiBcIjhweFwiLCBoZWlnaHQ6IFwiOHB4XCIsIHZpZXdCb3g6IFwiMCAwIDEyMCAxMjBcIiwgXCJkYXRhLXRlc3RpZFwiOiBcImljb25Ecm9wZG93blwiIH0sIHByb3BzLCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNNC4yMjE4MjU0MSw0OC4yMjE4MjU0IEM4LjQ0MjIyODI4LDQ0LjAwMTQyMjUgMTUuMjM4ODQ5NCw0My45MjczODA0IDE5LjU0OTY0NTksNDcuOTk5Njk4OSBMMTkuNzc4MTc0Niw0OC4yMjE4MjU0IEw2MCw4OC40NDMgTDEwMC4yMjE4MjUsNDguMjIxODI1NCBDMTA0LjQ0MjIyOCw0NC4wMDE0MjI1IDExMS4yMzg4NDksNDMuOTI3MzgwNCAxMTUuNTQ5NjQ2LDQ3Ljk5OTY5ODkgTDExNS43NzgxNzUsNDguMjIxODI1NCBDMTE5Ljk5ODU3Nyw1Mi40NDIyMjgzIDEyMC4wNzI2Miw1OS4yMzg4NDk0IDExNi4wMDAzMDEsNjMuNTQ5NjQ1OSBMMTE1Ljc3ODE3NSw2My43NzgxNzQ2IEw2Ny43NzgxNzQ2LDExMS43NzgxNzUgQzYzLjU1Nzc3MTcsMTE1Ljk5ODU3NyA1Ni43NjExNTA2LDExNi4wNzI2MiA1Mi40NTAzNTQxLDExMi4wMDAzMDEgTDUyLjIyMTgyNTQsMTExLjc3ODE3NSBMNC4yMjE4MjU0MSw2My43NzgxNzQ2IEMtMC4wNzM5NDE4MDIzLDU5LjQ4MjQwNzQgLTAuMDczOTQxODAyMyw1Mi41MTc1OTI2IDQuMjIxODI1NDEsNDguMjIxODI1NCBaXCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIGZpbGxSdWxlOiBcIm5vbnplcm9cIiB9KSB9KSkpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHN0eWxlZCBzZWxlY3QgY29tcG9uZW50IOKAkyBkaXNwbGF5aW5nIGEgY2FwdGlvbiBhbmQgYSBjdXN0b21cbiAqIGRyb3AtZG93biBpY29uLlxuICovXG5mdW5jdGlvbiBEcm9wZG93bihwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsIHZhbHVlID0gcHJvcHMudmFsdWUsIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sIGNhcHRpb24gPSBwcm9wcy5jYXB0aW9uLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBJY29uRHJvcGRvd25Db21wb25lbnQgPSAoX2IgPSAoX2EgPSBkYXlQaWNrZXIuY29tcG9uZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkljb25Ecm9wZG93bikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSWNvbkRyb3Bkb3duO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcImRpdlwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUgfSwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInNwYW5cIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGRheVBpY2tlci5jbGFzc05hbWVzLnZoaWRkZW4gfSwgeyBjaGlsZHJlbjogcHJvcHNbJ2FyaWEtbGFiZWwnXSB9KSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInNlbGVjdFwiLCBfX2Fzc2lnbih7IG5hbWU6IHByb3BzLm5hbWUsIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1snYXJpYS1sYWJlbCddLCBjbGFzc05hbWU6IGRheVBpY2tlci5jbGFzc05hbWVzLmRyb3Bkb3duLCBzdHlsZTogZGF5UGlja2VyLnN0eWxlcy5kcm9wZG93biwgdmFsdWU6IHZhbHVlLCBvbkNoYW5nZTogb25DaGFuZ2UgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpLCBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBkYXlQaWNrZXIuY2xhc3NOYW1lcy5jYXB0aW9uX2xhYmVsLCBzdHlsZTogZGF5UGlja2VyLnN0eWxlcy5jYXB0aW9uX2xhYmVsLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIHsgY2hpbGRyZW46IFtjYXB0aW9uLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goSWNvbkRyb3Bkb3duQ29tcG9uZW50LCB7IGNsYXNzTmFtZTogZGF5UGlja2VyLmNsYXNzTmFtZXMuZHJvcGRvd25faWNvbiwgc3R5bGU6IGRheVBpY2tlci5zdHlsZXMuZHJvcGRvd25faWNvbiB9KV0gfSkpXSB9KSkpO1xufVxuXG4vKiogUmVuZGVyIHRoZSBkcm9wZG93biB0byBuYXZpZ2F0ZSBiZXR3ZWVuIG1vbnRocy4gKi9cbmZ1bmN0aW9uIE1vbnRoc0Ryb3Bkb3duKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYiA9IHVzZURheVBpY2tlcigpLCBmcm9tRGF0ZSA9IF9iLmZyb21EYXRlLCB0b0RhdGUgPSBfYi50b0RhdGUsIHN0eWxlcyA9IF9iLnN0eWxlcywgbG9jYWxlID0gX2IubG9jYWxlLCBmb3JtYXRNb250aENhcHRpb24gPSBfYi5mb3JtYXR0ZXJzLmZvcm1hdE1vbnRoQ2FwdGlvbiwgY2xhc3NOYW1lcyA9IF9iLmNsYXNzTmFtZXMsIGNvbXBvbmVudHMgPSBfYi5jb21wb25lbnRzLCBsYWJlbE1vbnRoRHJvcGRvd24gPSBfYi5sYWJlbHMubGFiZWxNb250aERyb3Bkb3duO1xuICAgIC8vIERyb3Bkb3duIHNob3VsZCBhcHBlYXIgb25seSB3aGVuIGJvdGggZnJvbS90b0RhdGUgaXMgc2V0XG4gICAgaWYgKCFmcm9tRGF0ZSlcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwge30pO1xuICAgIGlmICghdG9EYXRlKVxuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7fSk7XG4gICAgdmFyIGRyb3Bkb3duTW9udGhzID0gW107XG4gICAgaWYgKGlzU2FtZVllYXIoZnJvbURhdGUsIHRvRGF0ZSkpIHtcbiAgICAgICAgLy8gb25seSBkaXNwbGF5IHRoZSBtb250aHMgaW5jbHVkZWQgaW4gdGhlIHJhbmdlXG4gICAgICAgIHZhciBkYXRlID0gc3RhcnRPZk1vbnRoKGZyb21EYXRlKTtcbiAgICAgICAgZm9yICh2YXIgbW9udGggPSBmcm9tRGF0ZS5nZXRNb250aCgpOyBtb250aCA8PSB0b0RhdGUuZ2V0TW9udGgoKTsgbW9udGgrKykge1xuICAgICAgICAgICAgZHJvcGRvd25Nb250aHMucHVzaChzZXRNb250aChkYXRlLCBtb250aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXNwbGF5IGFsbCB0aGUgMTIgbW9udGhzXG4gICAgICAgIHZhciBkYXRlID0gc3RhcnRPZk1vbnRoKG5ldyBEYXRlKCkpOyAvLyBBbnkgZGF0ZSBzaG91bGQgYmUgT0ssIGFzIHdlIGp1c3QgbmVlZCB0aGUgeWVhclxuICAgICAgICBmb3IgKHZhciBtb250aCA9IDA7IG1vbnRoIDw9IDExOyBtb250aCsrKSB7XG4gICAgICAgICAgICBkcm9wZG93bk1vbnRocy5wdXNoKHNldE1vbnRoKGRhdGUsIG1vbnRoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZE1vbnRoID0gTnVtYmVyKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgdmFyIG5ld01vbnRoID0gc2V0TW9udGgoc3RhcnRPZk1vbnRoKHByb3BzLmRpc3BsYXlNb250aCksIHNlbGVjdGVkTW9udGgpO1xuICAgICAgICBwcm9wcy5vbkNoYW5nZShuZXdNb250aCk7XG4gICAgfTtcbiAgICB2YXIgRHJvcGRvd25Db21wb25lbnQgPSAoX2EgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuRHJvcGRvd24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERyb3Bkb3duO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KERyb3Bkb3duQ29tcG9uZW50LCBfX2Fzc2lnbih7IG5hbWU6IFwibW9udGhzXCIsIFwiYXJpYS1sYWJlbFwiOiBsYWJlbE1vbnRoRHJvcGRvd24oKSwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmRyb3Bkb3duX21vbnRoLCBzdHlsZTogc3R5bGVzLmRyb3Bkb3duX21vbnRoLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLCB2YWx1ZTogcHJvcHMuZGlzcGxheU1vbnRoLmdldE1vbnRoKCksIGNhcHRpb246IGZvcm1hdE1vbnRoQ2FwdGlvbihwcm9wcy5kaXNwbGF5TW9udGgsIHsgbG9jYWxlOiBsb2NhbGUgfSkgfSwgeyBjaGlsZHJlbjogZHJvcGRvd25Nb250aHMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwib3B0aW9uXCIsIF9fYXNzaWduKHsgdmFsdWU6IG0uZ2V0TW9udGgoKSB9LCB7IGNoaWxkcmVuOiBmb3JtYXRNb250aENhcHRpb24obSwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9KSwgbS5nZXRNb250aCgpKSk7IH0pIH0pKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgZHJvcGRvd24gdG8gY2hhbmdlIHRoZSB5ZWFyLiBUYWtlIGluIGFjY291bnQgdGhlIGBuYXYuZnJvbURhdGVgIGFuZFxuICogYHRvRGF0ZWAgZnJvbSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBZZWFyc0Ryb3Bkb3duKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkaXNwbGF5TW9udGggPSBwcm9wcy5kaXNwbGF5TW9udGg7XG4gICAgdmFyIF9iID0gdXNlRGF5UGlja2VyKCksIGZyb21EYXRlID0gX2IuZnJvbURhdGUsIHRvRGF0ZSA9IF9iLnRvRGF0ZSwgbG9jYWxlID0gX2IubG9jYWxlLCBzdHlsZXMgPSBfYi5zdHlsZXMsIGNsYXNzTmFtZXMgPSBfYi5jbGFzc05hbWVzLCBjb21wb25lbnRzID0gX2IuY29tcG9uZW50cywgZm9ybWF0WWVhckNhcHRpb24gPSBfYi5mb3JtYXR0ZXJzLmZvcm1hdFllYXJDYXB0aW9uLCBsYWJlbFllYXJEcm9wZG93biA9IF9iLmxhYmVscy5sYWJlbFllYXJEcm9wZG93bjtcbiAgICB2YXIgeWVhcnMgPSBbXTtcbiAgICAvLyBEcm9wZG93biBzaG91bGQgYXBwZWFyIG9ubHkgd2hlbiBib3RoIGZyb20vdG9EYXRlIGlzIHNldFxuICAgIGlmICghZnJvbURhdGUpXG4gICAgICAgIHJldHVybiBqc3hSdW50aW1lRXhwb3J0cy5qc3goanN4UnVudGltZUV4cG9ydHMuRnJhZ21lbnQsIHt9KTtcbiAgICBpZiAoIXRvRGF0ZSlcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwge30pO1xuICAgIHZhciBmcm9tWWVhciA9IGZyb21EYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgdmFyIHRvWWVhciA9IHRvRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGZvciAodmFyIHllYXIgPSBmcm9tWWVhcjsgeWVhciA8PSB0b1llYXI7IHllYXIrKykge1xuICAgICAgICB5ZWFycy5wdXNoKHNldFllYXIoc3RhcnRPZlllYXIobmV3IERhdGUoKSksIHllYXIpKTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBuZXdNb250aCA9IHNldFllYXIoc3RhcnRPZk1vbnRoKGRpc3BsYXlNb250aCksIE51bWJlcihlLnRhcmdldC52YWx1ZSkpO1xuICAgICAgICBwcm9wcy5vbkNoYW5nZShuZXdNb250aCk7XG4gICAgfTtcbiAgICB2YXIgRHJvcGRvd25Db21wb25lbnQgPSAoX2EgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuRHJvcGRvd24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERyb3Bkb3duO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KERyb3Bkb3duQ29tcG9uZW50LCBfX2Fzc2lnbih7IG5hbWU6IFwieWVhcnNcIiwgXCJhcmlhLWxhYmVsXCI6IGxhYmVsWWVhckRyb3Bkb3duKCksIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5kcm9wZG93bl95ZWFyLCBzdHlsZTogc3R5bGVzLmRyb3Bkb3duX3llYXIsIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsIHZhbHVlOiBkaXNwbGF5TW9udGguZ2V0RnVsbFllYXIoKSwgY2FwdGlvbjogZm9ybWF0WWVhckNhcHRpb24oZGlzcGxheU1vbnRoLCB7IGxvY2FsZTogbG9jYWxlIH0pIH0sIHsgY2hpbGRyZW46IHllYXJzLm1hcChmdW5jdGlvbiAoeWVhcikgeyByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcIm9wdGlvblwiLCBfX2Fzc2lnbih7IHZhbHVlOiB5ZWFyLmdldEZ1bGxZZWFyKCkgfSwgeyBjaGlsZHJlbjogZm9ybWF0WWVhckNhcHRpb24oeWVhciwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9KSwgeWVhci5nZXRGdWxsWWVhcigpKSk7IH0pIH0pKSk7XG59XG5cbi8qKlxuICogSGVscGVyIGhvb2sgZm9yIHVzaW5nIGNvbnRyb2xsZWQvdW5jb250cm9sbGVkIHZhbHVlcyBmcm9tIGEgY29tcG9uZW50IHByb3BzLlxuICpcbiAqIFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBjb250cm9sbGVkLCBwYXNzIGB1bmRlZmluZWRgIGFzIGBjb250cm9sbGVkVmFsdWVgIGFuZFxuICogdXNlIHRoZSByZXR1cm5lZCBzZXR0ZXIgdG8gdXBkYXRlIGl0LlxuICpcbiAqIFdoZW4gdGhlIHZhbHVlIGlzIGNvbnRyb2xsZWQsIHBhc3MgdGhlIGNvbnRyb2xsZWQgdmFsdWUgYXMgc2Vjb25kXG4gKiBhcmd1bWVudCwgd2hpY2ggd2lsbCBiZSBhbHdheXMgcmV0dXJuZWQgYXMgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlZFZhbHVlKGRlZmF1bHRWYWx1ZSwgY29udHJvbGxlZFZhbHVlKSB7XG4gICAgdmFyIF9hID0gdXNlU3RhdGUoZGVmYXVsdFZhbHVlKSwgdW5jb250cm9sbGVkVmFsdWUgPSBfYVswXSwgc2V0VmFsdWUgPSBfYVsxXTtcbiAgICB2YXIgdmFsdWUgPSBjb250cm9sbGVkVmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuY29udHJvbGxlZFZhbHVlIDogY29udHJvbGxlZFZhbHVlO1xuICAgIHJldHVybiBbdmFsdWUsIHNldFZhbHVlXTtcbn1cblxuLyoqIFJldHVybiB0aGUgaW5pdGlhbCBtb250aCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMuICovXG5mdW5jdGlvbiBnZXRJbml0aWFsTW9udGgoY29udGV4dCkge1xuICAgIHZhciBtb250aCA9IGNvbnRleHQubW9udGgsIGRlZmF1bHRNb250aCA9IGNvbnRleHQuZGVmYXVsdE1vbnRoLCB0b2RheSA9IGNvbnRleHQudG9kYXk7XG4gICAgdmFyIGluaXRpYWxNb250aCA9IG1vbnRoIHx8IGRlZmF1bHRNb250aCB8fCB0b2RheSB8fCBuZXcgRGF0ZSgpO1xuICAgIHZhciB0b0RhdGUgPSBjb250ZXh0LnRvRGF0ZSwgZnJvbURhdGUgPSBjb250ZXh0LmZyb21EYXRlLCBfYSA9IGNvbnRleHQubnVtYmVyT2ZNb250aHMsIG51bWJlck9mTW9udGhzID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYTtcbiAgICAvLyBGaXggdGhlIGluaXRpYWxNb250aCBpZiBpcyBhZnRlciB0aGUgdG8tZGF0ZVxuICAgIGlmICh0b0RhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHModG9EYXRlLCBpbml0aWFsTW9udGgpIDwgMCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gLTEgKiAobnVtYmVyT2ZNb250aHMgLSAxKTtcbiAgICAgICAgaW5pdGlhbE1vbnRoID0gYWRkTW9udGhzKHRvRGF0ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gRml4IHRoZSBpbml0aWFsTW9udGggaWYgaXMgYmVmb3JlIHRoZSBmcm9tLWRhdGVcbiAgICBpZiAoZnJvbURhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMoaW5pdGlhbE1vbnRoLCBmcm9tRGF0ZSkgPCAwKSB7XG4gICAgICAgIGluaXRpYWxNb250aCA9IGZyb21EYXRlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRPZk1vbnRoKGluaXRpYWxNb250aCk7XG59XG5cbi8qKiBDb250cm9scyB0aGUgbmF2aWdhdGlvbiBzdGF0ZS4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25TdGF0ZSgpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBpbml0aWFsTW9udGggPSBnZXRJbml0aWFsTW9udGgoY29udGV4dCk7XG4gICAgdmFyIF9hID0gdXNlQ29udHJvbGxlZFZhbHVlKGluaXRpYWxNb250aCwgY29udGV4dC5tb250aCksIG1vbnRoID0gX2FbMF0sIHNldE1vbnRoID0gX2FbMV07XG4gICAgdmFyIGdvVG9Nb250aCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGNvbnRleHQuZGlzYWJsZU5hdmlnYXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtb250aCA9IHN0YXJ0T2ZNb250aChkYXRlKTtcbiAgICAgICAgc2V0TW9udGgobW9udGgpO1xuICAgICAgICAoX2EgPSBjb250ZXh0Lm9uTW9udGhDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQsIG1vbnRoKTtcbiAgICB9O1xuICAgIHJldHVybiBbbW9udGgsIGdvVG9Nb250aF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtb250aHMgdG8gZGlzcGxheSBpbiB0aGUgY29tcG9uZW50IGFjY29yZGluZyB0byB0aGUgbnVtYmVyIG9mXG4gKiBtb250aHMgYW5kIHRoZSBmcm9tL3RvIGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGdldERpc3BsYXlNb250aHMobW9udGgsIF9hKSB7XG4gICAgdmFyIHJldmVyc2VNb250aHMgPSBfYS5yZXZlcnNlTW9udGhzLCBudW1iZXJPZk1vbnRocyA9IF9hLm51bWJlck9mTW9udGhzO1xuICAgIHZhciBzdGFydCA9IHN0YXJ0T2ZNb250aChtb250aCk7XG4gICAgdmFyIGVuZCA9IHN0YXJ0T2ZNb250aChhZGRNb250aHMoc3RhcnQsIG51bWJlck9mTW9udGhzKSk7XG4gICAgdmFyIG1vbnRoc0RpZmYgPSBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhlbmQsIHN0YXJ0KTtcbiAgICB2YXIgbW9udGhzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb250aHNEaWZmOyBpKyspIHtcbiAgICAgICAgdmFyIG5leHRNb250aCA9IGFkZE1vbnRocyhzdGFydCwgaSk7XG4gICAgICAgIG1vbnRocy5wdXNoKG5leHRNb250aCk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlTW9udGhzKVxuICAgICAgICBtb250aHMgPSBtb250aHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBtb250aHM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBtb250aCB0aGUgdXNlciBjYW4gbmF2aWdhdGUgdG8gYWNjb3JkaW5nIHRvIHRoZSBnaXZlblxuICogb3B0aW9ucy5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBuZXh0IG1vbnRoIGlzIG5vdCBhbHdheXMgdGhlIG5leHQgY2FsZW5kYXIgbW9udGg6XG4gKlxuICogLSBpZiBhZnRlciB0aGUgYHRvRGF0ZWAgcmFuZ2UsIGlzIHVuZGVmaW5lZDtcbiAqIC0gaWYgdGhlIG5hdmlnYXRpb24gaXMgcGFnZWQsIGlzIHRoZSBudW1iZXIgb2YgbW9udGhzIGRpc3BsYXllZCBhaGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRNb250aChzdGFydGluZ01vbnRoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZU5hdmlnYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHRvRGF0ZSA9IG9wdGlvbnMudG9EYXRlLCBwYWdlZE5hdmlnYXRpb24gPSBvcHRpb25zLnBhZ2VkTmF2aWdhdGlvbiwgX2EgPSBvcHRpb25zLm51bWJlck9mTW9udGhzLCBudW1iZXJPZk1vbnRocyA9IF9hID09PSB2b2lkIDAgPyAxIDogX2E7XG4gICAgdmFyIG9mZnNldCA9IHBhZ2VkTmF2aWdhdGlvbiA/IG51bWJlck9mTW9udGhzIDogMTtcbiAgICB2YXIgbW9udGggPSBzdGFydE9mTW9udGgoc3RhcnRpbmdNb250aCk7XG4gICAgaWYgKCF0b0RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFkZE1vbnRocyhtb250aCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmFyIG1vbnRoc0RpZmYgPSBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyh0b0RhdGUsIHN0YXJ0aW5nTW9udGgpO1xuICAgIGlmIChtb250aHNEaWZmIDwgbnVtYmVyT2ZNb250aHMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSnVtcCBmb3J3YXJkIGFzIHRoZSBudW1iZXIgb2YgbW9udGhzIHdoZW4gcGFnZWQgbmF2aWdhdGlvblxuICAgIHJldHVybiBhZGRNb250aHMobW9udGgsIG9mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBwcmV2aW91cyB0aGUgdXNlciBjYW4gbmF2aWdhdGUgdG8sIGFjY29yZGluZyB0byB0aGUgZ2l2ZW5cbiAqIG9wdGlvbnMuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgcHJldmlvdXMgbW9udGggaXMgbm90IGFsd2F5cyB0aGUgcHJldmlvdXMgY2FsZW5kYXJcbiAqIG1vbnRoOlxuICpcbiAqIC0gaWYgYmVmb3JlIHRoZSBgZnJvbURhdGVgIGRhdGUsIGlzIGB1bmRlZmluZWRgO1xuICogLSBpZiB0aGUgbmF2aWdhdGlvbiBpcyBwYWdlZCwgaXMgdGhlIG51bWJlciBvZiBtb250aHMgZGlzcGxheWVkIGJlZm9yZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFByZXZpb3VzTW9udGgoc3RhcnRpbmdNb250aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRpc2FibGVOYXZpZ2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBmcm9tRGF0ZSA9IG9wdGlvbnMuZnJvbURhdGUsIHBhZ2VkTmF2aWdhdGlvbiA9IG9wdGlvbnMucGFnZWROYXZpZ2F0aW9uLCBfYSA9IG9wdGlvbnMubnVtYmVyT2ZNb250aHMsIG51bWJlck9mTW9udGhzID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYTtcbiAgICB2YXIgb2Zmc2V0ID0gcGFnZWROYXZpZ2F0aW9uID8gbnVtYmVyT2ZNb250aHMgOiAxO1xuICAgIHZhciBtb250aCA9IHN0YXJ0T2ZNb250aChzdGFydGluZ01vbnRoKTtcbiAgICBpZiAoIWZyb21EYXRlKSB7XG4gICAgICAgIHJldHVybiBhZGRNb250aHMobW9udGgsIC1vZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgbW9udGhzRGlmZiA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKG1vbnRoLCBmcm9tRGF0ZSk7XG4gICAgaWYgKG1vbnRoc0RpZmYgPD0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBKdW1wIGJhY2sgYXMgdGhlIG51bWJlciBvZiBtb250aHMgd2hlbiBwYWdlZCBuYXZpZ2F0aW9uXG4gICAgcmV0dXJuIGFkZE1vbnRocyhtb250aCwgLW9mZnNldCk7XG59XG5cbi8qKlxuICogVGhlIE5hdmlnYXRpb24gY29udGV4dCBzaGFyZXMgZGV0YWlscyBhbmQgbWV0aG9kcyB0byBuYXZpZ2F0ZSB0aGUgbW9udGhzIGluIERheVBpY2tlci5cbiAqIEFjY2VzcyB0aGlzIGNvbnRleHQgZnJvbSB0aGUge0BsaW5rIHVzZU5hdmlnYXRpb259IGhvb2suXG4gKi9cbnZhciBOYXZpZ2F0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKiBQcm92aWRlcyB0aGUgdmFsdWVzIGZvciB0aGUge0BsaW5rIE5hdmlnYXRpb25Db250ZXh0fS4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRpb25Qcm92aWRlcihwcm9wcykge1xuICAgIHZhciBkYXlQaWNrZXIgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgX2EgPSB1c2VOYXZpZ2F0aW9uU3RhdGUoKSwgY3VycmVudE1vbnRoID0gX2FbMF0sIGdvVG9Nb250aCA9IF9hWzFdO1xuICAgIHZhciBkaXNwbGF5TW9udGhzID0gZ2V0RGlzcGxheU1vbnRocyhjdXJyZW50TW9udGgsIGRheVBpY2tlcik7XG4gICAgdmFyIG5leHRNb250aCA9IGdldE5leHRNb250aChjdXJyZW50TW9udGgsIGRheVBpY2tlcik7XG4gICAgdmFyIHByZXZpb3VzTW9udGggPSBnZXRQcmV2aW91c01vbnRoKGN1cnJlbnRNb250aCwgZGF5UGlja2VyKTtcbiAgICB2YXIgaXNEYXRlRGlzcGxheWVkID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlNb250aHMuc29tZShmdW5jdGlvbiAoZGlzcGxheU1vbnRoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgoZGF0ZSwgZGlzcGxheU1vbnRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZ29Ub0RhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgcmVmRGF0ZSkge1xuICAgICAgICBpZiAoaXNEYXRlRGlzcGxheWVkKGRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkRhdGUgJiYgaXNCZWZvcmUoZGF0ZSwgcmVmRGF0ZSkpIHtcbiAgICAgICAgICAgIGdvVG9Nb250aChhZGRNb250aHMoZGF0ZSwgMSArIGRheVBpY2tlci5udW1iZXJPZk1vbnRocyAqIC0xKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnb1RvTW9udGgoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgY3VycmVudE1vbnRoOiBjdXJyZW50TW9udGgsXG4gICAgICAgIGRpc3BsYXlNb250aHM6IGRpc3BsYXlNb250aHMsXG4gICAgICAgIGdvVG9Nb250aDogZ29Ub01vbnRoLFxuICAgICAgICBnb1RvRGF0ZTogZ29Ub0RhdGUsXG4gICAgICAgIHByZXZpb3VzTW9udGg6IHByZXZpb3VzTW9udGgsXG4gICAgICAgIG5leHRNb250aDogbmV4dE1vbnRoLFxuICAgICAgICBpc0RhdGVEaXNwbGF5ZWQ6IGlzRGF0ZURpc3BsYXllZFxuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG59XG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIHRoZSB7QGxpbmsgTmF2aWdhdGlvbkNvbnRleHRWYWx1ZX0uIFVzZSB0aGlzIGhvb2sgdG8gbmF2aWdhdGVcbiAqIGJldHdlZW4gbW9udGhzIG9yIHllYXJzIGluIERheVBpY2tlci5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VOYXZpZ2F0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBOYXZpZ2F0aW9uUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgY2FwdGlvbiB3aXRoIHRoZSBkcm9wZG93bnMgdG8gbmF2aWdhdGUgYmV0d2VlbiBtb250aHMgYW5kIHllYXJzLlxuICovXG5mdW5jdGlvbiBDYXB0aW9uRHJvcGRvd25zKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYiA9IHVzZURheVBpY2tlcigpLCBjbGFzc05hbWVzID0gX2IuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Iuc3R5bGVzLCBjb21wb25lbnRzID0gX2IuY29tcG9uZW50cztcbiAgICB2YXIgZ29Ub01vbnRoID0gdXNlTmF2aWdhdGlvbigpLmdvVG9Nb250aDtcbiAgICB2YXIgaGFuZGxlTW9udGhDaGFuZ2UgPSBmdW5jdGlvbiAobmV3TW9udGgpIHtcbiAgICAgICAgZ29Ub01vbnRoKGFkZE1vbnRocyhuZXdNb250aCwgcHJvcHMuZGlzcGxheUluZGV4ID8gLXByb3BzLmRpc3BsYXlJbmRleCA6IDApKTtcbiAgICB9O1xuICAgIHZhciBDYXB0aW9uTGFiZWxDb21wb25lbnQgPSAoX2EgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuQ2FwdGlvbkxhYmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDYXB0aW9uTGFiZWw7XG4gICAgdmFyIGNhcHRpb25MYWJlbCA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3goQ2FwdGlvbkxhYmVsQ29tcG9uZW50LCB7IGlkOiBwcm9wcy5pZCwgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGggfSkpO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcImRpdlwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jYXB0aW9uX2Ryb3Bkb3ducywgc3R5bGU6IHN0eWxlcy5jYXB0aW9uX2Ryb3Bkb3ducyB9LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnZoaWRkZW4gfSwgeyBjaGlsZHJlbjogY2FwdGlvbkxhYmVsIH0pKSwganN4UnVudGltZUV4cG9ydHMuanN4KE1vbnRoc0Ryb3Bkb3duLCB7IG9uQ2hhbmdlOiBoYW5kbGVNb250aENoYW5nZSwgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGggfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChZZWFyc0Ryb3Bkb3duLCB7IG9uQ2hhbmdlOiBoYW5kbGVNb250aENoYW5nZSwgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGggfSldIH0pKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBcInByZXZpb3VzIG1vbnRoXCIgYnV0dG9uIGluIHRoZSBuYXZpZ2F0aW9uLlxuICovXG5mdW5jdGlvbiBJY29uTGVmdChwcm9wcykge1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIF9fYXNzaWduKHsgd2lkdGg6IFwiMTZweFwiLCBoZWlnaHQ6IFwiMTZweFwiLCB2aWV3Qm94OiBcIjAgMCAxMjAgMTIwXCIgfSwgcHJvcHMsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk02OS40OTAzMzIsMy4zNDMxNDU3NSBDNzIuNjE0NTI2MywwLjIxODk1MTQxNiA3Ny42Nzk4NDYyLDAuMjE4OTUxNDE2IDgwLjgwNDA0MDUsMy4zNDMxNDU3NSBDODMuODYxNzYyNiw2LjQwMDg2Nzg2IDgzLjkyNjgyMDUsMTEuMzE3OTkzMSA4MC45OTkyMTQzLDE0LjQ1NDgzODggTDgwLjgwNDA0MDUsMTQuNjU2ODU0MiBMMzUuNDYxLDYwIEw4MC44MDQwNDA1LDEwNS4zNDMxNDYgQzgzLjg2MTc2MjYsMTA4LjQwMDg2OCA4My45MjY4MjA1LDExMy4zMTc5OTMgODAuOTk5MjE0MywxMTYuNDU0ODM5IEw4MC44MDQwNDA1LDExNi42NTY4NTQgQzc3Ljc0NjMxODQsMTE5LjcxNDU3NiA3Mi44MjkxOTMxLDExOS43Nzk2MzQgNjkuNjkyMzQ3NSwxMTYuODUyMDI4IEw2OS40OTAzMzIsMTE2LjY1Njg1NCBMMTguNDkwMzMyLDY1LjY1Njg1NDIgQzE1LjQzMjYwOTksNjIuNTk5MTMyMSAxNS4zNjc1NTIsNTcuNjgyMDA2OSAxOC4yOTUxNTgzLDU0LjU0NTE2MTIgTDE4LjQ5MDMzMiw1NC4zNDMxNDU4IEw2OS40OTAzMzIsMy4zNDMxNDU3NSBaXCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIGZpbGxSdWxlOiBcIm5vbnplcm9cIiB9KSB9KSkpO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgXCJuZXh0IG1vbnRoXCIgYnV0dG9uIGluIHRoZSBuYXZpZ2F0aW9uLlxuICovXG5mdW5jdGlvbiBJY29uUmlnaHQocHJvcHMpIHtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCBfX2Fzc2lnbih7IHdpZHRoOiBcIjE2cHhcIiwgaGVpZ2h0OiBcIjE2cHhcIiwgdmlld0JveDogXCIwIDAgMTIwIDEyMFwiIH0sIHByb3BzLCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNNDkuODA0MDQwNSwzLjM0MzE0NTc1IEM0Ni42Nzk4NDYyLDAuMjE4OTUxNDE2IDQxLjYxNDUyNjMsMC4yMTg5NTE0MTYgMzguNDkwMzMyLDMuMzQzMTQ1NzUgQzM1LjQzMjYwOTksNi40MDA4Njc4NiAzNS4zNjc1NTIsMTEuMzE3OTkzMSAzOC4yOTUxNTgzLDE0LjQ1NDgzODggTDM4LjQ5MDMzMiwxNC42NTY4NTQyIEw4My44MzMzNzI1LDYwIEwzOC40OTAzMzIsMTA1LjM0MzE0NiBDMzUuNDMyNjA5OSwxMDguNDAwODY4IDM1LjM2NzU1MiwxMTMuMzE3OTkzIDM4LjI5NTE1ODMsMTE2LjQ1NDgzOSBMMzguNDkwMzMyLDExNi42NTY4NTQgQzQxLjU0ODA1NDEsMTE5LjcxNDU3NiA0Ni40NjUxNzk0LDExOS43Nzk2MzQgNDkuNjAyMDI1LDExNi44NTIwMjggTDQ5LjgwNDA0MDUsMTE2LjY1Njg1NCBMMTAwLjgwNDA0MSw2NS42NTY4NTQyIEMxMDMuODYxNzYzLDYyLjU5OTEzMjEgMTAzLjkyNjgyMSw1Ny42ODIwMDY5IDEwMC45OTkyMTQsNTQuNTQ1MTYxMiBMMTAwLjgwNDA0MSw1NC4zNDMxNDU4IEw0OS44MDQwNDA1LDMuMzQzMTQ1NzUgWlwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0pIH0pKSk7XG59XG5cbi8qKiBSZW5kZXIgYSBidXR0b24gSFRNTCBlbGVtZW50IGFwcGx5aW5nIHRoZSByZXNldCBjbGFzcyBuYW1lLiAqL1xudmFyIEJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgY2xhc3NOYW1lcyA9IF9hLmNsYXNzTmFtZXMsIHN0eWxlcyA9IF9hLnN0eWxlcztcbiAgICB2YXIgY2xhc3NOYW1lc0FyciA9IFtjbGFzc05hbWVzLmJ1dHRvbl9yZXNldCwgY2xhc3NOYW1lcy5idXR0b25dO1xuICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lc0Fyci5wdXNoKHByb3BzLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzQXJyLmpvaW4oJyAnKTtcbiAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGVzLmJ1dHRvbl9yZXNldCksIHN0eWxlcy5idXR0b24pO1xuICAgIGlmIChwcm9wcy5zdHlsZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCBwcm9wcy5zdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwiYnV0dG9uXCIsIF9fYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IHJlZiwgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHN0eWxlOiBzdHlsZSB9KSkpO1xufSk7XG5cbi8qKiBBIGNvbXBvbmVudCByZW5kZXJpbmcgdGhlIG5hdmlnYXRpb24gYnV0dG9ucyBvciB0aGUgZHJvcC1kb3ducy4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRpb24ocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBfYyA9IHVzZURheVBpY2tlcigpLCBkaXIgPSBfYy5kaXIsIGxvY2FsZSA9IF9jLmxvY2FsZSwgY2xhc3NOYW1lcyA9IF9jLmNsYXNzTmFtZXMsIHN0eWxlcyA9IF9jLnN0eWxlcywgX2QgPSBfYy5sYWJlbHMsIGxhYmVsUHJldmlvdXMgPSBfZC5sYWJlbFByZXZpb3VzLCBsYWJlbE5leHQgPSBfZC5sYWJlbE5leHQsIGNvbXBvbmVudHMgPSBfYy5jb21wb25lbnRzO1xuICAgIGlmICghcHJvcHMubmV4dE1vbnRoICYmICFwcm9wcy5wcmV2aW91c01vbnRoKSB7XG4gICAgICAgIHJldHVybiBqc3hSdW50aW1lRXhwb3J0cy5qc3goanN4UnVudGltZUV4cG9ydHMuRnJhZ21lbnQsIHt9KTtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzTGFiZWwgPSBsYWJlbFByZXZpb3VzKHByb3BzLnByZXZpb3VzTW9udGgsIHsgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgdmFyIHByZXZpb3VzQ2xhc3NOYW1lID0gW1xuICAgICAgICBjbGFzc05hbWVzLm5hdl9idXR0b24sXG4gICAgICAgIGNsYXNzTmFtZXMubmF2X2J1dHRvbl9wcmV2aW91c1xuICAgIF0uam9pbignICcpO1xuICAgIHZhciBuZXh0TGFiZWwgPSBsYWJlbE5leHQocHJvcHMubmV4dE1vbnRoLCB7IGxvY2FsZTogbG9jYWxlIH0pO1xuICAgIHZhciBuZXh0Q2xhc3NOYW1lID0gW1xuICAgICAgICBjbGFzc05hbWVzLm5hdl9idXR0b24sXG4gICAgICAgIGNsYXNzTmFtZXMubmF2X2J1dHRvbl9uZXh0XG4gICAgXS5qb2luKCcgJyk7XG4gICAgdmFyIEljb25SaWdodENvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5JY29uUmlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEljb25SaWdodDtcbiAgICB2YXIgSWNvbkxlZnRDb21wb25lbnQgPSAoX2IgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuSWNvbkxlZnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEljb25MZWZ0O1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcImRpdlwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5uYXYsIHN0eWxlOiBzdHlsZXMubmF2IH0sIHsgY2hpbGRyZW46IFshcHJvcHMuaGlkZVByZXZpb3VzICYmIChqc3hSdW50aW1lRXhwb3J0cy5qc3goQnV0dG9uLCBfX2Fzc2lnbih7IG5hbWU6IFwicHJldmlvdXMtbW9udGhcIiwgXCJhcmlhLWxhYmVsXCI6IHByZXZpb3VzTGFiZWwsIGNsYXNzTmFtZTogcHJldmlvdXNDbGFzc05hbWUsIHN0eWxlOiBzdHlsZXMubmF2X2J1dHRvbl9wcmV2aW91cywgZGlzYWJsZWQ6ICFwcm9wcy5wcmV2aW91c01vbnRoLCBvbkNsaWNrOiBwcm9wcy5vblByZXZpb3VzQ2xpY2sgfSwgeyBjaGlsZHJlbjogZGlyID09PSAncnRsJyA/IChqc3hSdW50aW1lRXhwb3J0cy5qc3goSWNvblJpZ2h0Q29tcG9uZW50LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5uYXZfaWNvbiwgc3R5bGU6IHN0eWxlcy5uYXZfaWNvbiB9KSkgOiAoanN4UnVudGltZUV4cG9ydHMuanN4KEljb25MZWZ0Q29tcG9uZW50LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5uYXZfaWNvbiwgc3R5bGU6IHN0eWxlcy5uYXZfaWNvbiB9KSkgfSkpKSwgIXByb3BzLmhpZGVOZXh0ICYmIChqc3hSdW50aW1lRXhwb3J0cy5qc3goQnV0dG9uLCBfX2Fzc2lnbih7IG5hbWU6IFwibmV4dC1tb250aFwiLCBcImFyaWEtbGFiZWxcIjogbmV4dExhYmVsLCBjbGFzc05hbWU6IG5leHRDbGFzc05hbWUsIHN0eWxlOiBzdHlsZXMubmF2X2J1dHRvbl9uZXh0LCBkaXNhYmxlZDogIXByb3BzLm5leHRNb250aCwgb25DbGljazogcHJvcHMub25OZXh0Q2xpY2sgfSwgeyBjaGlsZHJlbjogZGlyID09PSAncnRsJyA/IChqc3hSdW50aW1lRXhwb3J0cy5qc3goSWNvbkxlZnRDb21wb25lbnQsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm5hdl9pY29uLCBzdHlsZTogc3R5bGVzLm5hdl9pY29uIH0pKSA6IChqc3hSdW50aW1lRXhwb3J0cy5qc3goSWNvblJpZ2h0Q29tcG9uZW50LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5uYXZfaWNvbiwgc3R5bGU6IHN0eWxlcy5uYXZfaWNvbiB9KSkgfSkpKV0gfSkpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBjYXB0aW9uIHdpdGggYSBidXR0b24tYmFzZWQgbmF2aWdhdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FwdGlvbk5hdmlnYXRpb24ocHJvcHMpIHtcbiAgICB2YXIgbnVtYmVyT2ZNb250aHMgPSB1c2VEYXlQaWNrZXIoKS5udW1iZXJPZk1vbnRocztcbiAgICB2YXIgX2EgPSB1c2VOYXZpZ2F0aW9uKCksIHByZXZpb3VzTW9udGggPSBfYS5wcmV2aW91c01vbnRoLCBuZXh0TW9udGggPSBfYS5uZXh0TW9udGgsIGdvVG9Nb250aCA9IF9hLmdvVG9Nb250aCwgZGlzcGxheU1vbnRocyA9IF9hLmRpc3BsYXlNb250aHM7XG4gICAgdmFyIGRpc3BsYXlJbmRleCA9IGRpc3BsYXlNb250aHMuZmluZEluZGV4KGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgocHJvcHMuZGlzcGxheU1vbnRoLCBtb250aCk7XG4gICAgfSk7XG4gICAgdmFyIGlzRmlyc3QgPSBkaXNwbGF5SW5kZXggPT09IDA7XG4gICAgdmFyIGlzTGFzdCA9IGRpc3BsYXlJbmRleCA9PT0gZGlzcGxheU1vbnRocy5sZW5ndGggLSAxO1xuICAgIHZhciBoaWRlTmV4dCA9IG51bWJlck9mTW9udGhzID4gMSAmJiAoaXNGaXJzdCB8fCAhaXNMYXN0KTtcbiAgICB2YXIgaGlkZVByZXZpb3VzID0gbnVtYmVyT2ZNb250aHMgPiAxICYmIChpc0xhc3QgfHwgIWlzRmlyc3QpO1xuICAgIHZhciBoYW5kbGVQcmV2aW91c0NsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByZXZpb3VzTW9udGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGdvVG9Nb250aChwcmV2aW91c01vbnRoKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVOZXh0Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghbmV4dE1vbnRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnb1RvTW9udGgobmV4dE1vbnRoKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KE5hdmlnYXRpb24sIHsgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGgsIGhpZGVOZXh0OiBoaWRlTmV4dCwgaGlkZVByZXZpb3VzOiBoaWRlUHJldmlvdXMsIG5leHRNb250aDogbmV4dE1vbnRoLCBwcmV2aW91c01vbnRoOiBwcmV2aW91c01vbnRoLCBvblByZXZpb3VzQ2xpY2s6IGhhbmRsZVByZXZpb3VzQ2xpY2ssIG9uTmV4dENsaWNrOiBoYW5kbGVOZXh0Q2xpY2sgfSkpO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgY2FwdGlvbiBvZiBhIG1vbnRoLiBUaGUgY2FwdGlvbiBoYXMgYSBkaWZmZXJlbnQgbGF5b3V0IHdoZW5cbiAqIHNldHRpbmcgdGhlIHtAbGluayBEYXlQaWNrZXJCYXNlLmNhcHRpb25MYXlvdXR9IHByb3AuXG4gKi9cbmZ1bmN0aW9uIENhcHRpb24ocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iID0gdXNlRGF5UGlja2VyKCksIGNsYXNzTmFtZXMgPSBfYi5jbGFzc05hbWVzLCBkaXNhYmxlTmF2aWdhdGlvbiA9IF9iLmRpc2FibGVOYXZpZ2F0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIGNhcHRpb25MYXlvdXQgPSBfYi5jYXB0aW9uTGF5b3V0LCBjb21wb25lbnRzID0gX2IuY29tcG9uZW50cztcbiAgICB2YXIgQ2FwdGlvbkxhYmVsQ29tcG9uZW50ID0gKF9hID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkNhcHRpb25MYWJlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQ2FwdGlvbkxhYmVsO1xuICAgIHZhciBjYXB0aW9uO1xuICAgIGlmIChkaXNhYmxlTmF2aWdhdGlvbikge1xuICAgICAgICBjYXB0aW9uID0gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uTGFiZWxDb21wb25lbnQsIHsgaWQ6IHByb3BzLmlkLCBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhcHRpb25MYXlvdXQgPT09ICdkcm9wZG93bicpIHtcbiAgICAgICAgY2FwdGlvbiA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3goQ2FwdGlvbkRyb3Bkb3ducywgeyBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgaWQ6IHByb3BzLmlkIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwdGlvbkxheW91dCA9PT0gJ2Ryb3Bkb3duLWJ1dHRvbnMnKSB7XG4gICAgICAgIGNhcHRpb24gPSAoanN4UnVudGltZUV4cG9ydHMuanN4cyhqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uRHJvcGRvd25zLCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBkaXNwbGF5SW5kZXg6IHByb3BzLmRpc3BsYXlJbmRleCwgaWQ6IHByb3BzLmlkIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goQ2FwdGlvbk5hdmlnYXRpb24sIHsgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGgsIGRpc3BsYXlJbmRleDogcHJvcHMuZGlzcGxheUluZGV4LCBpZDogcHJvcHMuaWQgfSldIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHRpb24gPSAoanN4UnVudGltZUV4cG9ydHMuanN4cyhqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uTGFiZWxDb21wb25lbnQsIHsgaWQ6IHByb3BzLmlkLCBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgZGlzcGxheUluZGV4OiBwcm9wcy5kaXNwbGF5SW5kZXggfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uTmF2aWdhdGlvbiwgeyBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgaWQ6IHByb3BzLmlkIH0pXSB9KSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNhcHRpb24sIHN0eWxlOiBzdHlsZXMuY2FwdGlvbiB9LCB7IGNoaWxkcmVuOiBjYXB0aW9uIH0pKSk7XG59XG5cbi8qKiBSZW5kZXIgdGhlIEZvb3RlciBjb21wb25lbnQgKGVtcHR5IGFzIGRlZmF1bHQpLiovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiBGb290ZXIocHJvcHMpIHtcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgZm9vdGVyID0gX2EuZm9vdGVyLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHRmb290ID0gX2EuY2xhc3NOYW1lcy50Zm9vdDtcbiAgICBpZiAoIWZvb3RlcilcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwge30pO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwidGZvb3RcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IHRmb290LCBzdHlsZTogc3R5bGVzLnRmb290IH0sIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInRyXCIsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInRkXCIsIF9fYXNzaWduKHsgY29sU3BhbjogOCB9LCB7IGNoaWxkcmVuOiBmb290ZXIgfSkpIH0pIH0pKSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXJpZXMgb2YgNyBkYXlzLCBzdGFydGluZyBmcm9tIHRoZSB3ZWVrLCB0byB1c2UgZm9yIGZvcm1hdHRpbmdcbiAqIHRoZSB3ZWVrZGF5IG5hbWVzIChNb25kYXksIFR1ZXNkYXksIGV0Yy4pLlxuICovXG5mdW5jdGlvbiBnZXRXZWVrZGF5cyhsb2NhbGUsIFxuLyoqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwIC0gU3VuZGF5KS4gKi9cbndlZWtTdGFydHNPbiwgXG4vKiogVXNlIElTT1dlZWsgaW5zdGVhZCBvZiBsb2NhbGUvICovXG5JU09XZWVrKSB7XG4gICAgdmFyIHN0YXJ0ID0gSVNPV2Vla1xuICAgICAgICA/IHN0YXJ0T2ZJU09XZWVrKG5ldyBEYXRlKCkpXG4gICAgICAgIDogc3RhcnRPZldlZWsobmV3IERhdGUoKSwgeyBsb2NhbGU6IGxvY2FsZSwgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24gfSk7XG4gICAgdmFyIGRheXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICB2YXIgZGF5ID0gYWRkRGF5cyhzdGFydCwgaSk7XG4gICAgICAgIGRheXMucHVzaChkYXkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF5cztcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIEhlYWRSb3cgY29tcG9uZW50IC0gaS5lLiB0aGUgdGFibGUgaGVhZCByb3cgd2l0aCB0aGUgd2Vla2RheSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gSGVhZFJvdygpIHtcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgY2xhc3NOYW1lcyA9IF9hLmNsYXNzTmFtZXMsIHN0eWxlcyA9IF9hLnN0eWxlcywgc2hvd1dlZWtOdW1iZXIgPSBfYS5zaG93V2Vla051bWJlciwgbG9jYWxlID0gX2EubG9jYWxlLCB3ZWVrU3RhcnRzT24gPSBfYS53ZWVrU3RhcnRzT24sIElTT1dlZWsgPSBfYS5JU09XZWVrLCBmb3JtYXRXZWVrZGF5TmFtZSA9IF9hLmZvcm1hdHRlcnMuZm9ybWF0V2Vla2RheU5hbWUsIGxhYmVsV2Vla2RheSA9IF9hLmxhYmVscy5sYWJlbFdlZWtkYXk7XG4gICAgdmFyIHdlZWtkYXlzID0gZ2V0V2Vla2RheXMobG9jYWxlLCB3ZWVrU3RhcnRzT24sIElTT1dlZWspO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcInRyXCIsIF9fYXNzaWduKHsgc3R5bGU6IHN0eWxlcy5oZWFkX3JvdywgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmhlYWRfcm93IH0sIHsgY2hpbGRyZW46IFtzaG93V2Vla051bWJlciAmJiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwidGRcIiwgeyBzdHlsZTogc3R5bGVzLmhlYWRfY2VsbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmhlYWRfY2VsbCB9KSksIHdlZWtkYXlzLm1hcChmdW5jdGlvbiAod2Vla2RheSwgaSkgeyByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInRoXCIsIF9fYXNzaWduKHsgc2NvcGU6IFwiY29sXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5oZWFkX2NlbGwsIHN0eWxlOiBzdHlsZXMuaGVhZF9jZWxsLCBcImFyaWEtbGFiZWxcIjogbGFiZWxXZWVrZGF5KHdlZWtkYXksIHsgbG9jYWxlOiBsb2NhbGUgfSkgfSwgeyBjaGlsZHJlbjogZm9ybWF0V2Vla2RheU5hbWUod2Vla2RheSwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9KSwgaSkpOyB9KV0gfSkpKTtcbn1cblxuLyoqIFJlbmRlciB0aGUgdGFibGUgaGVhZC4gKi9cbmZ1bmN0aW9uIEhlYWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYiA9IHVzZURheVBpY2tlcigpLCBjbGFzc05hbWVzID0gX2IuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Iuc3R5bGVzLCBjb21wb25lbnRzID0gX2IuY29tcG9uZW50cztcbiAgICB2YXIgSGVhZFJvd0NvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5IZWFkUm93KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBIZWFkUm93O1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwidGhlYWRcIiwgX19hc3NpZ24oeyBzdHlsZTogc3R5bGVzLmhlYWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5oZWFkIH0sIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChIZWFkUm93Q29tcG9uZW50LCB7fSkgfSkpKTtcbn1cblxuLyoqIFJlbmRlciB0aGUgY29udGVudCBvZiB0aGUgZGF5IGNlbGwuICovXG5mdW5jdGlvbiBEYXlDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF9hID0gdXNlRGF5UGlja2VyKCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgZm9ybWF0RGF5ID0gX2EuZm9ybWF0dGVycy5mb3JtYXREYXk7XG4gICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwgeyBjaGlsZHJlbjogZm9ybWF0RGF5KHByb3BzLmRhdGUsIHsgbG9jYWxlOiBsb2NhbGUgfSkgfSk7XG59XG5cbi8qKlxuICogVGhlIFNlbGVjdE11bHRpcGxlIGNvbnRleHQgc2hhcmVzIGRldGFpbHMgYWJvdXQgdGhlIHNlbGVjdGVkIGRheXMgd2hlbiBpblxuICogbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuXG4gKlxuICogQWNjZXNzIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlU2VsZWN0TXVsdGlwbGV9IGhvb2suXG4gKi9cbnZhciBTZWxlY3RNdWx0aXBsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKiogUHJvdmlkZXMgdGhlIHZhbHVlcyBmb3IgdGhlIHtAbGluayBTZWxlY3RNdWx0aXBsZUNvbnRleHR9LiAqL1xuZnVuY3Rpb24gU2VsZWN0TXVsdGlwbGVQcm92aWRlcihwcm9wcykge1xuICAgIGlmICghaXNEYXlQaWNrZXJNdWx0aXBsZShwcm9wcy5pbml0aWFsUHJvcHMpKSB7XG4gICAgICAgIHZhciBlbXB0eUNvbnRleHRWYWx1ZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0TXVsdGlwbGVDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiBlbXB0eUNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RNdWx0aXBsZVByb3ZpZGVySW50ZXJuYWwsIHsgaW5pdGlhbFByb3BzOiBwcm9wcy5pbml0aWFsUHJvcHMsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSk7XG59XG5mdW5jdGlvbiBTZWxlY3RNdWx0aXBsZVByb3ZpZGVySW50ZXJuYWwoX2EpIHtcbiAgICB2YXIgaW5pdGlhbFByb3BzID0gX2EuaW5pdGlhbFByb3BzLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciBzZWxlY3RlZCA9IGluaXRpYWxQcm9wcy5zZWxlY3RlZCwgbWluID0gaW5pdGlhbFByb3BzLm1pbiwgbWF4ID0gaW5pdGlhbFByb3BzLm1heDtcbiAgICB2YXIgb25EYXlDbGljayA9IGZ1bmN0aW9uIChkYXksIGFjdGl2ZU1vZGlmaWVycywgZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2EgPSBpbml0aWFsUHJvcHMub25EYXlDbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5pdGlhbFByb3BzLCBkYXksIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgICAgIHZhciBpc01pblNlbGVjdGVkID0gQm9vbGVhbihhY3RpdmVNb2RpZmllcnMuc2VsZWN0ZWQgJiYgbWluICYmIChzZWxlY3RlZCA9PT0gbnVsbCB8fCBzZWxlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWQubGVuZ3RoKSA9PT0gbWluKTtcbiAgICAgICAgaWYgKGlzTWluU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNNYXhTZWxlY3RlZCA9IEJvb2xlYW4oIWFjdGl2ZU1vZGlmaWVycy5zZWxlY3RlZCAmJiBtYXggJiYgKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5sZW5ndGgpID09PSBtYXgpO1xuICAgICAgICBpZiAoaXNNYXhTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZERheXMgPSBzZWxlY3RlZCA/IF9fc3ByZWFkQXJyYXkoW10sIHNlbGVjdGVkLCB0cnVlKSA6IFtdO1xuICAgICAgICBpZiAoYWN0aXZlTW9kaWZpZXJzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3RlZERheXMuZmluZEluZGV4KGZ1bmN0aW9uIChzZWxlY3RlZERheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBzZWxlY3RlZERheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkRGF5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWREYXlzLnB1c2goZGF5KTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSBpbml0aWFsUHJvcHMub25TZWxlY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGluaXRpYWxQcm9wcywgc2VsZWN0ZWREYXlzLCBkYXksIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0ge1xuICAgICAgICBkaXNhYmxlZDogW11cbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaChmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICB2YXIgaXNNYXhTZWxlY3RlZCA9IG1heCAmJiBzZWxlY3RlZC5sZW5ndGggPiBtYXggLSAxO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3RlZC5zb21lKGZ1bmN0aW9uIChzZWxlY3RlZERheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoc2VsZWN0ZWREYXksIGRheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGlzTWF4U2VsZWN0ZWQgJiYgIWlzU2VsZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNvbnRleHRWYWx1ZSA9IHtcbiAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICBvbkRheUNsaWNrOiBvbkRheUNsaWNrLFxuICAgICAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0TXVsdGlwbGVDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKTtcbn1cbi8qKlxuICogSG9vayB0byBhY2Nlc3MgdGhlIHtAbGluayBTZWxlY3RNdWx0aXBsZUNvbnRleHRWYWx1ZX0uXG4gKlxuICogVGhpcyBob29rIGlzIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiB1c2VTZWxlY3RNdWx0aXBsZSgpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2VsZWN0TXVsdGlwbGVDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VTZWxlY3RNdWx0aXBsZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU2VsZWN0TXVsdGlwbGVQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBBZGQgYSBkYXkgdG8gYW4gZXhpc3RpbmcgcmFuZ2UuXG4gKlxuICogVGhlIHJldHVybmVkIHJhbmdlIHRha2VzIGluIGFjY291bnQgdGhlIGB1bmRlZmluZWRgIHZhbHVlcyBhbmQgaWYgdGhlIGFkZGVkXG4gKiBkYXkgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYWRkVG9SYW5nZShkYXksIHJhbmdlKSB7XG4gICAgdmFyIF9hID0gcmFuZ2UgfHwge30sIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvO1xuICAgIGlmIChmcm9tICYmIHRvKSB7XG4gICAgICAgIGlmIChpc1NhbWVEYXkodG8sIGRheSkgJiYgaXNTYW1lRGF5KGZyb20sIGRheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2FtZURheSh0bywgZGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogdG8sIHRvOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTYW1lRGF5KGZyb20sIGRheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQWZ0ZXIoZnJvbSwgZGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGF5LCB0bzogdG8gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogZGF5IH07XG4gICAgfVxuICAgIGlmICh0bykge1xuICAgICAgICBpZiAoaXNBZnRlcihkYXksIHRvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogdG8sIHRvOiBkYXkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBkYXksIHRvOiB0byB9O1xuICAgIH1cbiAgICBpZiAoZnJvbSkge1xuICAgICAgICBpZiAoaXNCZWZvcmUoZGF5LCBmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGF5LCB0bzogZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb20sIHRvOiBkYXkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbTogZGF5LCB0bzogdW5kZWZpbmVkIH07XG59XG5cbi8qKlxuICogVGhlIFNlbGVjdFJhbmdlIGNvbnRleHQgc2hhcmVzIGRldGFpbHMgYWJvdXQgdGhlIHNlbGVjdGVkIGRheXMgd2hlbiBpblxuICogcmFuZ2Ugc2VsZWN0aW9uIG1vZGUuXG4gKlxuICogQWNjZXNzIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlU2VsZWN0UmFuZ2V9IGhvb2suXG4gKi9cbnZhciBTZWxlY3RSYW5nZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKiogUHJvdmlkZXMgdGhlIHZhbHVlcyBmb3IgdGhlIHtAbGluayBTZWxlY3RSYW5nZVByb3ZpZGVyfS4gKi9cbmZ1bmN0aW9uIFNlbGVjdFJhbmdlUHJvdmlkZXIocHJvcHMpIHtcbiAgICBpZiAoIWlzRGF5UGlja2VyUmFuZ2UocHJvcHMuaW5pdGlhbFByb3BzKSkge1xuICAgICAgICB2YXIgZW1wdHlDb250ZXh0VmFsdWUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgICAgcmFuZ2Vfc3RhcnQ6IFtdLFxuICAgICAgICAgICAgICAgIHJhbmdlX2VuZDogW10sXG4gICAgICAgICAgICAgICAgcmFuZ2VfbWlkZGxlOiBbXSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0UmFuZ2VDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiBlbXB0eUNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RSYW5nZVByb3ZpZGVySW50ZXJuYWwsIHsgaW5pdGlhbFByb3BzOiBwcm9wcy5pbml0aWFsUHJvcHMsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSk7XG59XG5mdW5jdGlvbiBTZWxlY3RSYW5nZVByb3ZpZGVySW50ZXJuYWwoX2EpIHtcbiAgICB2YXIgaW5pdGlhbFByb3BzID0gX2EuaW5pdGlhbFByb3BzLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciBzZWxlY3RlZCA9IGluaXRpYWxQcm9wcy5zZWxlY3RlZDtcbiAgICB2YXIgX2IgPSBzZWxlY3RlZCB8fCB7fSwgc2VsZWN0ZWRGcm9tID0gX2IuZnJvbSwgc2VsZWN0ZWRUbyA9IF9iLnRvO1xuICAgIHZhciBtaW4gPSBpbml0aWFsUHJvcHMubWluO1xuICAgIHZhciBtYXggPSBpbml0aWFsUHJvcHMubWF4O1xuICAgIHZhciBvbkRheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IGluaXRpYWxQcm9wcy5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbml0aWFsUHJvcHMsIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgdmFyIG5ld1JhbmdlID0gYWRkVG9SYW5nZShkYXksIHNlbGVjdGVkKTtcbiAgICAgICAgKF9iID0gaW5pdGlhbFByb3BzLm9uU2VsZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbml0aWFsUHJvcHMsIG5ld1JhbmdlLCBkYXksIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0ge1xuICAgICAgICByYW5nZV9zdGFydDogW10sXG4gICAgICAgIHJhbmdlX2VuZDogW10sXG4gICAgICAgIHJhbmdlX21pZGRsZTogW10sXG4gICAgICAgIGRpc2FibGVkOiBbXVxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkRnJvbSkge1xuICAgICAgICBtb2RpZmllcnMucmFuZ2Vfc3RhcnQgPSBbc2VsZWN0ZWRGcm9tXTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFRvKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucmFuZ2VfZW5kID0gW3NlbGVjdGVkRnJvbV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucmFuZ2VfZW5kID0gW3NlbGVjdGVkVG9dO1xuICAgICAgICAgICAgaWYgKCFpc1NhbWVEYXkoc2VsZWN0ZWRGcm9tLCBzZWxlY3RlZFRvKSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5yYW5nZV9taWRkbGUgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiBzZWxlY3RlZEZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IHNlbGVjdGVkVG9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZWN0ZWRUbykge1xuICAgICAgICBtb2RpZmllcnMucmFuZ2Vfc3RhcnQgPSBbc2VsZWN0ZWRUb107XG4gICAgICAgIG1vZGlmaWVycy5yYW5nZV9lbmQgPSBbc2VsZWN0ZWRUb107XG4gICAgfVxuICAgIGlmIChtaW4pIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkRnJvbSAmJiAhc2VsZWN0ZWRUbykge1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFmdGVyOiBzdWJEYXlzKHNlbGVjdGVkRnJvbSwgbWluIC0gMSksXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBhZGREYXlzKHNlbGVjdGVkRnJvbSwgbWluIC0gMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZEZyb20gJiYgc2VsZWN0ZWRUbykge1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFmdGVyOiBzZWxlY3RlZEZyb20sXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBhZGREYXlzKHNlbGVjdGVkRnJvbSwgbWluIC0gMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0ZWRGcm9tICYmIHNlbGVjdGVkVG8pIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5kaXNhYmxlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZnRlcjogc3ViRGF5cyhzZWxlY3RlZFRvLCBtaW4gLSAxKSxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGFkZERheXMoc2VsZWN0ZWRUbywgbWluIC0gMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXgpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkRnJvbSAmJiAhc2VsZWN0ZWRUbykge1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGJlZm9yZTogYWRkRGF5cyhzZWxlY3RlZEZyb20sIC1tYXggKyAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGFkZERheXMoc2VsZWN0ZWRGcm9tLCBtYXggLSAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkRnJvbSAmJiBzZWxlY3RlZFRvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRDb3VudCA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhzZWxlY3RlZFRvLCBzZWxlY3RlZEZyb20pICsgMTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXggLSBzZWxlY3RlZENvdW50O1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGJlZm9yZTogc3ViRGF5cyhzZWxlY3RlZEZyb20sIG9mZnNldClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFmdGVyOiBhZGREYXlzKHNlbGVjdGVkVG8sIG9mZnNldClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0ZWRGcm9tICYmIHNlbGVjdGVkVG8pIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5kaXNhYmxlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGFkZERheXMoc2VsZWN0ZWRUbywgLW1heCArIDEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGlmaWVycy5kaXNhYmxlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZnRlcjogYWRkRGF5cyhzZWxlY3RlZFRvLCBtYXggLSAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0UmFuZ2VDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiB7IHNlbGVjdGVkOiBzZWxlY3RlZCwgb25EYXlDbGljazogb25EYXlDbGljaywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufVxuLyoqXG4gKiBIb29rIHRvIGFjY2VzcyB0aGUge0BsaW5rIFNlbGVjdFJhbmdlQ29udGV4dFZhbHVlfS5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHVzZVNlbGVjdFJhbmdlKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTZWxlY3RSYW5nZUNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVNlbGVjdFJhbmdlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTZWxlY3RSYW5nZVByb3ZpZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG4vKiogTm9ybWFsaXplIHRvIGFycmF5IGEgbWF0Y2hlciBpbnB1dC4gKi9cbmZ1bmN0aW9uIG1hdGNoZXJUb0FycmF5KG1hdGNoZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaGVyKSkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXSwgbWF0Y2hlciwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW21hdGNoZXJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuLyoqIENyZWF0ZSBDdXN0b21Nb2RpZmllcnMgZnJvbSBkYXlNb2RpZmllcnMgKi9cbmZ1bmN0aW9uIGdldEN1c3RvbU1vZGlmaWVycyhkYXlNb2RpZmllcnMpIHtcbiAgICB2YXIgY3VzdG9tTW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoZGF5TW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbW9kaWZpZXIgPSBfYVswXSwgbWF0Y2hlciA9IF9hWzFdO1xuICAgICAgICBjdXN0b21Nb2RpZmllcnNbbW9kaWZpZXJdID0gbWF0Y2hlclRvQXJyYXkobWF0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1c3RvbU1vZGlmaWVycztcbn1cblxuLyoqIFRoZSBuYW1lIG9mIHRoZSBtb2RpZmllcnMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IERheVBpY2tlci4gKi9cbnZhciBJbnRlcm5hbE1vZGlmaWVyO1xuKGZ1bmN0aW9uIChJbnRlcm5hbE1vZGlmaWVyKSB7XG4gICAgSW50ZXJuYWxNb2RpZmllcltcIk91dHNpZGVcIl0gPSBcIm91dHNpZGVcIjtcbiAgICAvKiogTmFtZSBvZiB0aGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgZGlzYWJsZWQgZGF5cywgdXNpbmcgdGhlIGBkaXNhYmxlZGAgcHJvcC4gKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiRGlzYWJsZWRcIl0gPSBcImRpc2FibGVkXCI7XG4gICAgLyoqIE5hbWUgb2YgdGhlIG1vZGlmaWVyIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGVkIGRheXMgdXNpbmcgdGhlIGBzZWxlY3RlZGAgcHJvcCkuICovXG4gICAgSW50ZXJuYWxNb2RpZmllcltcIlNlbGVjdGVkXCJdID0gXCJzZWxlY3RlZFwiO1xuICAgIC8qKiBOYW1lIG9mIHRoZSBtb2RpZmllciBhcHBsaWVkIHRvIHRoZSBoaWRkZW4gZGF5cyB1c2luZyB0aGUgYGhpZGRlbmAgcHJvcCkuICovXG4gICAgSW50ZXJuYWxNb2RpZmllcltcIkhpZGRlblwiXSA9IFwiaGlkZGVuXCI7XG4gICAgLyoqIE5hbWUgb2YgdGhlIG1vZGlmaWVyIGFwcGxpZWQgdG8gdGhlIGRheSBzcGVjaWZpZWQgdXNpbmcgdGhlIGB0b2RheWAgcHJvcCkuICovXG4gICAgSW50ZXJuYWxNb2RpZmllcltcIlRvZGF5XCJdID0gXCJ0b2RheVwiO1xuICAgIC8qKiBUaGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgZGF5IHN0YXJ0aW5nIGEgc2VsZWN0ZWQgcmFuZ2UsIHdoZW4gaW4gcmFuZ2Ugc2VsZWN0aW9uIG1vZGUuICAqL1xuICAgIEludGVybmFsTW9kaWZpZXJbXCJSYW5nZVN0YXJ0XCJdID0gXCJyYW5nZV9zdGFydFwiO1xuICAgIC8qKiBUaGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgZGF5IGVuZGluZyBhIHNlbGVjdGVkIHJhbmdlLCB3aGVuIGluIHJhbmdlIHNlbGVjdGlvbiBtb2RlLiAgKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiUmFuZ2VFbmRcIl0gPSBcInJhbmdlX2VuZFwiO1xuICAgIC8qKiBUaGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgZGF5cyBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgdGhlIGVuZCBvZiBhIHNlbGVjdGVkIHJhbmdlLCB3aGVuIGluIHJhbmdlIHNlbGVjdGlvbiBtb2RlLiAgKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiUmFuZ2VNaWRkbGVcIl0gPSBcInJhbmdlX21pZGRsZVwiO1xufSkoSW50ZXJuYWxNb2RpZmllciB8fCAoSW50ZXJuYWxNb2RpZmllciA9IHt9KSk7XG5cbnZhciBTZWxlY3RlZCA9IEludGVybmFsTW9kaWZpZXIuU2VsZWN0ZWQsIERpc2FibGVkID0gSW50ZXJuYWxNb2RpZmllci5EaXNhYmxlZCwgSGlkZGVuID0gSW50ZXJuYWxNb2RpZmllci5IaWRkZW4sIFRvZGF5ID0gSW50ZXJuYWxNb2RpZmllci5Ub2RheSwgUmFuZ2VFbmQgPSBJbnRlcm5hbE1vZGlmaWVyLlJhbmdlRW5kLCBSYW5nZU1pZGRsZSA9IEludGVybmFsTW9kaWZpZXIuUmFuZ2VNaWRkbGUsIFJhbmdlU3RhcnQgPSBJbnRlcm5hbE1vZGlmaWVyLlJhbmdlU3RhcnQsIE91dHNpZGUgPSBJbnRlcm5hbE1vZGlmaWVyLk91dHNpZGU7XG4vKiogUmV0dXJuIHRoZSB7QGxpbmsgSW50ZXJuYWxNb2RpZmllcnN9IGZyb20gdGhlIERheVBpY2tlciBhbmQgc2VsZWN0IGNvbnRleHRzLiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2RpZmllcnMoZGF5UGlja2VyLCBzZWxlY3RNdWx0aXBsZSwgc2VsZWN0UmFuZ2UpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGludGVybmFsTW9kaWZpZXJzID0gKF9hID0ge30sXG4gICAgICAgIF9hW1NlbGVjdGVkXSA9IG1hdGNoZXJUb0FycmF5KGRheVBpY2tlci5zZWxlY3RlZCksXG4gICAgICAgIF9hW0Rpc2FibGVkXSA9IG1hdGNoZXJUb0FycmF5KGRheVBpY2tlci5kaXNhYmxlZCksXG4gICAgICAgIF9hW0hpZGRlbl0gPSBtYXRjaGVyVG9BcnJheShkYXlQaWNrZXIuaGlkZGVuKSxcbiAgICAgICAgX2FbVG9kYXldID0gW2RheVBpY2tlci50b2RheV0sXG4gICAgICAgIF9hW1JhbmdlRW5kXSA9IFtdLFxuICAgICAgICBfYVtSYW5nZU1pZGRsZV0gPSBbXSxcbiAgICAgICAgX2FbUmFuZ2VTdGFydF0gPSBbXSxcbiAgICAgICAgX2FbT3V0c2lkZV0gPSBbXSxcbiAgICAgICAgX2EpO1xuICAgIGlmIChkYXlQaWNrZXIuZnJvbURhdGUpIHtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbRGlzYWJsZWRdLnB1c2goeyBiZWZvcmU6IGRheVBpY2tlci5mcm9tRGF0ZSB9KTtcbiAgICB9XG4gICAgaWYgKGRheVBpY2tlci50b0RhdGUpIHtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbRGlzYWJsZWRdLnB1c2goeyBhZnRlcjogZGF5UGlja2VyLnRvRGF0ZSB9KTtcbiAgICB9XG4gICAgaWYgKGlzRGF5UGlja2VyTXVsdGlwbGUoZGF5UGlja2VyKSkge1xuICAgICAgICBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0gPSBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0uY29uY2F0KHNlbGVjdE11bHRpcGxlLm1vZGlmaWVyc1tEaXNhYmxlZF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0RheVBpY2tlclJhbmdlKGRheVBpY2tlcikpIHtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbRGlzYWJsZWRdID0gaW50ZXJuYWxNb2RpZmllcnNbRGlzYWJsZWRdLmNvbmNhdChzZWxlY3RSYW5nZS5tb2RpZmllcnNbRGlzYWJsZWRdKTtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbUmFuZ2VTdGFydF0gPSBzZWxlY3RSYW5nZS5tb2RpZmllcnNbUmFuZ2VTdGFydF07XG4gICAgICAgIGludGVybmFsTW9kaWZpZXJzW1JhbmdlTWlkZGxlXSA9IHNlbGVjdFJhbmdlLm1vZGlmaWVyc1tSYW5nZU1pZGRsZV07XG4gICAgICAgIGludGVybmFsTW9kaWZpZXJzW1JhbmdlRW5kXSA9IHNlbGVjdFJhbmdlLm1vZGlmaWVyc1tSYW5nZUVuZF07XG4gICAgfVxuICAgIHJldHVybiBpbnRlcm5hbE1vZGlmaWVycztcbn1cblxuLyoqIFRoZSBNb2RpZmllcnMgY29udGV4dCBzdG9yZSB0aGUgbW9kaWZpZXJzIHVzZWQgaW4gRGF5UGlja2VyLiBUbyBhY2Nlc3MgdGhlIHZhbHVlIG9mIHRoaXMgY29udGV4dCwgdXNlIHtAbGluayB1c2VNb2RpZmllcnN9LiAqL1xudmFyIE1vZGlmaWVyc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKiogUHJvdmlkZSB0aGUgdmFsdWUgZm9yIHRoZSB7QGxpbmsgTW9kaWZpZXJzQ29udGV4dH0uICovXG5mdW5jdGlvbiBNb2RpZmllcnNQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBkYXlQaWNrZXIgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgc2VsZWN0TXVsdGlwbGUgPSB1c2VTZWxlY3RNdWx0aXBsZSgpO1xuICAgIHZhciBzZWxlY3RSYW5nZSA9IHVzZVNlbGVjdFJhbmdlKCk7XG4gICAgdmFyIGludGVybmFsTW9kaWZpZXJzID0gZ2V0SW50ZXJuYWxNb2RpZmllcnMoZGF5UGlja2VyLCBzZWxlY3RNdWx0aXBsZSwgc2VsZWN0UmFuZ2UpO1xuICAgIHZhciBjdXN0b21Nb2RpZmllcnMgPSBnZXRDdXN0b21Nb2RpZmllcnMoZGF5UGlja2VyLm1vZGlmaWVycyk7XG4gICAgdmFyIG1vZGlmaWVycyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbnRlcm5hbE1vZGlmaWVycyksIGN1c3RvbU1vZGlmaWVycyk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goTW9kaWZpZXJzQ29udGV4dC5Qcm92aWRlciwgX19hc3NpZ24oeyB2YWx1ZTogbW9kaWZpZXJzIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbW9kaWZpZXJzIHVzZWQgYnkgRGF5UGlja2VyLlxuICpcbiAqIFRoaXMgaG9vayBpcyBtZWFudCB0byBiZSB1c2VkIGluc2lkZSBpbnRlcm5hbCBvciBjdXN0b20gY29tcG9uZW50cy5cbiAqIFJlcXVpcmVzIHRvIGJlIHdyYXBwZWQgaW50byB7QGxpbmsgTW9kaWZpZXJzUHJvdmlkZXJ9LlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTW9kaWZpZXJzKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNb2RpZmllcnNDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VNb2RpZmllcnMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE1vZGlmaWVyc1Byb3ZpZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGBtYXRjaGVyYCBpcyBvZiB0eXBlIHtAbGluayBEYXRlSW50ZXJ2YWx9LiAqL1xuZnVuY3Rpb24gaXNEYXRlSW50ZXJ2YWwobWF0Y2hlcikge1xuICAgIHJldHVybiBCb29sZWFuKG1hdGNoZXIgJiZcbiAgICAgICAgdHlwZW9mIG1hdGNoZXIgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdiZWZvcmUnIGluIG1hdGNoZXIgJiZcbiAgICAgICAgJ2FmdGVyJyBpbiBtYXRjaGVyKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIHtAbGluayBEYXRlUmFuZ2V9IHR5cGUuICovXG5mdW5jdGlvbiBpc0RhdGVSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ2Zyb20nIGluIHZhbHVlKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBvZiB0eXBlIHtAbGluayBEYXRlQWZ0ZXJ9LiAqL1xuZnVuY3Rpb24gaXNEYXRlQWZ0ZXJUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnYWZ0ZXInIGluIHZhbHVlKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBvZiB0eXBlIHtAbGluayBEYXRlQmVmb3JlfS4gKi9cbmZ1bmN0aW9uIGlzRGF0ZUJlZm9yZVR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdiZWZvcmUnIGluIHZhbHVlKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIHtAbGluayBEYXlPZldlZWt9IHR5cGUuICovXG5mdW5jdGlvbiBpc0RheU9mV2Vla1R5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdkYXlPZldlZWsnIGluIHZhbHVlKTtcbn1cblxuLyoqIFJldHVybiBgdHJ1ZWAgd2hldGhlciBgZGF0ZWAgaXMgaW5zaWRlIGByYW5nZWAuICovXG5mdW5jdGlvbiBpc0RhdGVJblJhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSwgdG8gPSByYW5nZS50bztcbiAgICBpZiAoZnJvbSAmJiB0bykge1xuICAgICAgICB2YXIgaXNSYW5nZUludmVydGVkID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKHRvLCBmcm9tKSA8IDA7XG4gICAgICAgIGlmIChpc1JhbmdlSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgIF9hID0gW3RvLCBmcm9tXSwgZnJvbSA9IF9hWzBdLCB0byA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0luUmFuZ2UgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZSwgZnJvbSkgPj0gMCAmJlxuICAgICAgICAgICAgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKHRvLCBkYXRlKSA+PSAwO1xuICAgICAgICByZXR1cm4gaXNJblJhbmdlO1xuICAgIH1cbiAgICBpZiAodG8pIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZURheSh0bywgZGF0ZSk7XG4gICAgfVxuICAgIGlmIChmcm9tKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVEYXkoZnJvbSwgZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgRGF0ZSB0eXBlLiAqL1xuZnVuY3Rpb24gaXNEYXRlVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc0RhdGUodmFsdWUpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IG9mIHZhbGlkIGRhdGVzLiAqL1xuZnVuY3Rpb24gaXNBcnJheU9mRGF0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoaXNEYXRlKTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgZGF5IG1hdGNoZXMgYWdhaW5zdCBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIE1hdGNoZXJzLlxuICpcbiAqIGBgYFxuICogY29uc3QgZGF5ID0gbmV3IERhdGUoMjAyMiwgNSwgMTkpO1xuICogY29uc3QgbWF0Y2hlcjE6IERhdGVSYW5nZSA9IHtcbiAqICAgIGZyb206IG5ldyBEYXRlKDIwMjEsIDEyLCAyMSksXG4gKiAgICB0bzogbmV3IERhdGUoMjAyMSwgMTIsIDMwKVxuICogfVxuICogY29uc3QgbWF0Y2hlcjI6IERhdGVSYW5nZSA9IHtcbiAqICAgIGZyb206IG5ldyBEYXRlKDIwMjIsIDUsIDEpLFxuICogICAgdG86IG5ldyBEYXRlKDIwMjIsIDUsIDIzKVxuICogfVxuICpcbiAqIGNvbnN0IGlzTWF0Y2goZGF5LCBbbWF0Y2hlcjEsIG1hdGNoZXIyXSk7IC8vIHRydWUsIHNpbmNlIGRheSBpcyBpbiB0aGUgbWF0Y2hlcjEgcmFuZ2UuXG4gKiBgYGBcbiAqICovXG5mdW5jdGlvbiBpc01hdGNoKGRheSwgbWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZShmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0ZVR5cGUobWF0Y2hlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBtYXRjaGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheU9mRGF0ZXMobWF0Y2hlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLmluY2x1ZGVzKGRheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0ZVJhbmdlKG1hdGNoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEYXRlSW5SYW5nZShkYXksIG1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RheU9mV2Vla1R5cGUobWF0Y2hlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLmRheU9mV2Vlay5pbmNsdWRlcyhkYXkuZ2V0RGF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RhdGVJbnRlcnZhbChtYXRjaGVyKSkge1xuICAgICAgICAgICAgdmFyIGRpZmZCZWZvcmUgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMobWF0Y2hlci5iZWZvcmUsIGRheSk7XG4gICAgICAgICAgICB2YXIgZGlmZkFmdGVyID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKG1hdGNoZXIuYWZ0ZXIsIGRheSk7XG4gICAgICAgICAgICB2YXIgaXNEYXlCZWZvcmUgPSBkaWZmQmVmb3JlID4gMDtcbiAgICAgICAgICAgIHZhciBpc0RheUFmdGVyID0gZGlmZkFmdGVyIDwgMDtcbiAgICAgICAgICAgIHZhciBpc0Nsb3NlZEludGVydmFsID0gaXNBZnRlcihtYXRjaGVyLmJlZm9yZSwgbWF0Y2hlci5hZnRlcik7XG4gICAgICAgICAgICBpZiAoaXNDbG9zZWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RheUFmdGVyICYmIGlzRGF5QmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5QmVmb3JlIHx8IGlzRGF5QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0ZUFmdGVyVHlwZShtYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXksIG1hdGNoZXIuYWZ0ZXIpID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRlQmVmb3JlVHlwZShtYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhtYXRjaGVyLmJlZm9yZSwgZGF5KSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihkYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cblxuLyoqIFJldHVybiB0aGUgYWN0aXZlIG1vZGlmaWVycyBmb3IgdGhlIGdpdmVuIGRheS4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZU1vZGlmaWVycyhkYXksIFxuLyoqIFRoZSBtb2RpZmllcnMgdG8gbWF0Y2ggZm9yIHRoZSBnaXZlbiBkYXRlLiAqL1xubW9kaWZpZXJzLCBcbi8qKiBUaGUgbW9udGggd2hlcmUgdGhlIGRheSBpcyBkaXNwbGF5ZWQsIHRvIGFkZCB0aGUgXCJvdXRzaWRlXCIgbW9kaWZpZXJzLiAgKi9cbmRpc3BsYXlNb250aCkge1xuICAgIHZhciBtYXRjaGVkTW9kaWZpZXJzID0gT2JqZWN0LmtleXMobW9kaWZpZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IG1vZGlmaWVyc1trZXldO1xuICAgICAgICBpZiAoaXNNYXRjaChkYXksIG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgYWN0aXZlTW9kaWZpZXJzID0ge307XG4gICAgbWF0Y2hlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gKGFjdGl2ZU1vZGlmaWVyc1ttb2RpZmllcl0gPSB0cnVlKTsgfSk7XG4gICAgaWYgKGRpc3BsYXlNb250aCAmJiAhaXNTYW1lTW9udGgoZGF5LCBkaXNwbGF5TW9udGgpKSB7XG4gICAgICAgIGFjdGl2ZU1vZGlmaWVycy5vdXRzaWRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZU1vZGlmaWVycztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXkgdGhhdCBzaG91bGQgYmUgdGhlIHRhcmdldCBvZiB0aGUgZm9jdXMgd2hlbiBEYXlQaWNrZXIgaXNcbiAqIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICpcbiAqIFRPRE86IHRoaXMgZnVuY3Rpb24gZG9lc24ndCBjb25zaWRlciBpZiB0aGUgZGF5IGlzIG91dHNpZGUgdGhlIG1vbnRoLiBXZVxuICogaW1wbGVtZW50ZWQgdGhpcyBjaGVjayBpbiBgdXNlRGF5UmVuZGVyYCBidXQgaXQgc2hvdWxkIHByb2JhYmx5IGdvIGhlcmUuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dwYmwvcmVhY3QtZGF5LXBpY2tlci9wdWxsLzE1NzZcbiAqL1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzVGFyZ2V0KGRpc3BsYXlNb250aHMsIG1vZGlmaWVycykge1xuICAgIHZhciBmaXJzdERheUluTW9udGggPSBzdGFydE9mTW9udGgoZGlzcGxheU1vbnRoc1swXSk7XG4gICAgdmFyIGxhc3REYXlJbk1vbnRoID0gZW5kT2ZNb250aChkaXNwbGF5TW9udGhzW2Rpc3BsYXlNb250aHMubGVuZ3RoIC0gMV0pO1xuICAgIC8vIFRPRE86IGNsZWFudXAgY29kZVxuICAgIHZhciBmaXJzdEZvY3VzYWJsZURheTtcbiAgICB2YXIgdG9kYXk7XG4gICAgdmFyIGRhdGUgPSBmaXJzdERheUluTW9udGg7XG4gICAgd2hpbGUgKGRhdGUgPD0gbGFzdERheUluTW9udGgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZU1vZGlmaWVycyA9IGdldEFjdGl2ZU1vZGlmaWVycyhkYXRlLCBtb2RpZmllcnMpO1xuICAgICAgICB2YXIgaXNGb2N1c2FibGUgPSAhYWN0aXZlTW9kaWZpZXJzLmRpc2FibGVkICYmICFhY3RpdmVNb2RpZmllcnMuaGlkZGVuO1xuICAgICAgICBpZiAoIWlzRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCAxKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVNb2RpZmllcnMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVNb2RpZmllcnMudG9kYXkgJiYgIXRvZGF5KSB7XG4gICAgICAgICAgICB0b2RheSA9IGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEZvY3VzYWJsZURheSkge1xuICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVEYXkgPSBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgIH1cbiAgICBpZiAodG9kYXkpIHtcbiAgICAgICAgcmV0dXJuIHRvZGF5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9jdXNhYmxlRGF5O1xuICAgIH1cbn1cblxudmFyIE1BWF9SRVRSWSA9IDM2NTtcbi8qKiBSZXR1cm4gdGhlIG5leHQgZGF0ZSB0byBiZSBmb2N1c2VkLiAqL1xuZnVuY3Rpb24gZ2V0TmV4dEZvY3VzKGZvY3VzZWREYXksIG9wdGlvbnMpIHtcbiAgICB2YXIgbW92ZUJ5ID0gb3B0aW9ucy5tb3ZlQnksIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uLCBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBtb2RpZmllcnMgPSBvcHRpb25zLm1vZGlmaWVycywgX2EgPSBvcHRpb25zLnJldHJ5LCByZXRyeSA9IF9hID09PSB2b2lkIDAgPyB7IGNvdW50OiAwLCBsYXN0Rm9jdXNlZDogZm9jdXNlZERheSB9IDogX2E7XG4gICAgdmFyIHdlZWtTdGFydHNPbiA9IGNvbnRleHQud2Vla1N0YXJ0c09uLCBmcm9tRGF0ZSA9IGNvbnRleHQuZnJvbURhdGUsIHRvRGF0ZSA9IGNvbnRleHQudG9EYXRlLCBsb2NhbGUgPSBjb250ZXh0LmxvY2FsZTtcbiAgICB2YXIgbW92ZUZucyA9IHtcbiAgICAgICAgZGF5OiBhZGREYXlzLFxuICAgICAgICB3ZWVrOiBhZGRXZWVrcyxcbiAgICAgICAgbW9udGg6IGFkZE1vbnRocyxcbiAgICAgICAgeWVhcjogYWRkWWVhcnMsXG4gICAgICAgIHN0YXJ0T2ZXZWVrOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuSVNPV2Vla1xuICAgICAgICAgICAgICAgID8gc3RhcnRPZklTT1dlZWsoZGF0ZSlcbiAgICAgICAgICAgICAgICA6IHN0YXJ0T2ZXZWVrKGRhdGUsIHsgbG9jYWxlOiBsb2NhbGUsIHdlZWtTdGFydHNPbjogd2Vla1N0YXJ0c09uIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbmRPZldlZWs6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5JU09XZWVrXG4gICAgICAgICAgICAgICAgPyBlbmRPZklTT1dlZWsoZGF0ZSlcbiAgICAgICAgICAgICAgICA6IGVuZE9mV2VlayhkYXRlLCB7IGxvY2FsZTogbG9jYWxlLCB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbiB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG5ld0ZvY3VzZWREYXkgPSBtb3ZlRm5zW21vdmVCeV0oZm9jdXNlZERheSwgZGlyZWN0aW9uID09PSAnYWZ0ZXInID8gMSA6IC0xKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnYmVmb3JlJyAmJiBmcm9tRGF0ZSkge1xuICAgICAgICBuZXdGb2N1c2VkRGF5ID0gbWF4KFtmcm9tRGF0ZSwgbmV3Rm9jdXNlZERheV0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdhZnRlcicgJiYgdG9EYXRlKSB7XG4gICAgICAgIG5ld0ZvY3VzZWREYXkgPSBtaW4oW3RvRGF0ZSwgbmV3Rm9jdXNlZERheV0pO1xuICAgIH1cbiAgICB2YXIgaXNGb2N1c2FibGUgPSB0cnVlO1xuICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgdmFyIGFjdGl2ZU1vZGlmaWVycyA9IGdldEFjdGl2ZU1vZGlmaWVycyhuZXdGb2N1c2VkRGF5LCBtb2RpZmllcnMpO1xuICAgICAgICBpc0ZvY3VzYWJsZSA9ICFhY3RpdmVNb2RpZmllcnMuZGlzYWJsZWQgJiYgIWFjdGl2ZU1vZGlmaWVycy5oaWRkZW47XG4gICAgfVxuICAgIGlmIChpc0ZvY3VzYWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3Rm9jdXNlZERheTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChyZXRyeS5jb3VudCA+IE1BWF9SRVRSWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5Lmxhc3RGb2N1c2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXROZXh0Rm9jdXMobmV3Rm9jdXNlZERheSwge1xuICAgICAgICAgICAgbW92ZUJ5OiBtb3ZlQnksXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgICAgICAgIHJldHJ5OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmV0cnkpLCB7IGNvdW50OiByZXRyeS5jb3VudCArIDEgfSlcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBGb2N1cyBjb250ZXh0IHNoYXJlcyBkZXRhaWxzIGFib3V0IHRoZSBmb2N1c2VkIGRheSBmb3IgdGhlIGtleWJvYXJkXG4gKlxuICogQWNjZXNzIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlRm9jdXNDb250ZXh0fSBob29rLlxuICovXG52YXIgRm9jdXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqIFRoZSBwcm92aWRlciBmb3IgdGhlIHtAbGluayBGb2N1c0NvbnRleHR9LiAqL1xuZnVuY3Rpb24gRm9jdXNQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICAgIHZhciBtb2RpZmllcnMgPSB1c2VNb2RpZmllcnMoKTtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZSgpLCBmb2N1c2VkRGF5ID0gX2FbMF0sIHNldEZvY3VzZWREYXkgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSB1c2VTdGF0ZSgpLCBsYXN0Rm9jdXNlZCA9IF9iWzBdLCBzZXRMYXN0Rm9jdXNlZCA9IF9iWzFdO1xuICAgIHZhciBpbml0aWFsRm9jdXNUYXJnZXQgPSBnZXRJbml0aWFsRm9jdXNUYXJnZXQobmF2aWdhdGlvbi5kaXNwbGF5TW9udGhzLCBtb2RpZmllcnMpO1xuICAgIC8vIFRPRE86IGNsZWFudXAgYW5kIHRlc3Qgb2JzY3VyZSBjb2RlIGJlbG93XG4gICAgdmFyIGZvY3VzVGFyZ2V0ID0gKGZvY3VzZWREYXkgIT09IG51bGwgJiYgZm9jdXNlZERheSAhPT0gdm9pZCAwID8gZm9jdXNlZERheSA6IChsYXN0Rm9jdXNlZCAmJiBuYXZpZ2F0aW9uLmlzRGF0ZURpc3BsYXllZChsYXN0Rm9jdXNlZCkpKVxuICAgICAgICA/IGxhc3RGb2N1c2VkXG4gICAgICAgIDogaW5pdGlhbEZvY3VzVGFyZ2V0O1xuICAgIHZhciBibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRMYXN0Rm9jdXNlZChmb2N1c2VkRGF5KTtcbiAgICAgICAgc2V0Rm9jdXNlZERheSh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgdmFyIGZvY3VzID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgc2V0Rm9jdXNlZERheShkYXRlKTtcbiAgICB9O1xuICAgIHZhciBjb250ZXh0ID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIG1vdmVGb2N1cyA9IGZ1bmN0aW9uIChtb3ZlQnksIGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoIWZvY3VzZWREYXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBuZXh0Rm9jdXNlZCA9IGdldE5leHRGb2N1cyhmb2N1c2VkRGF5LCB7XG4gICAgICAgICAgICBtb3ZlQnk6IG1vdmVCeSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNTYW1lRGF5KGZvY3VzZWREYXksIG5leHRGb2N1c2VkKSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIG5hdmlnYXRpb24uZ29Ub0RhdGUobmV4dEZvY3VzZWQsIGZvY3VzZWREYXkpO1xuICAgICAgICBmb2N1cyhuZXh0Rm9jdXNlZCk7XG4gICAgfTtcbiAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgIGZvY3VzZWREYXk6IGZvY3VzZWREYXksXG4gICAgICAgIGZvY3VzVGFyZ2V0OiBmb2N1c1RhcmdldCxcbiAgICAgICAgYmx1cjogYmx1cixcbiAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICBmb2N1c0RheUFmdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ2RheScsICdhZnRlcicpOyB9LFxuICAgICAgICBmb2N1c0RheUJlZm9yZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCdkYXknLCAnYmVmb3JlJyk7IH0sXG4gICAgICAgIGZvY3VzV2Vla0FmdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ3dlZWsnLCAnYWZ0ZXInKTsgfSxcbiAgICAgICAgZm9jdXNXZWVrQmVmb3JlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ3dlZWsnLCAnYmVmb3JlJyk7IH0sXG4gICAgICAgIGZvY3VzTW9udGhCZWZvcmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygnbW9udGgnLCAnYmVmb3JlJyk7IH0sXG4gICAgICAgIGZvY3VzTW9udGhBZnRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCdtb250aCcsICdhZnRlcicpOyB9LFxuICAgICAgICBmb2N1c1llYXJCZWZvcmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygneWVhcicsICdiZWZvcmUnKTsgfSxcbiAgICAgICAgZm9jdXNZZWFyQWZ0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygneWVhcicsICdhZnRlcicpOyB9LFxuICAgICAgICBmb2N1c1N0YXJ0T2ZXZWVrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ3N0YXJ0T2ZXZWVrJywgJ2JlZm9yZScpOyB9LFxuICAgICAgICBmb2N1c0VuZE9mV2VlazogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCdlbmRPZldlZWsnLCAnYWZ0ZXInKTsgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRm9jdXNDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiB2YWx1ZSB9LCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSkpO1xufVxuLyoqXG4gKiBIb29rIHRvIGFjY2VzcyB0aGUge0BsaW5rIEZvY3VzQ29udGV4dFZhbHVlfS4gVXNlIHRoaXMgaG9vayB0byBoYW5kbGUgdGhlXG4gKiBmb2N1cyBzdGF0ZSBvZiB0aGUgZWxlbWVudHMuXG4gKlxuICogVGhpcyBob29rIGlzIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiB1c2VGb2N1c0NvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KEZvY3VzQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlRm9jdXNDb250ZXh0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBGb2N1c1Byb3ZpZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYWN0aXZlIG1vZGlmaWVycyBmb3IgdGhlIHNwZWNpZmllZCBkYXkuXG4gKlxuICogVGhpcyBob29rIGlzIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSBkYXlcbiAqIEBwYXJhbSBkaXNwbGF5TW9udGhcbiAqL1xuZnVuY3Rpb24gdXNlQWN0aXZlTW9kaWZpZXJzKGRheSwgXG4vKipcbiAqIFRoZSBtb250aCB3aGVyZSB0aGUgZGF0ZSBpcyBkaXNwbGF5ZWQuIElmIG5vdCB0aGUgc2FtZSBhcyBgZGF0ZWAsIHRoZSBkYXlcbiAqIGlzIGFuIFwib3V0c2lkZSBkYXlcIi5cbiAqL1xuZGlzcGxheU1vbnRoKSB7XG4gICAgdmFyIG1vZGlmaWVycyA9IHVzZU1vZGlmaWVycygpO1xuICAgIHZhciBhY3RpdmVNb2RpZmllcnMgPSBnZXRBY3RpdmVNb2RpZmllcnMoZGF5LCBtb2RpZmllcnMsIGRpc3BsYXlNb250aCk7XG4gICAgcmV0dXJuIGFjdGl2ZU1vZGlmaWVycztcbn1cblxuLyoqXG4gKiBUaGUgU2VsZWN0U2luZ2xlIGNvbnRleHQgc2hhcmVzIGRldGFpbHMgYWJvdXQgdGhlIHNlbGVjdGVkIGRheXMgd2hlbiBpblxuICogc2luZ2xlIHNlbGVjdGlvbiBtb2RlLlxuICpcbiAqIEFjY2VzcyB0aGlzIGNvbnRleHQgZnJvbSB0aGUge0BsaW5rIHVzZVNlbGVjdFNpbmdsZX0gaG9vay5cbiAqL1xudmFyIFNlbGVjdFNpbmdsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKiogUHJvdmlkZXMgdGhlIHZhbHVlcyBmb3IgdGhlIHtAbGluayBTZWxlY3RTaW5nbGVQcm92aWRlcn0uICovXG5mdW5jdGlvbiBTZWxlY3RTaW5nbGVQcm92aWRlcihwcm9wcykge1xuICAgIGlmICghaXNEYXlQaWNrZXJTaW5nbGUocHJvcHMuaW5pdGlhbFByb3BzKSkge1xuICAgICAgICB2YXIgZW1wdHlDb250ZXh0VmFsdWUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdFNpbmdsZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IGVtcHR5Q29udGV4dFZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdFNpbmdsZVByb3ZpZGVySW50ZXJuYWwsIHsgaW5pdGlhbFByb3BzOiBwcm9wcy5pbml0aWFsUHJvcHMsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSk7XG59XG5mdW5jdGlvbiBTZWxlY3RTaW5nbGVQcm92aWRlckludGVybmFsKF9hKSB7XG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IF9hLmluaXRpYWxQcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgb25EYXlDbGljayA9IGZ1bmN0aW9uIChkYXksIGFjdGl2ZU1vZGlmaWVycywgZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgKF9hID0gaW5pdGlhbFByb3BzLm9uRGF5Q2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGluaXRpYWxQcm9wcywgZGF5LCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgICAgICBpZiAoYWN0aXZlTW9kaWZpZXJzLnNlbGVjdGVkICYmICFpbml0aWFsUHJvcHMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIChfYiA9IGluaXRpYWxQcm9wcy5vblNlbGVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW5pdGlhbFByb3BzLCB1bmRlZmluZWQsIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2MgPSBpbml0aWFsUHJvcHMub25TZWxlY3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGluaXRpYWxQcm9wcywgZGF5LCBkYXksIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgY29udGV4dFZhbHVlID0ge1xuICAgICAgICBzZWxlY3RlZDogaW5pdGlhbFByb3BzLnNlbGVjdGVkLFxuICAgICAgICBvbkRheUNsaWNrOiBvbkRheUNsaWNrXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RTaW5nbGVDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKTtcbn1cbi8qKlxuICogSG9vayB0byBhY2Nlc3MgdGhlIHtAbGluayBTZWxlY3RTaW5nbGVDb250ZXh0VmFsdWV9LlxuICpcbiAqIFRoaXMgaG9vayBpcyBtZWFudCB0byBiZSB1c2VkIGluc2lkZSBpbnRlcm5hbCBvciBjdXN0b20gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gdXNlU2VsZWN0U2luZ2xlKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTZWxlY3RTaW5nbGVDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VTZWxlY3RTaW5nbGUgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFNlbGVjdFNpbmdsZVByb3ZpZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGRldGFpbHMgYWJvdXQgdGhlIGNvbnRlbnQgdG8gcmVuZGVyIGluIHRoZSBkYXkgY2VsbC5cbiAqXG4gKlxuICogV2hlbiBhIGRheSBjZWxsIGlzIHJlbmRlcmVkIGluIHRoZSB0YWJsZSwgRGF5UGlja2VyIGNhbiBlaXRoZXI6XG4gKlxuICogLSByZW5kZXIgbm90aGluZzogd2hlbiB0aGUgZGF5IGlzIG91dHNpZGUgdGhlIG1vbnRoIG9yIGhhcyBtYXRjaGVkIHRoZVxuICogICBcImhpZGRlblwiIG1vZGlmaWVyLlxuICogLSByZW5kZXIgYSBidXR0b24gd2hlbiBgb25EYXlDbGlja2Agb3IgYSBzZWxlY3Rpb24gbW9kZSBpcyBzZXQuXG4gKiAtIHJlbmRlciBhIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50OiB3aGVuIG5vIHNlbGVjdGlvbiBtb2RlIGlzIHNldCwgdGhlIGRheVxuICogICBjZWxsIHNob3VsZG7igJl0IHJlc3BvbmQgdG8gYW55IGludGVyYWN0aW9uLiBEYXlQaWNrZXIgc2hvdWxkIHJlbmRlciBhIGBkaXZgXG4gKiAgIG9yIGEgYHNwYW5gLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFVzZSB0aGlzIGhvb2sgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiB0aGUge0BsaW5rIERheX0gY29tcG9uZW50LiBDcmVhdGUgYVxuICogbmV3IGBEYXlgIGNvbXBvbmVudCB1c2luZyB0aGlzIGhvb2sgYW5kIHBhc3MgaXQgdG8gdGhlIGBjb21wb25lbnRzYCBwcm9wLlxuICogVGhlIHNvdXJjZSBvZiB7QGxpbmsgRGF5fSBjYW4gYmUgYSBnb29kIHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRGF5RXZlbnRIYW5kbGVycyhkYXRlLCBhY3RpdmVNb2RpZmllcnMpIHtcbiAgICB2YXIgZGF5UGlja2VyID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIHNpbmdsZSA9IHVzZVNlbGVjdFNpbmdsZSgpO1xuICAgIHZhciBtdWx0aXBsZSA9IHVzZVNlbGVjdE11bHRpcGxlKCk7XG4gICAgdmFyIHJhbmdlID0gdXNlU2VsZWN0UmFuZ2UoKTtcbiAgICB2YXIgX2EgPSB1c2VGb2N1c0NvbnRleHQoKSwgZm9jdXNEYXlBZnRlciA9IF9hLmZvY3VzRGF5QWZ0ZXIsIGZvY3VzRGF5QmVmb3JlID0gX2EuZm9jdXNEYXlCZWZvcmUsIGZvY3VzV2Vla0FmdGVyID0gX2EuZm9jdXNXZWVrQWZ0ZXIsIGZvY3VzV2Vla0JlZm9yZSA9IF9hLmZvY3VzV2Vla0JlZm9yZSwgYmx1ciA9IF9hLmJsdXIsIGZvY3VzID0gX2EuZm9jdXMsIGZvY3VzTW9udGhCZWZvcmUgPSBfYS5mb2N1c01vbnRoQmVmb3JlLCBmb2N1c01vbnRoQWZ0ZXIgPSBfYS5mb2N1c01vbnRoQWZ0ZXIsIGZvY3VzWWVhckJlZm9yZSA9IF9hLmZvY3VzWWVhckJlZm9yZSwgZm9jdXNZZWFyQWZ0ZXIgPSBfYS5mb2N1c1llYXJBZnRlciwgZm9jdXNTdGFydE9mV2VlayA9IF9hLmZvY3VzU3RhcnRPZldlZWssIGZvY3VzRW5kT2ZXZWVrID0gX2EuZm9jdXNFbmRPZldlZWs7XG4gICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpc0RheVBpY2tlclNpbmdsZShkYXlQaWNrZXIpKSB7XG4gICAgICAgICAgICAoX2EgPSBzaW5nbGUub25EYXlDbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc2luZ2xlLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF5UGlja2VyTXVsdGlwbGUoZGF5UGlja2VyKSkge1xuICAgICAgICAgICAgKF9iID0gbXVsdGlwbGUub25EYXlDbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwobXVsdGlwbGUsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXlQaWNrZXJSYW5nZShkYXlQaWNrZXIpKSB7XG4gICAgICAgICAgICAoX2MgPSByYW5nZS5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChyYW5nZSwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfZCA9IGRheVBpY2tlci5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbkZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb2N1cyhkYXRlKTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5Rm9jdXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGJsdXIoKTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5Qmx1cikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uTW91c2VFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5TW91c2VFbnRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5TW91c2VMZWF2ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uUG9pbnRlckVudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlQb2ludGVyRW50ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvblBvaW50ZXJMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5UG9pbnRlckxlYXZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25Ub3VjaENhbmNlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5VG91Y2hDYW5jZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvblRvdWNoRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlUb3VjaEVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlUb3VjaE1vdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGRheVBpY2tlci5vbkRheVRvdWNoU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlLZXlVcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBkYXlQaWNrZXIuZGlyID09PSAncnRsJyA/IGZvY3VzRGF5QWZ0ZXIoKSA6IGZvY3VzRGF5QmVmb3JlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBkYXlQaWNrZXIuZGlyID09PSAncnRsJyA/IGZvY3VzRGF5QmVmb3JlKCkgOiBmb2N1c0RheUFmdGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvY3VzV2Vla0FmdGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBmb2N1c1dlZWtCZWZvcmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5zaGlmdEtleSA/IGZvY3VzWWVhckJlZm9yZSgpIDogZm9jdXNNb250aEJlZm9yZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUGFnZURvd24nOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUuc2hpZnRLZXkgPyBmb2N1c1llYXJBZnRlcigpIDogZm9jdXNNb250aEFmdGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBmb2N1c1N0YXJ0T2ZXZWVrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvY3VzRW5kT2ZXZWVrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5S2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgICAgIG9uQmx1cjogb25CbHVyLFxuICAgICAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICAgICAgb25LZXlVcDogb25LZXlVcCxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogb25Qb2ludGVyRW50ZXIsXG4gICAgICAgIG9uUG9pbnRlckxlYXZlOiBvblBvaW50ZXJMZWF2ZSxcbiAgICAgICAgb25Ub3VjaENhbmNlbDogb25Ub3VjaENhbmNlbCxcbiAgICAgICAgb25Ub3VjaEVuZDogb25Ub3VjaEVuZCxcbiAgICAgICAgb25Ub3VjaE1vdmU6IG9uVG91Y2hNb3ZlLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFxuICAgIH07XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcnM7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjdXJyZW50IHNlbGVjdGVkIGRheXMgd2hlbiBEYXlQaWNrZXIgaXMgaW4gc2VsZWN0aW9uIG1vZGUuIERheXNcbiAqIHNlbGVjdGVkIGJ5IHRoZSBjdXN0b20gc2VsZWN0aW9uIG1vZGUgYXJlIG5vdCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VTZWxlY3RlZERheXMoKSB7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBzaW5nbGUgPSB1c2VTZWxlY3RTaW5nbGUoKTtcbiAgICB2YXIgbXVsdGlwbGUgPSB1c2VTZWxlY3RNdWx0aXBsZSgpO1xuICAgIHZhciByYW5nZSA9IHVzZVNlbGVjdFJhbmdlKCk7XG4gICAgdmFyIHNlbGVjdGVkRGF5cyA9IGlzRGF5UGlja2VyU2luZ2xlKGRheVBpY2tlcilcbiAgICAgICAgPyBzaW5nbGUuc2VsZWN0ZWRcbiAgICAgICAgOiBpc0RheVBpY2tlck11bHRpcGxlKGRheVBpY2tlcilcbiAgICAgICAgICAgID8gbXVsdGlwbGUuc2VsZWN0ZWRcbiAgICAgICAgICAgIDogaXNEYXlQaWNrZXJSYW5nZShkYXlQaWNrZXIpXG4gICAgICAgICAgICAgICAgPyByYW5nZS5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxlY3RlZERheXM7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxNb2RpZmllcihtb2RpZmllcikge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKEludGVybmFsTW9kaWZpZXIpLmluY2x1ZGVzKG1vZGlmaWVyKTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBjbGFzcyBuYW1lcyBmb3IgdGhlIERheSBlbGVtZW50LCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGFjdGl2ZVxuICogbW9kaWZpZXJzLlxuICpcbiAqIEN1c3RvbSBjbGFzcyBuYW1lcyBhcmUgc2V0IHZpYSBgbW9kaWZpZXJzQ2xhc3NOYW1lc2Agb3IgYGNsYXNzTmFtZXNgLFxuICogd2hlcmUgdGhlIGZpcnN0IGhhdmUgdGhlIHByZWNlZGVuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMoZGF5UGlja2VyLCBhY3RpdmVNb2RpZmllcnMpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtkYXlQaWNrZXIuY2xhc3NOYW1lcy5kYXldO1xuICAgIE9iamVjdC5rZXlzKGFjdGl2ZU1vZGlmaWVycykuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgdmFyIGN1c3RvbUNsYXNzTmFtZSA9IGRheVBpY2tlci5tb2RpZmllcnNDbGFzc05hbWVzW21vZGlmaWVyXTtcbiAgICAgICAgaWYgKGN1c3RvbUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGN1c3RvbUNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbnRlcm5hbE1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgdmFyIGludGVybmFsQ2xhc3NOYW1lID0gZGF5UGlja2VyLmNsYXNzTmFtZXNbXCJkYXlfXCIuY29uY2F0KG1vZGlmaWVyKV07XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goaW50ZXJuYWxDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbi8qKiBSZXR1cm4gdGhlIHN0eWxlIGZvciB0aGUgRGF5IGVsZW1lbnQsIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYWN0aXZlIG1vZGlmaWVycy4gKi9cbmZ1bmN0aW9uIGdldERheVN0eWxlKGRheVBpY2tlciwgYWN0aXZlTW9kaWZpZXJzKSB7XG4gICAgdmFyIHN0eWxlID0gX19hc3NpZ24oe30sIGRheVBpY2tlci5zdHlsZXMuZGF5KTtcbiAgICBPYmplY3Qua2V5cyhhY3RpdmVNb2RpZmllcnMpLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGUpLCAoX2EgPSBkYXlQaWNrZXIubW9kaWZpZXJzU3R5bGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbbW9kaWZpZXJdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogUmV0dXJuIHByb3BzIGFuZCBkYXRhIHVzZWQgdG8gcmVuZGVyIHRoZSB7QGxpbmsgRGF5fSBjb21wb25lbnQuXG4gKlxuICogVXNlIHRoaXMgaG9vayB3aGVuIGNyZWF0aW5nIGEgY29tcG9uZW50IHRvIHJlcGxhY2UgdGhlIGJ1aWx0LWluIGBEYXlgXG4gKiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZURheVJlbmRlcihcbi8qKiBUaGUgZGF0ZSB0byByZW5kZXIuICovXG5kYXksIFxuLyoqIFRoZSBtb250aCB3aGVyZSB0aGUgZGF0ZSBpcyBkaXNwbGF5ZWQgKGlmIG5vdCB0aGUgc2FtZSBhcyBgZGF0ZWAsIGl0IG1lYW5zIGl0IGlzIGFuIFwib3V0c2lkZVwiIGRheSkuICovXG5kaXNwbGF5TW9udGgsIFxuLyoqIEEgcmVmIHRvIHRoZSBidXR0b24gZWxlbWVudCB0aGF0IHdpbGwgYmUgdGFyZ2V0IG9mIGZvY3VzIHdoZW4gcmVuZGVyZWQgKGlmIHJlcXVpcmVkKS4gKi9cbmJ1dHRvblJlZikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciBkYXlQaWNrZXIgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgZm9jdXNDb250ZXh0ID0gdXNlRm9jdXNDb250ZXh0KCk7XG4gICAgdmFyIGFjdGl2ZU1vZGlmaWVycyA9IHVzZUFjdGl2ZU1vZGlmaWVycyhkYXksIGRpc3BsYXlNb250aCk7XG4gICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB1c2VEYXlFdmVudEhhbmRsZXJzKGRheSwgYWN0aXZlTW9kaWZpZXJzKTtcbiAgICB2YXIgc2VsZWN0ZWREYXlzID0gdXNlU2VsZWN0ZWREYXlzKCk7XG4gICAgdmFyIGlzQnV0dG9uID0gQm9vbGVhbihkYXlQaWNrZXIub25EYXlDbGljayB8fCBkYXlQaWNrZXIubW9kZSAhPT0gJ2RlZmF1bHQnKTtcbiAgICAvLyBGb2N1cyB0aGUgYnV0dG9uIGlmIHRoZSBkYXkgaXMgZm9jdXNlZCBhY2NvcmRpbmcgdG8gdGhlIGZvY3VzIGNvbnRleHRcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChhY3RpdmVNb2RpZmllcnMub3V0c2lkZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFmb2N1c0NvbnRleHQuZm9jdXNlZERheSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFpc0J1dHRvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlzU2FtZURheShmb2N1c0NvbnRleHQuZm9jdXNlZERheSwgZGF5KSkge1xuICAgICAgICAgICAgKF9hID0gYnV0dG9uUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBmb2N1c0NvbnRleHQuZm9jdXNlZERheSxcbiAgICAgICAgZGF5LFxuICAgICAgICBidXR0b25SZWYsXG4gICAgICAgIGlzQnV0dG9uLFxuICAgICAgICBhY3RpdmVNb2RpZmllcnMub3V0c2lkZVxuICAgIF0pO1xuICAgIHZhciBjbGFzc05hbWUgPSBnZXREYXlDbGFzc05hbWVzKGRheVBpY2tlciwgYWN0aXZlTW9kaWZpZXJzKS5qb2luKCcgJyk7XG4gICAgdmFyIHN0eWxlID0gZ2V0RGF5U3R5bGUoZGF5UGlja2VyLCBhY3RpdmVNb2RpZmllcnMpO1xuICAgIHZhciBpc0hpZGRlbiA9IEJvb2xlYW4oKGFjdGl2ZU1vZGlmaWVycy5vdXRzaWRlICYmICFkYXlQaWNrZXIuc2hvd091dHNpZGVEYXlzKSB8fFxuICAgICAgICBhY3RpdmVNb2RpZmllcnMuaGlkZGVuKTtcbiAgICB2YXIgRGF5Q29udGVudENvbXBvbmVudCA9IChfYyA9IChfYiA9IGRheVBpY2tlci5jb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuRGF5Q29udGVudCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogRGF5Q29udGVudDtcbiAgICB2YXIgY2hpbGRyZW4gPSAoanN4UnVudGltZUV4cG9ydHMuanN4KERheUNvbnRlbnRDb21wb25lbnQsIHsgZGF0ZTogZGF5LCBkaXNwbGF5TW9udGg6IGRpc3BsYXlNb250aCwgYWN0aXZlTW9kaWZpZXJzOiBhY3RpdmVNb2RpZmllcnMgfSkpO1xuICAgIHZhciBkaXZQcm9wcyA9IHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICByb2xlOiAnZ3JpZGNlbGwnXG4gICAgfTtcbiAgICB2YXIgaXNGb2N1c1RhcmdldCA9IGZvY3VzQ29udGV4dC5mb2N1c1RhcmdldCAmJlxuICAgICAgICBpc1NhbWVEYXkoZm9jdXNDb250ZXh0LmZvY3VzVGFyZ2V0LCBkYXkpICYmXG4gICAgICAgICFhY3RpdmVNb2RpZmllcnMub3V0c2lkZTtcbiAgICB2YXIgaXNGb2N1c2VkID0gZm9jdXNDb250ZXh0LmZvY3VzZWREYXkgJiYgaXNTYW1lRGF5KGZvY3VzQ29udGV4dC5mb2N1c2VkRGF5LCBkYXkpO1xuICAgIHZhciBidXR0b25Qcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkaXZQcm9wcyksIChfYSA9IHsgZGlzYWJsZWQ6IGFjdGl2ZU1vZGlmaWVycy5kaXNhYmxlZCwgcm9sZTogJ2dyaWRjZWxsJyB9LCBfYVsnYXJpYS1zZWxlY3RlZCddID0gYWN0aXZlTW9kaWZpZXJzLnNlbGVjdGVkLCBfYS50YWJJbmRleCA9IGlzRm9jdXNlZCB8fCBpc0ZvY3VzVGFyZ2V0ID8gMCA6IC0xLCBfYSkpLCBldmVudEhhbmRsZXJzKTtcbiAgICB2YXIgZGF5UmVuZGVyID0ge1xuICAgICAgICBpc0J1dHRvbjogaXNCdXR0b24sXG4gICAgICAgIGlzSGlkZGVuOiBpc0hpZGRlbixcbiAgICAgICAgYWN0aXZlTW9kaWZpZXJzOiBhY3RpdmVNb2RpZmllcnMsXG4gICAgICAgIHNlbGVjdGVkRGF5czogc2VsZWN0ZWREYXlzLFxuICAgICAgICBidXR0b25Qcm9wczogYnV0dG9uUHJvcHMsXG4gICAgICAgIGRpdlByb3BzOiBkaXZQcm9wc1xuICAgIH07XG4gICAgcmV0dXJuIGRheVJlbmRlcjtcbn1cblxuLyoqXG4gKiBUaGUgY29udGVudCBvZiBhIGRheSBjZWxsIOKAkyBhcyBhIGJ1dHRvbiBvciBzcGFuIGVsZW1lbnQgYWNjb3JkaW5nIHRvIGl0c1xuICogbW9kaWZpZXJzLlxuICovXG5mdW5jdGlvbiBEYXkocHJvcHMpIHtcbiAgICB2YXIgYnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciBkYXlSZW5kZXIgPSB1c2VEYXlSZW5kZXIocHJvcHMuZGF0ZSwgcHJvcHMuZGlzcGxheU1vbnRoLCBidXR0b25SZWYpO1xuICAgIGlmIChkYXlSZW5kZXIuaXNIaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImRpdlwiLCB7IHJvbGU6IFwiZ3JpZGNlbGxcIiB9KTtcbiAgICB9XG4gICAgaWYgKCFkYXlSZW5kZXIuaXNCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZGF5UmVuZGVyLmRpdlByb3BzKSk7XG4gICAgfVxuICAgIHJldHVybiBqc3hSdW50aW1lRXhwb3J0cy5qc3goQnV0dG9uLCBfX2Fzc2lnbih7IG5hbWU6IFwiZGF5XCIsIHJlZjogYnV0dG9uUmVmIH0sIGRheVJlbmRlci5idXR0b25Qcm9wcykpO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgd2VlayBudW1iZXIgZWxlbWVudC4gSWYgYG9uV2Vla051bWJlckNsaWNrYCBpcyBwYXNzZWQgdG8gRGF5UGlja2VyLCBpdFxuICogcmVuZGVycyBhIGJ1dHRvbiwgb3RoZXJ3aXNlIGEgc3BhbiBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBXZWVrTnVtYmVyKHByb3BzKSB7XG4gICAgdmFyIHdlZWtOdW1iZXIgPSBwcm9wcy5udW1iZXIsIGRhdGVzID0gcHJvcHMuZGF0ZXM7XG4gICAgdmFyIF9hID0gdXNlRGF5UGlja2VyKCksIG9uV2Vla051bWJlckNsaWNrID0gX2Eub25XZWVrTnVtYmVyQ2xpY2ssIHN0eWxlcyA9IF9hLnN0eWxlcywgY2xhc3NOYW1lcyA9IF9hLmNsYXNzTmFtZXMsIGxvY2FsZSA9IF9hLmxvY2FsZSwgbGFiZWxXZWVrTnVtYmVyID0gX2EubGFiZWxzLmxhYmVsV2Vla051bWJlciwgZm9ybWF0V2Vla051bWJlciA9IF9hLmZvcm1hdHRlcnMuZm9ybWF0V2Vla051bWJlcjtcbiAgICB2YXIgY29udGVudCA9IGZvcm1hdFdlZWtOdW1iZXIoTnVtYmVyKHdlZWtOdW1iZXIpLCB7IGxvY2FsZTogbG9jYWxlIH0pO1xuICAgIGlmICghb25XZWVrTnVtYmVyQ2xpY2spIHtcbiAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzcGFuXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLndlZWtudW1iZXIsIHN0eWxlOiBzdHlsZXMud2Vla251bWJlciB9LCB7IGNoaWxkcmVuOiBjb250ZW50IH0pKSk7XG4gICAgfVxuICAgIHZhciBsYWJlbCA9IGxhYmVsV2Vla051bWJlcihOdW1iZXIod2Vla051bWJlciksIHsgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgb25XZWVrTnVtYmVyQ2xpY2sod2Vla051bWJlciwgZGF0ZXMsIGUpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goQnV0dG9uLCBfX2Fzc2lnbih7IG5hbWU6IFwid2Vlay1udW1iZXJcIiwgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMud2Vla251bWJlciwgc3R5bGU6IHN0eWxlcy53ZWVrbnVtYmVyLCBvbkNsaWNrOiBoYW5kbGVDbGljayB9LCB7IGNoaWxkcmVuOiBjb250ZW50IH0pKSk7XG59XG5cbi8qKiBSZW5kZXIgYSByb3cgaW4gdGhlIGNhbGVuZGFyLCB3aXRoIHRoZSBkYXlzIGFuZCB0aGUgd2VlayBudW1iZXIuICovXG5mdW5jdGlvbiBSb3cocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBfYyA9IHVzZURheVBpY2tlcigpLCBzdHlsZXMgPSBfYy5zdHlsZXMsIGNsYXNzTmFtZXMgPSBfYy5jbGFzc05hbWVzLCBzaG93V2Vla051bWJlciA9IF9jLnNob3dXZWVrTnVtYmVyLCBjb21wb25lbnRzID0gX2MuY29tcG9uZW50cztcbiAgICB2YXIgRGF5Q29tcG9uZW50ID0gKF9hID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkRheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF5O1xuICAgIHZhciBXZWVrbnVtYmVyQ29tcG9uZW50ID0gKF9iID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLldlZWtOdW1iZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFdlZWtOdW1iZXI7XG4gICAgdmFyIHdlZWtOdW1iZXJDZWxsO1xuICAgIGlmIChzaG93V2Vla051bWJlcikge1xuICAgICAgICB3ZWVrTnVtYmVyQ2VsbCA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJ0ZFwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jZWxsLCBzdHlsZTogc3R5bGVzLmNlbGwgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFdlZWtudW1iZXJDb21wb25lbnQsIHsgbnVtYmVyOiBwcm9wcy53ZWVrTnVtYmVyLCBkYXRlczogcHJvcHMuZGF0ZXMgfSkgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwidHJcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMucm93LCBzdHlsZTogc3R5bGVzLnJvdyB9LCB7IGNoaWxkcmVuOiBbd2Vla051bWJlckNlbGwsIHByb3BzLmRhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInRkXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNlbGwsIHN0eWxlOiBzdHlsZXMuY2VsbCwgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goRGF5Q29tcG9uZW50LCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBkYXRlOiBkYXRlIH0pIH0pLCBnZXRVbml4VGltZShkYXRlKSkpOyB9KV0gfSkpKTtcbn1cblxuLyoqIFJldHVybiB0aGUgd2Vla3MgYmV0d2VlbiB0d28gZGF0ZXMuICAqL1xuZnVuY3Rpb24gZGF5c1RvTW9udGhXZWVrcyhmcm9tRGF0ZSwgdG9EYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIHRvV2VlayA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuSVNPV2VlaylcbiAgICAgICAgPyBlbmRPZklTT1dlZWsodG9EYXRlKVxuICAgICAgICA6IGVuZE9mV2Vlayh0b0RhdGUsIG9wdGlvbnMpO1xuICAgIHZhciBmcm9tV2VlayA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuSVNPV2VlaylcbiAgICAgICAgPyBzdGFydE9mSVNPV2Vlayhmcm9tRGF0ZSlcbiAgICAgICAgOiBzdGFydE9mV2Vlayhmcm9tRGF0ZSwgb3B0aW9ucyk7XG4gICAgdmFyIG5PZkRheXMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXModG9XZWVrLCBmcm9tV2Vlayk7XG4gICAgdmFyIGRheXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuT2ZEYXlzOyBpKyspIHtcbiAgICAgICAgZGF5cy5wdXNoKGFkZERheXMoZnJvbVdlZWssIGkpKTtcbiAgICB9XG4gICAgdmFyIHdlZWtzSW5Nb250aCA9IGRheXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGRhdGUpIHtcbiAgICAgICAgdmFyIHdlZWtOdW1iZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLklTT1dlZWspXG4gICAgICAgICAgICA/IGdldElTT1dlZWsoZGF0ZSlcbiAgICAgICAgICAgIDogZ2V0V2VlayhkYXRlLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nV2VlayA9IHJlc3VsdC5maW5kKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUud2Vla051bWJlciA9PT0gd2Vla051bWJlcjsgfSk7XG4gICAgICAgIGlmIChleGlzdGluZ1dlZWspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nV2Vlay5kYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB3ZWVrTnVtYmVyOiB3ZWVrTnVtYmVyLFxuICAgICAgICAgICAgZGF0ZXM6IFtkYXRlXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHdlZWtzSW5Nb250aDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdlZWtzIGJlbG9uZ2luZyB0byB0aGUgZ2l2ZW4gbW9udGgsIGFkZGluZyB0aGUgXCJvdXRzaWRlIGRheXNcIiB0b1xuICogdGhlIGZpcnN0IGFuZCBsYXN0IHdlZWsuXG4gKi9cbmZ1bmN0aW9uIGdldE1vbnRoV2Vla3MobW9udGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2Vla3NJbk1vbnRoID0gZGF5c1RvTW9udGhXZWVrcyhzdGFydE9mTW9udGgobW9udGgpLCBlbmRPZk1vbnRoKG1vbnRoKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51c2VGaXhlZFdlZWtzKSB7XG4gICAgICAgIC8vIEFkZCBleHRyYSB3ZWVrcyB0byB0aGUgbW9udGgsIHVwIHRvIDYgd2Vla3NcbiAgICAgICAgdmFyIG5yT2ZNb250aFdlZWtzID0gZ2V0V2Vla3NJbk1vbnRoKG1vbnRoLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG5yT2ZNb250aFdlZWtzIDwgNikge1xuICAgICAgICAgICAgdmFyIGxhc3RXZWVrID0gd2Vla3NJbk1vbnRoW3dlZWtzSW5Nb250aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBsYXN0RGF0ZSA9IGxhc3RXZWVrLmRhdGVzW2xhc3RXZWVrLmRhdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHRvRGF0ZSA9IGFkZFdlZWtzKGxhc3REYXRlLCA2IC0gbnJPZk1vbnRoV2Vla3MpO1xuICAgICAgICAgICAgdmFyIGV4dHJhV2Vla3MgPSBkYXlzVG9Nb250aFdlZWtzKGFkZFdlZWtzKGxhc3REYXRlLCAxKSwgdG9EYXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdlZWtzSW5Nb250aC5wdXNoLmFwcGx5KHdlZWtzSW5Nb250aCwgZXh0cmFXZWVrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdlZWtzSW5Nb250aDtcbn1cblxuLyoqIFJlbmRlciB0aGUgdGFibGUgd2l0aCB0aGUgY2FsZW5kYXIuICovXG5mdW5jdGlvbiBUYWJsZShwcm9wcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHZhciBfZCA9IHVzZURheVBpY2tlcigpLCBsb2NhbGUgPSBfZC5sb2NhbGUsIGNsYXNzTmFtZXMgPSBfZC5jbGFzc05hbWVzLCBzdHlsZXMgPSBfZC5zdHlsZXMsIGhpZGVIZWFkID0gX2QuaGlkZUhlYWQsIGZpeGVkV2Vla3MgPSBfZC5maXhlZFdlZWtzLCBjb21wb25lbnRzID0gX2QuY29tcG9uZW50cywgd2Vla1N0YXJ0c09uID0gX2Qud2Vla1N0YXJ0c09uLCBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBfZC5maXJzdFdlZWtDb250YWluc0RhdGUsIElTT1dlZWsgPSBfZC5JU09XZWVrO1xuICAgIHZhciB3ZWVrcyA9IGdldE1vbnRoV2Vla3MocHJvcHMuZGlzcGxheU1vbnRoLCB7XG4gICAgICAgIHVzZUZpeGVkV2Vla3M6IEJvb2xlYW4oZml4ZWRXZWVrcyksXG4gICAgICAgIElTT1dlZWs6IElTT1dlZWssXG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcbiAgICAgICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiBmaXJzdFdlZWtDb250YWluc0RhdGVcbiAgICB9KTtcbiAgICB2YXIgSGVhZENvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5IZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBIZWFkO1xuICAgIHZhciBSb3dDb21wb25lbnQgPSAoX2IgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuUm93KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBSb3c7XG4gICAgdmFyIEZvb3RlckNvbXBvbmVudCA9IChfYyA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5Gb290ZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IEZvb3RlcjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJ0YWJsZVwiLCBfX2Fzc2lnbih7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRhYmxlLCBzdHlsZTogc3R5bGVzLnRhYmxlLCByb2xlOiBcImdyaWRcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHNbJ2FyaWEtbGFiZWxsZWRieSddIH0sIHsgY2hpbGRyZW46IFshaGlkZUhlYWQgJiYganN4UnVudGltZUV4cG9ydHMuanN4KEhlYWRDb21wb25lbnQsIHt9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwidGJvZHlcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMudGJvZHksIHN0eWxlOiBzdHlsZXMudGJvZHkgfSwgeyBjaGlsZHJlbjogd2Vla3MubWFwKGZ1bmN0aW9uICh3ZWVrKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFJvd0NvbXBvbmVudCwgeyBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgZGF0ZXM6IHdlZWsuZGF0ZXMsIHdlZWtOdW1iZXI6IHdlZWsud2Vla051bWJlciB9LCB3ZWVrLndlZWtOdW1iZXIpKTsgfSkgfSkpLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goRm9vdGVyQ29tcG9uZW50LCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoIH0pXSB9KSkpO1xufVxuXG4vKlxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxOC1wcmVzZW50LCBSZWFjdCBUcmFpbmluZyBMTENcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG4vKlxuICogV2VsY29tZSB0byBAcmVhY2gvYXV0by1pZCFcbiAqIExldCdzIHNlZSBpZiB3ZSBjYW4gbWFrZSBzZW5zZSBvZiB3aHkgdGhpcyBob29rIGV4aXN0cyBhbmQgaXRzXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTb21lIGJhY2tncm91bmQ6XG4gKiAgIDEuIEFjY2Vzc2liaWxpdHkgQVBJcyByZWx5IGhlYXZpbHkgb24gZWxlbWVudCBJRHNcbiAqICAgMi4gUmVxdWlyaW5nIGRldmVsb3BlcnMgdG8gcHV0IElEcyBvbiBldmVyeSBlbGVtZW50IGluIFJlYWNoIFVJIGlzIGJvdGhcbiAqICAgICAgY3VtYmVyc29tZSBhbmQgZXJyb3ItcHJvbmVcbiAqICAgMy4gV2l0aCBhIGNvbXBvbmVudCBtb2RlbCwgd2UgY2FuIGdlbmVyYXRlIElEcyBmb3IgdGhlbSFcbiAqXG4gKiBTb2x1dGlvbiAxOiBHZW5lcmF0ZSByYW5kb20gSURzLlxuICpcbiAqIFRoaXMgd29ya3MgZ3JlYXQgYXMgbG9uZyBhcyB5b3UgZG9uJ3Qgc2VydmVyIHJlbmRlciB5b3VyIGFwcC4gV2hlbiBSZWFjdCAoaW5cbiAqIHRoZSBjbGllbnQpIHRyaWVzIHRvIHJldXNlIHRoZSBtYXJrdXAgZnJvbSB0aGUgc2VydmVyLCB0aGUgSURzIHdvbid0IG1hdGNoXG4gKiBhbmQgUmVhY3Qgd2lsbCB0aGVuIHJlY3JlYXRlIHRoZSBlbnRpcmUgRE9NIHRyZWUuXG4gKlxuICogU29sdXRpb24gMjogSW5jcmVtZW50IGFuIGludGVnZXJcbiAqXG4gKiBUaGlzIHNvdW5kcyBncmVhdC4gU2luY2Ugd2UncmUgcmVuZGVyaW5nIHRoZSBleGFjdCBzYW1lIHRyZWUgb24gdGhlIHNlcnZlclxuICogYW5kIGNsaWVudCwgd2UgY2FuIGluY3JlbWVudCBhIGNvdW50ZXIgYW5kIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0IGJldHdlZW5cbiAqIGNsaWVudCBhbmQgc2VydmVyLiBBbHNvLCBKUyBpbnRlZ2VycyBjYW4gZ28gdXAgdG8gbmluZS1xdWFkcmlsbGlvbi4gSSdtXG4gKiBwcmV0dHkgc3VyZSB0aGUgdGFiIHdpbGwgYmUgY2xvc2VkIGJlZm9yZSBhbiBhcHAgbmV2ZXIgbmVlZHNcbiAqIDEwIHF1YWRyaWxsaW9uIElEcyFcbiAqXG4gKiBQcm9ibGVtIHNvbHZlZCwgcmlnaHQ/XG4gKlxuICogQWgsIGJ1dCB0aGVyZSdzIGEgY2F0Y2ghIFJlYWN0J3MgY29uY3VycmVudCByZW5kZXJpbmcgbWFrZXMgdGhpcyBhcHByb2FjaFxuICogbm9uLWRldGVybWluaXN0aWMuIFdoaWxlIHRoZSBjbGllbnQgYW5kIHNlcnZlciB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lXG4gKiBlbGVtZW50cyBpbiB0aGUgZW5kLCBkZXBlbmRpbmcgb24gc3VzcGVuc2UgYm91bmRhcmllcyAoYW5kIHBvc3NpYmx5IHNvbWUgdXNlclxuICogaW5wdXQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlcikgdGhlIGluY3JlbWVudGluZyBpbnRlZ2VycyB3b24ndCBhbHdheXMgbWF0Y2hcbiAqIHVwLlxuICpcbiAqIFNvbHV0aW9uIDM6IERvbid0IHVzZSBJRHMgYXQgYWxsIG9uIHRoZSBzZXJ2ZXI7IHBhdGNoIGFmdGVyIGZpcnN0IHJlbmRlci5cbiAqXG4gKiBXaGF0IHdlJ3ZlIGRvbmUgaGVyZSBpcyBzb2x1dGlvbiAyIHdpdGggc29tZSB0cmlja3MuIFdpdGggdGhpcyBhcHByb2FjaCwgdGhlXG4gKiBJRCByZXR1cm5lZCBpcyBhbiBlbXB0eSBzdHJpbmcgb24gdGhlIGZpcnN0IHJlbmRlci4gVGhpcyB3YXkgdGhlIHNlcnZlciBhbmRcbiAqIGNsaWVudCBoYXZlIHRoZSBzYW1lIG1hcmt1cCBubyBtYXR0ZXIgaG93IHdpbGQgdGhlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIG1heVxuICogaGF2ZSBnb3R0ZW4uXG4gKlxuICogQWZ0ZXIgdGhlIHJlbmRlciwgd2UgcGF0Y2ggdXAgdGhlIGNvbXBvbmVudHMgd2l0aCBhbiBpbmNyZW1lbnRlZCBJRC4gVGhpc1xuICogY2F1c2VzIGEgZG91YmxlIHJlbmRlciBvbiBhbnkgY29tcG9uZW50cyB3aXRoIGB1c2VJZGAuIFNob3VsZG4ndCBiZSBhIHByb2JsZW1cbiAqIHNpbmNlIHRoZSBjb21wb25lbnRzIHVzaW5nIHRoaXMgaG9vayBzaG91bGQgYmUgc21hbGwsIGFuZCB3ZSdyZSBvbmx5IHVwZGF0aW5nXG4gKiB0aGUgSUQgYXR0cmlidXRlIG9uIHRoZSBET00sIG5vdGhpbmcgYmlnIGlzIGhhcHBlbmluZy5cbiAqXG4gKiBJdCBkb2Vzbid0IGhhdmUgdG8gYmUgYW4gaW5jcmVtZW50ZWQgbnVtYmVyLCB0aG91Z2gtLXdlIGNvdWxkIGRvIGdlbmVyYXRlXG4gKiByYW5kb20gc3RyaW5ncyBpbnN0ZWFkLCBidXQgaW5jcmVtZW50aW5nIGEgbnVtYmVyIGlzIHByb2JhYmx5IHRoZSBjaGVhcGVzdFxuICogdGhpbmcgd2UgY2FuIGRvLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgd2Ugb25seSBkbyB0aGlzIHBhdGNodXAgb24gdGhlIHZlcnkgZmlyc3QgY2xpZW50IHJlbmRlciBldmVyLlxuICogQW55IGNhbGxzIHRvIGB1c2VJZGAgdGhhdCBoYXBwZW4gZHluYW1pY2FsbHkgaW4gdGhlIGNsaWVudCB3aWxsIGJlXG4gKiBwb3B1bGF0ZWQgaW1tZWRpYXRlbHkgd2l0aCBhIHZhbHVlLiBTbywgd2Ugb25seSBnZXQgdGhlIGRvdWJsZSByZW5kZXIgYWZ0ZXJcbiAqIHNlcnZlciBoeWRyYXRpb24gYW5kIG5ldmVyIGFnYWluLCBTTyBCQUNLIE9GRiBBTFJJR0hUP1xuICovXG5mdW5jdGlvbiBjYW5Vc2VET00oKSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG59XG4vKipcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuIFRvXG4gKiBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuICogdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBvY2Nhc2lvbmFsbHkgbmVlZCB1c2VMYXlvdXRFZmZlY3QgdG9cbiAqIGVuc3VyZSB3ZSBkb24ndCBnZXQgYSByZW5kZXIgZmxhc2ggZm9yIGNlcnRhaW4gb3BlcmF0aW9ucywgYnV0IHdlIG1heSBhbHNvXG4gKiBuZWVkIGFmZmVjdGVkIGNvbXBvbmVudHMgdG8gcmVuZGVyIG9uIHRoZSBzZXJ2ZXIuIE9uZSBleGFtcGxlIGlzIHdoZW4gc2V0dGluZ1xuICogYSBjb21wb25lbnQncyBkZXNjZW5kYW50cyB0byByZXRyaWV2ZSB0aGVpciBpbmRleCB2YWx1ZXMuXG4gKlxuICogSW1wb3J0YW50IHRvIG5vdGUgdGhhdCB1c2luZyB0aGlzIGhvb2sgYXMgYW4gZXNjYXBlIGhhdGNoIHdpbGwgYnJlYWsgdGhlXG4gKiBlc2xpbnQgZGVwZW5kZW5jeSB3YXJuaW5ncyB1bmxlc3MgeW91IHJlbmFtZSB0aGUgaW1wb3J0IHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuICogVXNlIHNwYXJpbmdseSBvbmx5IHdoZW4gdGhlIGVmZmVjdCB3b24ndCBlZmZlY3QgdGhlIHJlbmRlcmVkIEhUTUwgdG8gYXZvaWRcbiAqIGFueSBzZXJ2ZXIvY2xpZW50IG1pc21hdGNoLlxuICpcbiAqIElmIGEgdXNlTGF5b3V0RWZmZWN0IGlzIG5lZWRlZCBhbmQgdGhlIHJlc3VsdCB3b3VsZCBjcmVhdGUgYSBtaXNtYXRjaCwgaXQnc1xuICogbGlrZWx5IHRoYXQgdGhlIGNvbXBvbmVudCBpbiBxdWVzdGlvbiBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlciBhdFxuICogYWxsLCBzbyBhIGJldHRlciBhcHByb2FjaCB3b3VsZCBiZSB0byBsYXppbHkgcmVuZGVyIHRob3NlIGluIGEgcGFyZW50XG4gKiBjb21wb25lbnQgYWZ0ZXIgY2xpZW50LXNpZGUgaHlkcmF0aW9uLlxuICpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dhZWFyb24vZTdkOTdjZGYzOGEyOTA3OTI0ZWExMmU0ZWJkZjNjODVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlYWN0LXJlZHV4L2Jsb2IvbWFzdGVyL3NyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzXG4gKlxuICogQHBhcmFtIGVmZmVjdFxuICogQHBhcmFtIGRlcHNcbiAqL1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00oKSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbnZhciBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSBmYWxzZTtcbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBnZW5JZCgpIHtcbiAgICByZXR1cm4gXCJyZWFjdC1kYXktcGlja2VyLVwiLmNvbmNhdCgrK2lkKTtcbn1cbmZ1bmN0aW9uIHVzZUlkKHByb3ZpZGVkSWQpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgZXJyb3IgZmxhZyB3aGVuIHVwZGF0aW5nIGludGVybmFsIGRlcHMgdG8gUmVhY3QgMTguIE5vbmUgb2ZcbiAgICAvLyBvdXIgdHJpY2tzIHdpbGwgcGxheSB3ZWxsIHdpdGggY29uY3VycmVudCByZW5kZXJpbmcgYW55d2F5LlxuICAgIHZhciBfYTtcbiAgICAvLyBJZiB0aGlzIGluc3RhbmNlIGlzbid0IHBhcnQgb2YgdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoZVxuICAgIC8vIGRvdWJsZSByZW5kZXIvcGF0Y2gtdXAgZGFuY2UuIFdlIGNhbiBqdXN0IGdlbmVyYXRlIHRoZSBJRCBhbmQgcmV0dXJuIGl0LlxuICAgIHZhciBpbml0aWFsSWQgPSBwcm92aWRlZElkICE9PSBudWxsICYmIHByb3ZpZGVkSWQgIT09IHZvaWQgMCA/IHByb3ZpZGVkSWQgOiAoc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IG51bGwpO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKGluaXRpYWxJZCksIGlkID0gX2JbMF0sIHNldElkID0gX2JbMV07XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUGF0Y2ggdGhlIElEIGFmdGVyIHJlbmRlci4gV2UgZG8gdGhpcyBpbiBgdXNlTGF5b3V0RWZmZWN0YCB0byBhdm9pZCBhbnlcbiAgICAgICAgICAgIC8vIHJlbmRlcmluZyBmbGlja2VyLCB0aG91Z2ggaXQnbGwgbWFrZSB0aGUgZmlyc3QgcmVuZGVyIHNsb3dlciAodW5saWtlbHlcbiAgICAgICAgICAgIC8vIHRvIG1hdHRlciwgYnV0IHlvdSdyZSB3ZWxjb21lIHRvIG1lYXN1cmUgeW91ciBhcHAgYW5kIGxldCB1cyBrbm93IGlmXG4gICAgICAgICAgICAvLyBpdCdzIGEgcHJvYmxlbSkuXG4gICAgICAgICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBGbGFnIGFsbCBmdXR1cmUgdXNlcyBvZiBgdXNlSWRgIHRvIHNraXAgdGhlIHVwZGF0ZSBkYW5jZS4gVGhpcyBpcyBpblxuICAgICAgICAgICAgLy8gYHVzZUVmZmVjdGAgYmVjYXVzZSBpdCBnb2VzIGFmdGVyIGB1c2VMYXlvdXRFZmZlY3RgLCBlbnN1cmluZyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IGJhaWwgb3V0IG9mIHRoZSBwYXRjaC11cCBkYW5jZSBwcmVtYXR1cmVseS5cbiAgICAgICAgICAgIHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChfYSA9IHByb3ZpZGVkSWQgIT09IG51bGwgJiYgcHJvdmlkZWRJZCAhPT0gdm9pZCAwID8gcHJvdmlkZWRJZCA6IGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG59XG5cbi8qKiBSZW5kZXIgYSBtb250aC4gKi9cbmZ1bmN0aW9uIE1vbnRoKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICB2YXIgZGF5UGlja2VyID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIGRpciA9IGRheVBpY2tlci5kaXIsIGNsYXNzTmFtZXMgPSBkYXlQaWNrZXIuY2xhc3NOYW1lcywgc3R5bGVzID0gZGF5UGlja2VyLnN0eWxlcywgY29tcG9uZW50cyA9IGRheVBpY2tlci5jb21wb25lbnRzO1xuICAgIHZhciBkaXNwbGF5TW9udGhzID0gdXNlTmF2aWdhdGlvbigpLmRpc3BsYXlNb250aHM7XG4gICAgdmFyIGNhcHRpb25JZCA9IHVzZUlkKGRheVBpY2tlci5pZCA/IFwiXCIuY29uY2F0KGRheVBpY2tlci5pZCwgXCItXCIpLmNvbmNhdChwcm9wcy5kaXNwbGF5SW5kZXgpIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgdGFibGVJZCA9IGRheVBpY2tlci5pZFxuICAgICAgICA/IFwiXCIuY29uY2F0KGRheVBpY2tlci5pZCwgXCItZ3JpZC1cIikuY29uY2F0KHByb3BzLmRpc3BsYXlJbmRleClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVzLm1vbnRoXTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZXMubW9udGg7XG4gICAgdmFyIGlzU3RhcnQgPSBwcm9wcy5kaXNwbGF5SW5kZXggPT09IDA7XG4gICAgdmFyIGlzRW5kID0gcHJvcHMuZGlzcGxheUluZGV4ID09PSBkaXNwbGF5TW9udGhzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzQ2VudGVyID0gIWlzU3RhcnQgJiYgIWlzRW5kO1xuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICAgIF9hID0gW2lzU3RhcnQsIGlzRW5kXSwgaXNFbmQgPSBfYVswXSwgaXNTdGFydCA9IF9hWzFdO1xuICAgIH1cbiAgICBpZiAoaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWUucHVzaChjbGFzc05hbWVzLmNhcHRpb25fc3RhcnQpO1xuICAgICAgICBzdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZSksIHN0eWxlcy5jYXB0aW9uX3N0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKGNsYXNzTmFtZXMuY2FwdGlvbl9lbmQpO1xuICAgICAgICBzdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZSksIHN0eWxlcy5jYXB0aW9uX2VuZCk7XG4gICAgfVxuICAgIGlmIChpc0NlbnRlcikge1xuICAgICAgICBjbGFzc05hbWUucHVzaChjbGFzc05hbWVzLmNhcHRpb25fYmV0d2Vlbik7XG4gICAgICAgIHN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgc3R5bGVzLmNhcHRpb25fYmV0d2Vlbik7XG4gICAgfVxuICAgIHZhciBDYXB0aW9uQ29tcG9uZW50ID0gKF9iID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkNhcHRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENhcHRpb247XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZTogc3R5bGUgfSwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uQ29tcG9uZW50LCB7IGlkOiBjYXB0aW9uSWQsIGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBkaXNwbGF5SW5kZXg6IHByb3BzLmRpc3BsYXlJbmRleCB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFRhYmxlLCB7IGlkOiB0YWJsZUlkLCBcImFyaWEtbGFiZWxsZWRieVwiOiBjYXB0aW9uSWQsIGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoIH0pXSB9KSwgcHJvcHMuZGlzcGxheUluZGV4KSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSB3cmFwcGVyIGZvciB0aGUgbW9udGggZ3JpZHMuXG4gKi9cbmZ1bmN0aW9uIE1vbnRocyhwcm9wcykge1xuICAgIHZhciBfYSA9IHVzZURheVBpY2tlcigpLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Euc3R5bGVzO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm1vbnRocywgc3R5bGU6IHN0eWxlcy5tb250aHMgfSwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkpKTtcbn1cblxuLyoqIFJlbmRlciB0aGUgY29udGFpbmVyIHdpdGggdGhlIG1vbnRocyBhY2NvcmRpbmcgdG8gdGhlIG51bWJlciBvZiBtb250aHMgdG8gZGlzcGxheS4gKi9cbmZ1bmN0aW9uIFJvb3QoX2EpIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBfYS5pbml0aWFsUHJvcHM7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBmb2N1c0NvbnRleHQgPSB1c2VGb2N1c0NvbnRleHQoKTtcbiAgICB2YXIgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcbiAgICB2YXIgX2QgPSB1c2VTdGF0ZShmYWxzZSksIGhhc0luaXRpYWxGb2N1cyA9IF9kWzBdLCBzZXRIYXNJbml0aWFsRm9jdXMgPSBfZFsxXTtcbiAgICAvLyBGb2N1cyB0aGUgZm9jdXMgdGFyZ2V0IHdoZW4gaW5pdGlhbEZvY3VzIGlzIHBhc3NlZCBpblxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGF5UGlja2VyLmluaXRpYWxGb2N1cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFmb2N1c0NvbnRleHQuZm9jdXNUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChoYXNJbml0aWFsRm9jdXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvY3VzQ29udGV4dC5mb2N1cyhmb2N1c0NvbnRleHQuZm9jdXNUYXJnZXQpO1xuICAgICAgICBzZXRIYXNJbml0aWFsRm9jdXModHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICBkYXlQaWNrZXIuaW5pdGlhbEZvY3VzLFxuICAgICAgICBoYXNJbml0aWFsRm9jdXMsXG4gICAgICAgIGZvY3VzQ29udGV4dC5mb2N1cyxcbiAgICAgICAgZm9jdXNDb250ZXh0LmZvY3VzVGFyZ2V0LFxuICAgICAgICBmb2N1c0NvbnRleHRcbiAgICBdKTtcbiAgICAvLyBBcHBseSBjbGFzc25hbWVzIGFjY29yZGluZyB0byBwcm9wc1xuICAgIHZhciBjbGFzc05hbWVzID0gW2RheVBpY2tlci5jbGFzc05hbWVzLnJvb3QsIGRheVBpY2tlci5jbGFzc05hbWVdO1xuICAgIGlmIChkYXlQaWNrZXIubnVtYmVyT2ZNb250aHMgPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaChkYXlQaWNrZXIuY2xhc3NOYW1lcy5tdWx0aXBsZV9tb250aHMpO1xuICAgIH1cbiAgICBpZiAoZGF5UGlja2VyLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaChkYXlQaWNrZXIuY2xhc3NOYW1lcy53aXRoX3dlZWtudW1iZXIpO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF5UGlja2VyLnN0eWxlcy5yb290KSwgZGF5UGlja2VyLnN0eWxlKTtcbiAgICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbml0aWFsUHJvcHMpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoJ2RhdGEtJyk7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGF0dHJzLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGF0dHJzKSwgKF9hID0ge30sIF9hW2tleV0gPSBpbml0aWFsUHJvcHNba2V5XSwgX2EpKTtcbiAgICB9LCB7fSk7XG4gICAgdmFyIE1vbnRoc0NvbXBvbmVudCA9IChfYyA9IChfYiA9IGluaXRpYWxQcm9wcy5jb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuTW9udGhzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBNb250aHM7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogc3R5bGUsIGRpcjogZGF5UGlja2VyLmRpciwgaWQ6IGRheVBpY2tlci5pZCwgbm9uY2U6IGluaXRpYWxQcm9wcy5ub25jZSwgdGl0bGU6IGluaXRpYWxQcm9wcy50aXRsZSwgbGFuZzogaW5pdGlhbFByb3BzLmxhbmcgfSwgZGF0YUF0dHJpYnV0ZXMsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChNb250aHNDb21wb25lbnQsIHsgY2hpbGRyZW46IG5hdmlnYXRpb24uZGlzcGxheU1vbnRocy5tYXAoZnVuY3Rpb24gKG1vbnRoLCBpKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KE1vbnRoLCB7IGRpc3BsYXlJbmRleDogaSwgZGlzcGxheU1vbnRoOiBtb250aCB9LCBpKSk7IH0pIH0pIH0pKSk7XG59XG5cbi8qKiBQcm92aWRlIHRoZSB2YWx1ZSBmb3IgYWxsIHRoZSBjb250ZXh0IHByb3ZpZGVycy4gKi9cbmZ1bmN0aW9uIFJvb3RQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBpbml0aWFsUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImNoaWxkcmVuXCJdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChEYXlQaWNrZXJQcm92aWRlciwgX19hc3NpZ24oeyBpbml0aWFsUHJvcHM6IGluaXRpYWxQcm9wcyB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goTmF2aWdhdGlvblByb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0U2luZ2xlUHJvdmlkZXIsIF9fYXNzaWduKHsgaW5pdGlhbFByb3BzOiBpbml0aWFsUHJvcHMgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdE11bHRpcGxlUHJvdmlkZXIsIF9fYXNzaWduKHsgaW5pdGlhbFByb3BzOiBpbml0aWFsUHJvcHMgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdFJhbmdlUHJvdmlkZXIsIF9fYXNzaWduKHsgaW5pdGlhbFByb3BzOiBpbml0aWFsUHJvcHMgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KE1vZGlmaWVyc1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goRm9jdXNQcm92aWRlciwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkpIH0pKSB9KSkgfSkgfSkpKTtcbn1cblxuLyoqXG4gKiBEYXlQaWNrZXIgcmVuZGVyIGEgZGF0ZSBwaWNrZXIgY29tcG9uZW50IHRvIGxldCB1c2VycyBwaWNrIGRhdGVzIGZyb20gYVxuICogY2FsZW5kYXIuIFNlZSBodHRwOi8vcmVhY3QtZGF5LXBpY2tlci5qcy5vcmcgZm9yIHVwZGF0ZWQgZG9jdW1lbnRhdGlvbiBhbmRcbiAqIGV4YW1wbGVzLlxuICpcbiAqICMjIyBDdXN0b21pemF0aW9uXG4gKlxuICogRGF5UGlja2VyIG9mZmVycyBkaWZmZXJlbnQgY3VzdG9taXphdGlvbiBwcm9wcy4gRm9yIGV4YW1wbGUsXG4gKlxuICogLSBzaG93IG11bHRpcGxlIG1vbnRocyB1c2luZyBgbnVtYmVyT2ZNb250aHNgXG4gKiAtIGRpc3BsYXkgYSBkcm9wZG93biB0byBuYXZpZ2F0ZSB0aGUgbW9udGhzIHZpYSBgY2FwdGlvbkxheW91dGBcbiAqIC0gZGlzcGxheSB0aGUgd2VlayBudW1iZXJzIHdpdGggYHNob3dXZWVrTnVtYmVyc2BcbiAqIC0gZGlzYWJsZSBvciBoaWRlIGRheXMgd2l0aCBgZGlzYWJsZWRgIG9yIGBoaWRkZW5gXG4gKlxuICogIyMjIENvbnRyb2xsaW5nIHRoZSBtb250aHNcbiAqXG4gKiBDaGFuZ2UgdGhlIGluaXRpYWxseSBkaXNwbGF5ZWQgbW9udGggdXNpbmcgdGhlIGBkZWZhdWx0TW9udGhgIHByb3AuIFRoZVxuICogZGlzcGxheWVkIG1vbnRocyBhcmUgY29udHJvbGxlZCBieSBEYXlQaWNrZXIgYW5kIHN0b3JlZCBpbiBpdHMgaW50ZXJuYWxcbiAqIHN0YXRlLiBUbyBjb250cm9sIHRoZSBtb250aHMgeW91cnNlbGYsIHVzZSBgbW9udGhgIGluc3RlYWQgb2YgYGRlZmF1bHRNb250aGBcbiAqIGFuZCB1c2UgdGhlIGBvbk1vbnRoQ2hhbmdlYCBldmVudCB0byBzZXQgaXQuXG4gKlxuICogVG8gbGltaXQgdGhlIG1vbnRocyB0aGUgdXNlciBjYW4gbmF2aWdhdGUgdG8sIHVzZVxuICogYGZyb21EYXRlYC9gZnJvbU1vbnRoYC9gZnJvbVllYXJgIG9yIGB0b0RhdGVgL2B0b01vbnRoYC9gdG9ZZWFyYC5cbiAqXG4gKiAjIyMgU2VsZWN0aW9uIG1vZGVzXG4gKlxuICogRGF5UGlja2VyIHN1cHBvcnRzIGRpZmZlcmVudCBzZWxlY3Rpb24gbW9kZSB0aGF0IGNhbiBiZSB0b2dnbGVkIHVzaW5nIHRoZVxuICogYG1vZGVgIHByb3A6XG4gKlxuICogLSBgbW9kZT1cInNpbmdsZVwiYDogb25seSBvbmUgZGF5IGNhbiBiZSBzZWxlY3RlZC4gVXNlIGByZXF1aXJlZGAgdG8gbWFrZSB0aGVcbiAqICAgc2VsZWN0aW9uIHJlcXVpcmVkLiBVc2UgdGhlIGBvblNlbGVjdGAgZXZlbnQgaGFuZGxlciB0byBnZXQgdGhlIHNlbGVjdGVkXG4gKiAgIGRheXMuXG4gKiAtIGBtb2RlPVwibXVsdGlwbGVcImA6IHVzZXJzIGNhbiBzZWxlY3Qgb25lIG9yIG1vcmUgZGF5cy4gTGltaXQgdGhlIGFtb3VudCBvZlxuICogICBkYXlzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIHdpdGggdGhlIGBtaW5gIG9yIHRoZSBgbWF4YCBwcm9wcy5cbiAqIC0gYG1vZGU9XCJyYW5nZVwiYDogdXNlcnMgY2FuIHNlbGVjdCBhIHJhbmdlIG9mIGRheXMuIExpbWl0IHRoZSBhbW91bnQgb2YgZGF5c1xuICogICBpbiB0aGUgcmFuZ2Ugd2l0aCB0aGUgYG1pbmAgb3IgdGhlIGBtYXhgIHByb3BzLlxuICogLSBgbW9kZT1cImRlZmF1bHRcImAgKGRlZmF1bHQpOiB0aGUgYnVpbHQtaW4gc2VsZWN0aW9ucyBhcmUgZGlzYWJsZWQuIEltcGxlbWVudFxuICogICB5b3VyIG93biBzZWxlY3Rpb24gbW9kZSB3aXRoIGBvbkRheUNsaWNrYC5cbiAqXG4gKiBUaGUgc2VsZWN0aW9uIG1vZGVzIHNob3VsZCBjb3ZlciB0aGUgbW9zdCBjb21tb24gdXNlIGNhc2VzLiBJbiBjYXNlIHlvdVxuICogbmVlZCBhIG1vcmUgcmVmaW5lZCB3YXkgb2Ygc2VsZWN0aW5nIGRheXMsIHVzZSBgbW9kZT1cImRlZmF1bHRcImAuIFVzZSB0aGVcbiAqIGBzZWxlY3RlZGAgcHJvcHMgYW5kIGFkZCB0aGUgZGF5IGV2ZW50IGhhbmRsZXJzIHRvIGFkZC9yZW1vdmUgZGF5cyBmcm9tIHRoZVxuICogc2VsZWN0aW9uLlxuICpcbiAqICMjIyBNb2RpZmllcnNcbiAqXG4gKiBBIF9tb2RpZmllcl8gcmVwcmVzZW50cyBkaWZmZXJlbnQgc3R5bGVzIG9yIHN0YXRlcyBmb3IgdGhlIGRheXMgZGlzcGxheWVkIGluXG4gKiB0aGUgY2FsZW5kYXIgKGxpa2UgXCJzZWxlY3RlZFwiIG9yIFwiZGlzYWJsZWRcIikuIERlZmluZSBjdXN0b20gbW9kaWZpZXJzIHVzaW5nXG4gKiB0aGUgYG1vZGlmaWVyc2AgcHJvcC5cbiAqXG4gKiAjIyMgRm9ybWF0dGVycyBhbmQgY3VzdG9tIGNvbXBvbmVudFxuICpcbiAqIFlvdSBjYW4gY3VzdG9taXplIGhvdyB0aGUgY29udGVudCBpcyBkaXNwbGF5ZWQgaW4gdGhlIGRhdGUgcGlja2VyIGJ5IHVzaW5nXG4gKiBlaXRoZXIgdGhlIGZvcm1hdHRlcnMgb3IgcmVwbGFjaW5nIHRoZSBpbnRlcm5hbCBjb21wb25lbnRzLlxuICpcbiAqIEZvciB0aGUgbW9zdCBjb21tb24gY2FzZXMgeW91IHdhbnQgdG8gdXNlIHRoZSBgZm9ybWF0dGVyc2AgcHJvcCB0byBjaGFuZ2UgaG93XG4gKiB0aGUgY29udGVudCBpcyBmb3JtYXR0ZWQgaW4gdGhlIGNhbGVuZGFyLiBVc2UgdGhlIGBjb21wb25lbnRzYCBwcm9wIHRvXG4gKiByZXBsYWNlIHRoZSBpbnRlcm5hbCBjb21wb25lbnRzLCBsaWtlIHRoZSBuYXZpZ2F0aW9uIGljb25zLlxuICpcbiAqICMjIyBTdHlsaW5nXG4gKlxuICogRGF5UGlja2VyIGNvbWVzIHdpdGggYSBkZWZhdWx0LCBiYXNpYyBzdHlsZSBpbiBgcmVhY3QtZGF5LXBpY2tlci9zdHlsZWAg4oCTIHVzZVxuICogaXQgYXMgdGVtcGxhdGUgZm9yIHlvdXIgb3duIHN0eWxlLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgQ1NTIG1vZHVsZXMsIHBhc3MgdGhlIGltcG9ydGVkIHN0eWxlcyBvYmplY3QgdGhlXG4gKiBgY2xhc3NOYW1lc2AgcHJvcHMuXG4gKlxuICogWW91IGNhbiBhbHNvIHN0eWxlIHRoZSBlbGVtZW50cyB2aWEgaW5saW5lIHN0eWxlcyB1c2luZyB0aGUgYHN0eWxlc2AgcHJvcC5cbiAqXG4gKiAjIyMgRm9ybSBmaWVsZHNcbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBiaW5kIHRoZSBkYXRlIHBpY2tlciB0byBhIGZvcm0gZmllbGQsIHlvdSBjYW4gdXNlIHRoZVxuICogYHVzZUlucHV0YCBob29rcyBmb3IgYSBiYXNpYyBiZWhhdmlvci4gU2VlIHRoZSBgdXNlSW5wdXRgIHNvdXJjZSBhcyBhblxuICogZXhhbXBsZSB0byBiaW5kIHRoZSBkYXRlIHBpY2tlciB3aXRoIGZvcm0gZmllbGRzLlxuICpcbiAqICMjIyBMb2NhbGl6YXRpb25cbiAqXG4gKiBUbyBsb2NhbGl6ZSBEYXlQaWNrZXIsIGltcG9ydCB0aGUgbG9jYWxlIGZyb20gYGRhdGUtZm5zYCBwYWNrYWdlIGFuZCB1c2UgdGhlXG4gKiBgbG9jYWxlYCBwcm9wLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byB1c2UgU3BhbmlzaCBsb2NhbGU6XG4gKlxuICogYGBgXG4gKiBpbXBvcnQgeyBlcyB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZSc7XG4gKiA8RGF5UGlja2VyIGxvY2FsZT17ZXN9IC8+XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gRGF5UGlja2VyKHByb3BzKSB7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goUm9vdFByb3ZpZGVyLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChSb290LCB7IGluaXRpYWxQcm9wczogcHJvcHMgfSkgfSkpKTtcbn1cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBpc1ZhbGlkRGF0ZShkYXkpIHtcbiAgICByZXR1cm4gIWlzTmFOKGRheS5nZXRUaW1lKCkpO1xufVxuXG4vKiogUmV0dXJuIHByb3BzIGFuZCBzZXR0ZXJzIGZvciBiaW5kaW5nIGFuIGlucHV0IGZpZWxkIHRvIERheVBpY2tlci4gKi9cbmZ1bmN0aW9uIHVzZUlucHV0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMubG9jYWxlLCBsb2NhbGUgPSBfYSA9PT0gdm9pZCAwID8gZW5VUyA6IF9hLCByZXF1aXJlZCA9IG9wdGlvbnMucmVxdWlyZWQsIF9iID0gb3B0aW9ucy5mb3JtYXQsIGZvcm1hdCQxID0gX2IgPT09IHZvaWQgMCA/ICdQUCcgOiBfYiwgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9ucy5kZWZhdWx0U2VsZWN0ZWQsIF9jID0gb3B0aW9ucy50b2RheSwgdG9kYXkgPSBfYyA9PT0gdm9pZCAwID8gbmV3IERhdGUoKSA6IF9jO1xuICAgIHZhciBfZCA9IHBhcnNlRnJvbVRvUHJvcHMob3B0aW9ucyksIGZyb21EYXRlID0gX2QuZnJvbURhdGUsIHRvRGF0ZSA9IF9kLnRvRGF0ZTtcbiAgICAvLyBTaG9ydGN1dCB0byB0aGUgRGF0ZUZucyBmdW5jdGlvbnNcbiAgICB2YXIgcGFyc2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcGFyc2UodmFsdWUsIGZvcm1hdCQxLCB0b2RheSwgeyBsb2NhbGU6IGxvY2FsZSB9KTsgfTtcbiAgICAvLyBJbml0aWFsaXplIHN0YXRlc1xuICAgIHZhciBfZSA9IHVzZVN0YXRlKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCAmJiBkZWZhdWx0U2VsZWN0ZWQgIT09IHZvaWQgMCA/IGRlZmF1bHRTZWxlY3RlZCA6IHRvZGF5KSwgbW9udGggPSBfZVswXSwgc2V0TW9udGggPSBfZVsxXTtcbiAgICB2YXIgX2YgPSB1c2VTdGF0ZShkZWZhdWx0U2VsZWN0ZWQpLCBzZWxlY3RlZERheSA9IF9mWzBdLCBzZXRTZWxlY3RlZERheSA9IF9mWzFdO1xuICAgIHZhciBkZWZhdWx0SW5wdXRWYWx1ZSA9IGRlZmF1bHRTZWxlY3RlZFxuICAgICAgICA/IGZvcm1hdChkZWZhdWx0U2VsZWN0ZWQsIGZvcm1hdCQxLCB7IGxvY2FsZTogbG9jYWxlIH0pXG4gICAgICAgIDogJyc7XG4gICAgdmFyIF9nID0gdXNlU3RhdGUoZGVmYXVsdElucHV0VmFsdWUpLCBpbnB1dFZhbHVlID0gX2dbMF0sIHNldElucHV0VmFsdWUgPSBfZ1sxXTtcbiAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkRGF5KGRlZmF1bHRTZWxlY3RlZCk7XG4gICAgICAgIHNldE1vbnRoKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCAmJiBkZWZhdWx0U2VsZWN0ZWQgIT09IHZvaWQgMCA/IGRlZmF1bHRTZWxlY3RlZCA6IHRvZGF5KTtcbiAgICAgICAgc2V0SW5wdXRWYWx1ZShkZWZhdWx0SW5wdXRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0SW5wdXRWYWx1ZSAhPT0gdm9pZCAwID8gZGVmYXVsdElucHV0VmFsdWUgOiAnJyk7XG4gICAgfTtcbiAgICB2YXIgc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICBzZXRTZWxlY3RlZERheShkYXRlKTtcbiAgICAgICAgc2V0TW9udGgoZGF0ZSAhPT0gbnVsbCAmJiBkYXRlICE9PSB2b2lkIDAgPyBkYXRlIDogdG9kYXkpO1xuICAgICAgICBzZXRJbnB1dFZhbHVlKGRhdGUgPyBmb3JtYXQoZGF0ZSwgZm9ybWF0JDEsIHsgbG9jYWxlOiBsb2NhbGUgfSkgOiAnJyk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBfYSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBfYS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFyZXF1aXJlZCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXkodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHNldElucHV0VmFsdWUoJycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGVkRGF5KGRheSk7XG4gICAgICAgIHNldElucHV0VmFsdWUoZGF5ID8gZm9ybWF0KGRheSwgZm9ybWF0JDEsIHsgbG9jYWxlOiBsb2NhbGUgfSkgOiAnJyk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlTW9udGhDaGFuZ2UgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgc2V0TW9udGgobW9udGgpO1xuICAgIH07XG4gICAgLy8gV2hlbiBjaGFuZ2luZyB0aGUgaW5wdXQgZmllbGQsIHNhdmUgaXRzIHZhbHVlIGluIHN0YXRlIGFuZCBjaGVjayBpZiB0aGVcbiAgICAvLyBzdHJpbmcgaXMgYSB2YWxpZCBkYXRlLiBJZiBpdCBpcyBhIHZhbGlkIGRheSwgc2V0IGl0IGFzIHNlbGVjdGVkIGFuZCB1cGRhdGVcbiAgICAvLyB0aGUgY2FsZW5kYXLigJlzIG1vbnRoLlxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgdmFyIGRheSA9IHBhcnNlVmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICB2YXIgaXNCZWZvcmUgPSBmcm9tRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZnJvbURhdGUsIGRheSkgPiAwO1xuICAgICAgICB2YXIgaXNBZnRlciA9IHRvRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF5LCB0b0RhdGUpID4gMDtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRGF0ZShkYXkpIHx8IGlzQmVmb3JlIHx8IGlzQWZ0ZXIpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkRGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0ZWREYXkoZGF5KTtcbiAgICAgICAgc2V0TW9udGgoZGF5KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgX3JlcXVpcmVkXyBmaWVsZHM6IG9uIGJsdXIsIGlmIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaXMgbm90XG4gICAgLy8gYSB2YWxpZCBkYXRlLCByZXNldCB0aGUgY2FsZW5kYXIgYW5kIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICB2YXIgaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkYXkgPSBwYXJzZVZhbHVlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRGF0ZShkYXkpKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nLCBtYWtlIHN1cmUgRGF5UGlja2VyIHZpc3VhbGl6ZXMgdGhlIG1vbnRoIG9mIHRoZSBkYXRlIGluIHRoZVxuICAgIC8vIGlucHV0IGZpZWxkLlxuICAgIHZhciBoYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHBhcnNlVmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUoZGF5KSkge1xuICAgICAgICAgICAgc2V0TW9udGgoZGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRheVBpY2tlclByb3BzID0ge1xuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIG9uRGF5Q2xpY2s6IGhhbmRsZURheUNsaWNrLFxuICAgICAgICBvbk1vbnRoQ2hhbmdlOiBoYW5kbGVNb250aENoYW5nZSxcbiAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkRGF5LFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgZnJvbURhdGU6IGZyb21EYXRlLFxuICAgICAgICB0b0RhdGU6IHRvRGF0ZSxcbiAgICAgICAgdG9kYXk6IHRvZGF5XG4gICAgfTtcbiAgICB2YXIgaW5wdXRQcm9wcyA9IHtcbiAgICAgICAgb25CbHVyOiBoYW5kbGVCbHVyLFxuICAgICAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgICAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBmb3JtYXQobmV3IERhdGUoKSwgZm9ybWF0JDEsIHsgbG9jYWxlOiBsb2NhbGUgfSlcbiAgICB9O1xuICAgIHJldHVybiB7IGRheVBpY2tlclByb3BzOiBkYXlQaWNrZXJQcm9wcywgaW5wdXRQcm9wczogaW5wdXRQcm9wcywgcmVzZXQ6IHJlc2V0LCBzZXRTZWxlY3RlZDogc2V0U2VsZWN0ZWQgfTtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwcm9wcyBhcmUgb2YgdHlwZSB7QGxpbmsgRGF5UGlja2VyRGVmYXVsdFByb3BzfS4gKi9cbmZ1bmN0aW9uIGlzRGF5UGlja2VyRGVmYXVsdChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5tb2RlID09PSB1bmRlZmluZWQgfHwgcHJvcHMubW9kZSA9PT0gJ2RlZmF1bHQnO1xufVxuXG5leHBvcnQgeyBCdXR0b24sIENhcHRpb24sIENhcHRpb25Ecm9wZG93bnMsIENhcHRpb25MYWJlbCwgQ2FwdGlvbk5hdmlnYXRpb24sIERheSwgRGF5Q29udGVudCwgRGF5UGlja2VyLCBEYXlQaWNrZXJDb250ZXh0LCBEYXlQaWNrZXJQcm92aWRlciwgRHJvcGRvd24sIEZvY3VzQ29udGV4dCwgRm9jdXNQcm92aWRlciwgRm9vdGVyLCBIZWFkLCBIZWFkUm93LCBJY29uRHJvcGRvd24sIEljb25MZWZ0LCBJY29uUmlnaHQsIEludGVybmFsTW9kaWZpZXIsIE1vbnRocywgTmF2aWdhdGlvbkNvbnRleHQsIE5hdmlnYXRpb25Qcm92aWRlciwgUm9vdFByb3ZpZGVyLCBSb3csIFNlbGVjdE11bHRpcGxlQ29udGV4dCwgU2VsZWN0TXVsdGlwbGVQcm92aWRlciwgU2VsZWN0TXVsdGlwbGVQcm92aWRlckludGVybmFsLCBTZWxlY3RSYW5nZUNvbnRleHQsIFNlbGVjdFJhbmdlUHJvdmlkZXIsIFNlbGVjdFJhbmdlUHJvdmlkZXJJbnRlcm5hbCwgU2VsZWN0U2luZ2xlQ29udGV4dCwgU2VsZWN0U2luZ2xlUHJvdmlkZXIsIFNlbGVjdFNpbmdsZVByb3ZpZGVySW50ZXJuYWwsIFdlZWtOdW1iZXIsIGFkZFRvUmFuZ2UsIGlzRGF0ZUFmdGVyVHlwZSwgaXNEYXRlQmVmb3JlVHlwZSwgaXNEYXRlSW50ZXJ2YWwsIGlzRGF0ZVJhbmdlLCBpc0RheU9mV2Vla1R5cGUsIGlzRGF5UGlja2VyRGVmYXVsdCwgaXNEYXlQaWNrZXJNdWx0aXBsZSwgaXNEYXlQaWNrZXJSYW5nZSwgaXNEYXlQaWNrZXJTaW5nbGUsIGlzTWF0Y2gsIHVzZUFjdGl2ZU1vZGlmaWVycywgdXNlRGF5UGlja2VyLCB1c2VEYXlSZW5kZXIsIHVzZUZvY3VzQ29udGV4dCwgdXNlSW5wdXQsIHVzZU5hdmlnYXRpb24sIHVzZVNlbGVjdE11bHRpcGxlLCB1c2VTZWxlY3RSYW5nZSwgdXNlU2VsZWN0U2luZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsicmVxdWlyZSQkMCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlTGF5b3V0RWZmZWN0IiwiZm9ybWF0Iiwic3RhcnRPZk1vbnRoIiwiZW5kT2ZNb250aCIsInN0YXJ0T2ZEYXkiLCJpc1NhbWVZZWFyIiwic2V0TW9udGgiLCJzZXRZZWFyIiwic3RhcnRPZlllYXIiLCJkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyIsImFkZE1vbnRocyIsImlzU2FtZU1vbnRoIiwiaXNCZWZvcmUiLCJzdGFydE9mSVNPV2VlayIsInN0YXJ0T2ZXZWVrIiwiYWRkRGF5cyIsImlzU2FtZURheSIsImlzQWZ0ZXIiLCJzdWJEYXlzIiwiZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIiwiaXNEYXRlIiwibWF4IiwibWluIiwiYWRkV2Vla3MiLCJhZGRZZWFycyIsImVuZE9mSVNPV2VlayIsImVuZE9mV2VlayIsImdldFVuaXhUaW1lIiwiZ2V0SVNPV2VlayIsImdldFdlZWsiLCJnZXRXZWVrc0luTW9udGgiLCJwYXJzZSIsImVuVVMiLCJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwiYXIiLCJBcnJheSIsInNsaWNlIiwiY29uY2F0IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsImpzeFJ1bnRpbWUiLCJleHBvcnRzIiwicmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluIiwiaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4iLCJyZXF1aXJlUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluIiwiZiIsImsiLCJTeW1ib2wiLCJmb3IiLCJtIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJSZWFjdEN1cnJlbnRPd25lciIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwicSIsImMiLCJhIiwiZyIsImIiLCJkIiwiaCIsImRlZmF1bHRQcm9wcyIsIiQkdHlwZW9mIiwidHlwZSIsInByb3BzIiwiX293bmVyIiwiY3VycmVudCIsIkZyYWdtZW50IiwianN4IiwianN4cyIsInJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCIsImhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50IiwicmVxdWlyZVJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCIsInByb2Nlc3MiLCJSZWFjdCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsIlN0cmluZyIsInVuc2hpZnQiLCJGdW5jdGlvbiIsImNvbnNvbGUiLCJlbmFibGVTY29wZUFQSSIsImVuYWJsZUNhY2hlRWxlbWVudCIsImVuYWJsZVRyYW5zaXRpb25UcmFjaW5nIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlRGVidWdUcmFjaW5nIiwiUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldE1vZHVsZUlkIiwidW5kZWZpbmVkIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJSRVNFUlZFRF9QUk9QUyIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJjaGlsZCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsIm5leHQiLCJkb25lIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJfbmFtZSIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJrZXlzIiwianN4V2l0aFZhbGlkYXRpb24iLCJpc1N0YXRpY0NoaWxkcmVuIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJjaGlsZHJlbiIsImpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIiwianN4V2l0aFZhbGlkYXRpb25EeW5hbWljIiwianN4UnVudGltZUV4cG9ydHMiLCJpc0RheVBpY2tlck11bHRpcGxlIiwibW9kZSIsImlzRGF5UGlja2VyUmFuZ2UiLCJpc0RheVBpY2tlclNpbmdsZSIsImRlZmF1bHRDbGFzc05hbWVzIiwicm9vdCIsIm11bHRpcGxlX21vbnRocyIsIndpdGhfd2Vla251bWJlciIsInZoaWRkZW4iLCJidXR0b25fcmVzZXQiLCJidXR0b24iLCJjYXB0aW9uIiwiY2FwdGlvbl9zdGFydCIsImNhcHRpb25fZW5kIiwiY2FwdGlvbl9iZXR3ZWVuIiwiY2FwdGlvbl9sYWJlbCIsImNhcHRpb25fZHJvcGRvd25zIiwiZHJvcGRvd24iLCJkcm9wZG93bl9tb250aCIsImRyb3Bkb3duX3llYXIiLCJkcm9wZG93bl9pY29uIiwibW9udGhzIiwibW9udGgiLCJ0YWJsZSIsInRib2R5IiwidGZvb3QiLCJoZWFkIiwiaGVhZF9yb3ciLCJoZWFkX2NlbGwiLCJuYXYiLCJuYXZfYnV0dG9uIiwibmF2X2J1dHRvbl9wcmV2aW91cyIsIm5hdl9idXR0b25fbmV4dCIsIm5hdl9pY29uIiwicm93Iiwid2Vla251bWJlciIsImNlbGwiLCJkYXkiLCJkYXlfdG9kYXkiLCJkYXlfb3V0c2lkZSIsImRheV9zZWxlY3RlZCIsImRheV9kaXNhYmxlZCIsImRheV9oaWRkZW4iLCJkYXlfcmFuZ2Vfc3RhcnQiLCJkYXlfcmFuZ2VfZW5kIiwiZGF5X3JhbmdlX21pZGRsZSIsImZvcm1hdENhcHRpb24iLCJvcHRpb25zIiwiZm9ybWF0RGF5IiwiZm9ybWF0TW9udGhDYXB0aW9uIiwiZm9ybWF0V2Vla051bWJlciIsIndlZWtOdW1iZXIiLCJmb3JtYXRXZWVrZGF5TmFtZSIsIndlZWtkYXkiLCJmb3JtYXRZZWFyQ2FwdGlvbiIsInllYXIiLCJmb3JtYXR0ZXJzIiwiX19wcm90b19fIiwibGFiZWxEYXkiLCJhY3RpdmVNb2RpZmllcnMiLCJsYWJlbE1vbnRoRHJvcGRvd24iLCJsYWJlbE5leHQiLCJsYWJlbFByZXZpb3VzIiwibGFiZWxXZWVrZGF5IiwibGFiZWxXZWVrTnVtYmVyIiwibGFiZWxZZWFyRHJvcGRvd24iLCJsYWJlbHMiLCJnZXREZWZhdWx0Q29udGV4dFZhbHVlcyIsImNhcHRpb25MYXlvdXQiLCJjbGFzc05hbWVzIiwibG9jYWxlIiwibW9kaWZpZXJzQ2xhc3NOYW1lcyIsIm1vZGlmaWVycyIsIm51bWJlck9mTW9udGhzIiwic3R5bGVzIiwidG9kYXkiLCJEYXRlIiwicGFyc2VGcm9tVG9Qcm9wcyIsImZyb21ZZWFyIiwidG9ZZWFyIiwiZnJvbU1vbnRoIiwidG9Nb250aCIsImZyb21EYXRlIiwidG9EYXRlIiwiRGF5UGlja2VyQ29udGV4dCIsIkRheVBpY2tlclByb3ZpZGVyIiwiX2EiLCJpbml0aWFsUHJvcHMiLCJkZWZhdWx0Q29udGV4dFZhbHVlcyIsIl9iIiwib25TZWxlY3QiLCJjb21wb25lbnRzIiwiUHJvdmlkZXIiLCJ1c2VEYXlQaWNrZXIiLCJDYXB0aW9uTGFiZWwiLCJjbGFzc05hbWUiLCJzdHlsZSIsInJvbGUiLCJpZCIsImRpc3BsYXlNb250aCIsIkljb25Ecm9wZG93biIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsImZpbGwiLCJmaWxsUnVsZSIsIkRyb3Bkb3duIiwib25DaGFuZ2UiLCJkYXlQaWNrZXIiLCJJY29uRHJvcGRvd25Db21wb25lbnQiLCJNb250aHNEcm9wZG93biIsImRyb3Bkb3duTW9udGhzIiwiZGF0ZSIsImdldE1vbnRoIiwicHVzaCIsImhhbmRsZUNoYW5nZSIsInNlbGVjdGVkTW9udGgiLCJOdW1iZXIiLCJ0YXJnZXQiLCJuZXdNb250aCIsIkRyb3Bkb3duQ29tcG9uZW50IiwiWWVhcnNEcm9wZG93biIsInllYXJzIiwiZ2V0RnVsbFllYXIiLCJ1c2VDb250cm9sbGVkVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJjb250cm9sbGVkVmFsdWUiLCJ1bmNvbnRyb2xsZWRWYWx1ZSIsInNldFZhbHVlIiwiZ2V0SW5pdGlhbE1vbnRoIiwiZGVmYXVsdE1vbnRoIiwiaW5pdGlhbE1vbnRoIiwib2Zmc2V0IiwidXNlTmF2aWdhdGlvblN0YXRlIiwiZ29Ub01vbnRoIiwiZGlzYWJsZU5hdmlnYXRpb24iLCJvbk1vbnRoQ2hhbmdlIiwiZ2V0RGlzcGxheU1vbnRocyIsInJldmVyc2VNb250aHMiLCJzdGFydCIsImVuZCIsIm1vbnRoc0RpZmYiLCJuZXh0TW9udGgiLCJyZXZlcnNlIiwiZ2V0TmV4dE1vbnRoIiwic3RhcnRpbmdNb250aCIsInBhZ2VkTmF2aWdhdGlvbiIsImdldFByZXZpb3VzTW9udGgiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIk5hdmlnYXRpb25Qcm92aWRlciIsImN1cnJlbnRNb250aCIsImRpc3BsYXlNb250aHMiLCJwcmV2aW91c01vbnRoIiwiaXNEYXRlRGlzcGxheWVkIiwic29tZSIsImdvVG9EYXRlIiwicmVmRGF0ZSIsInVzZU5hdmlnYXRpb24iLCJDYXB0aW9uRHJvcGRvd25zIiwiaGFuZGxlTW9udGhDaGFuZ2UiLCJkaXNwbGF5SW5kZXgiLCJDYXB0aW9uTGFiZWxDb21wb25lbnQiLCJjYXB0aW9uTGFiZWwiLCJJY29uTGVmdCIsIkljb25SaWdodCIsIkJ1dHRvbiIsImNsYXNzTmFtZXNBcnIiLCJqb2luIiwiTmF2aWdhdGlvbiIsIl9jIiwiZGlyIiwiX2QiLCJwcmV2aW91c0xhYmVsIiwicHJldmlvdXNDbGFzc05hbWUiLCJuZXh0TGFiZWwiLCJuZXh0Q2xhc3NOYW1lIiwiSWNvblJpZ2h0Q29tcG9uZW50IiwiSWNvbkxlZnRDb21wb25lbnQiLCJoaWRlUHJldmlvdXMiLCJkaXNhYmxlZCIsIm9uQ2xpY2siLCJvblByZXZpb3VzQ2xpY2siLCJoaWRlTmV4dCIsIm9uTmV4dENsaWNrIiwiQ2FwdGlvbk5hdmlnYXRpb24iLCJmaW5kSW5kZXgiLCJpc0ZpcnN0IiwiaXNMYXN0IiwiaGFuZGxlUHJldmlvdXNDbGljayIsImhhbmRsZU5leHRDbGljayIsIkNhcHRpb24iLCJGb290ZXIiLCJmb290ZXIiLCJjb2xTcGFuIiwiZ2V0V2Vla2RheXMiLCJ3ZWVrU3RhcnRzT24iLCJJU09XZWVrIiwiZGF5cyIsIkhlYWRSb3ciLCJzaG93V2Vla051bWJlciIsIndlZWtkYXlzIiwic2NvcGUiLCJIZWFkIiwiSGVhZFJvd0NvbXBvbmVudCIsIkRheUNvbnRlbnQiLCJTZWxlY3RNdWx0aXBsZUNvbnRleHQiLCJTZWxlY3RNdWx0aXBsZVByb3ZpZGVyIiwiZW1wdHlDb250ZXh0VmFsdWUiLCJzZWxlY3RlZCIsIlNlbGVjdE11bHRpcGxlUHJvdmlkZXJJbnRlcm5hbCIsIm9uRGF5Q2xpY2siLCJpc01pblNlbGVjdGVkIiwiQm9vbGVhbiIsImlzTWF4U2VsZWN0ZWQiLCJzZWxlY3RlZERheXMiLCJpbmRleCIsInNlbGVjdGVkRGF5Iiwic3BsaWNlIiwiaXNTZWxlY3RlZCIsImNvbnRleHRWYWx1ZSIsInVzZVNlbGVjdE11bHRpcGxlIiwiYWRkVG9SYW5nZSIsInJhbmdlIiwiU2VsZWN0UmFuZ2VDb250ZXh0IiwiU2VsZWN0UmFuZ2VQcm92aWRlciIsInJhbmdlX3N0YXJ0IiwicmFuZ2VfZW5kIiwicmFuZ2VfbWlkZGxlIiwiU2VsZWN0UmFuZ2VQcm92aWRlckludGVybmFsIiwic2VsZWN0ZWRGcm9tIiwic2VsZWN0ZWRUbyIsIm5ld1JhbmdlIiwiYWZ0ZXIiLCJiZWZvcmUiLCJzZWxlY3RlZENvdW50IiwidXNlU2VsZWN0UmFuZ2UiLCJtYXRjaGVyVG9BcnJheSIsIm1hdGNoZXIiLCJnZXRDdXN0b21Nb2RpZmllcnMiLCJkYXlNb2RpZmllcnMiLCJjdXN0b21Nb2RpZmllcnMiLCJmb3JFYWNoIiwibW9kaWZpZXIiLCJJbnRlcm5hbE1vZGlmaWVyIiwiU2VsZWN0ZWQiLCJEaXNhYmxlZCIsIkhpZGRlbiIsIlRvZGF5IiwiUmFuZ2VFbmQiLCJSYW5nZU1pZGRsZSIsIlJhbmdlU3RhcnQiLCJPdXRzaWRlIiwiZ2V0SW50ZXJuYWxNb2RpZmllcnMiLCJzZWxlY3RNdWx0aXBsZSIsInNlbGVjdFJhbmdlIiwiaW50ZXJuYWxNb2RpZmllcnMiLCJoaWRkZW4iLCJNb2RpZmllcnNDb250ZXh0IiwiTW9kaWZpZXJzUHJvdmlkZXIiLCJ1c2VNb2RpZmllcnMiLCJpc0RhdGVJbnRlcnZhbCIsImlzRGF0ZVJhbmdlIiwiaXNEYXRlQWZ0ZXJUeXBlIiwiaXNEYXRlQmVmb3JlVHlwZSIsImlzRGF5T2ZXZWVrVHlwZSIsImlzRGF0ZUluUmFuZ2UiLCJpc1JhbmdlSW52ZXJ0ZWQiLCJpc0luUmFuZ2UiLCJpc0RhdGVUeXBlIiwiaXNBcnJheU9mRGF0ZXMiLCJldmVyeSIsImlzTWF0Y2giLCJtYXRjaGVycyIsImRheU9mV2VlayIsImdldERheSIsImRpZmZCZWZvcmUiLCJkaWZmQWZ0ZXIiLCJpc0RheUJlZm9yZSIsImlzRGF5QWZ0ZXIiLCJpc0Nsb3NlZEludGVydmFsIiwiZ2V0QWN0aXZlTW9kaWZpZXJzIiwibWF0Y2hlZE1vZGlmaWVycyIsInJlZHVjZSIsInJlc3VsdCIsIm91dHNpZGUiLCJnZXRJbml0aWFsRm9jdXNUYXJnZXQiLCJmaXJzdERheUluTW9udGgiLCJsYXN0RGF5SW5Nb250aCIsImZpcnN0Rm9jdXNhYmxlRGF5IiwiaXNGb2N1c2FibGUiLCJNQVhfUkVUUlkiLCJnZXROZXh0Rm9jdXMiLCJmb2N1c2VkRGF5IiwibW92ZUJ5IiwiZGlyZWN0aW9uIiwicmV0cnkiLCJjb3VudCIsImxhc3RGb2N1c2VkIiwibW92ZUZucyIsIndlZWsiLCJuZXdGb2N1c2VkRGF5IiwiRm9jdXNDb250ZXh0IiwiRm9jdXNQcm92aWRlciIsIm5hdmlnYXRpb24iLCJzZXRGb2N1c2VkRGF5Iiwic2V0TGFzdEZvY3VzZWQiLCJpbml0aWFsRm9jdXNUYXJnZXQiLCJmb2N1c1RhcmdldCIsImJsdXIiLCJmb2N1cyIsIm1vdmVGb2N1cyIsIm5leHRGb2N1c2VkIiwiZm9jdXNEYXlBZnRlciIsImZvY3VzRGF5QmVmb3JlIiwiZm9jdXNXZWVrQWZ0ZXIiLCJmb2N1c1dlZWtCZWZvcmUiLCJmb2N1c01vbnRoQmVmb3JlIiwiZm9jdXNNb250aEFmdGVyIiwiZm9jdXNZZWFyQmVmb3JlIiwiZm9jdXNZZWFyQWZ0ZXIiLCJmb2N1c1N0YXJ0T2ZXZWVrIiwiZm9jdXNFbmRPZldlZWsiLCJ1c2VGb2N1c0NvbnRleHQiLCJ1c2VBY3RpdmVNb2RpZmllcnMiLCJTZWxlY3RTaW5nbGVDb250ZXh0IiwiU2VsZWN0U2luZ2xlUHJvdmlkZXIiLCJTZWxlY3RTaW5nbGVQcm92aWRlckludGVybmFsIiwicmVxdWlyZWQiLCJ1c2VTZWxlY3RTaW5nbGUiLCJ1c2VEYXlFdmVudEhhbmRsZXJzIiwic2luZ2xlIiwibXVsdGlwbGUiLCJvbkZvY3VzIiwib25EYXlGb2N1cyIsIm9uQmx1ciIsIm9uRGF5Qmx1ciIsIm9uTW91c2VFbnRlciIsIm9uRGF5TW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIm9uRGF5TW91c2VMZWF2ZSIsIm9uUG9pbnRlckVudGVyIiwib25EYXlQb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsIm9uRGF5UG9pbnRlckxlYXZlIiwib25Ub3VjaENhbmNlbCIsIm9uRGF5VG91Y2hDYW5jZWwiLCJvblRvdWNoRW5kIiwib25EYXlUb3VjaEVuZCIsIm9uVG91Y2hNb3ZlIiwib25EYXlUb3VjaE1vdmUiLCJvblRvdWNoU3RhcnQiLCJvbkRheVRvdWNoU3RhcnQiLCJvbktleVVwIiwib25EYXlLZXlVcCIsIm9uS2V5RG93biIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic2hpZnRLZXkiLCJvbkRheUtleURvd24iLCJldmVudEhhbmRsZXJzIiwidXNlU2VsZWN0ZWREYXlzIiwiaXNJbnRlcm5hbE1vZGlmaWVyIiwiZ2V0RGF5Q2xhc3NOYW1lcyIsImN1c3RvbUNsYXNzTmFtZSIsImludGVybmFsQ2xhc3NOYW1lIiwiZ2V0RGF5U3R5bGUiLCJtb2RpZmllcnNTdHlsZXMiLCJ1c2VEYXlSZW5kZXIiLCJidXR0b25SZWYiLCJmb2N1c0NvbnRleHQiLCJpc0J1dHRvbiIsImlzSGlkZGVuIiwic2hvd091dHNpZGVEYXlzIiwiRGF5Q29udGVudENvbXBvbmVudCIsImRpdlByb3BzIiwiaXNGb2N1c1RhcmdldCIsImlzRm9jdXNlZCIsImJ1dHRvblByb3BzIiwidGFiSW5kZXgiLCJkYXlSZW5kZXIiLCJEYXkiLCJXZWVrTnVtYmVyIiwibnVtYmVyIiwiZGF0ZXMiLCJvbldlZWtOdW1iZXJDbGljayIsImNvbnRlbnQiLCJsYWJlbCIsImhhbmRsZUNsaWNrIiwiUm93IiwiRGF5Q29tcG9uZW50IiwiV2Vla251bWJlckNvbXBvbmVudCIsIndlZWtOdW1iZXJDZWxsIiwiZGF5c1RvTW9udGhXZWVrcyIsInRvV2VlayIsImZyb21XZWVrIiwibk9mRGF5cyIsIndlZWtzSW5Nb250aCIsImV4aXN0aW5nV2VlayIsImZpbmQiLCJnZXRNb250aFdlZWtzIiwidXNlRml4ZWRXZWVrcyIsIm5yT2ZNb250aFdlZWtzIiwibGFzdFdlZWsiLCJsYXN0RGF0ZSIsImV4dHJhV2Vla3MiLCJUYWJsZSIsImhpZGVIZWFkIiwiZml4ZWRXZWVrcyIsImZpcnN0V2Vla0NvbnRhaW5zRGF0ZSIsIndlZWtzIiwiSGVhZENvbXBvbmVudCIsIlJvd0NvbXBvbmVudCIsIkZvb3RlckNvbXBvbmVudCIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUiLCJnZW5JZCIsInVzZUlkIiwicHJvdmlkZWRJZCIsImluaXRpYWxJZCIsInNldElkIiwiTW9udGgiLCJjYXB0aW9uSWQiLCJ0YWJsZUlkIiwiaXNTdGFydCIsImlzRW5kIiwiaXNDZW50ZXIiLCJDYXB0aW9uQ29tcG9uZW50IiwiTW9udGhzIiwiUm9vdCIsImhhc0luaXRpYWxGb2N1cyIsInNldEhhc0luaXRpYWxGb2N1cyIsImluaXRpYWxGb2N1cyIsImRhdGFBdHRyaWJ1dGVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImF0dHJzIiwiTW9udGhzQ29tcG9uZW50Iiwibm9uY2UiLCJ0aXRsZSIsImxhbmciLCJSb290UHJvdmlkZXIiLCJEYXlQaWNrZXIiLCJpc1ZhbGlkRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsInVzZUlucHV0IiwiZm9ybWF0JDEiLCJkZWZhdWx0U2VsZWN0ZWQiLCJwYXJzZVZhbHVlIiwiX2UiLCJfZiIsInNldFNlbGVjdGVkRGF5IiwiZGVmYXVsdElucHV0VmFsdWUiLCJfZyIsImlucHV0VmFsdWUiLCJzZXRJbnB1dFZhbHVlIiwicmVzZXQiLCJzZXRTZWxlY3RlZCIsImhhbmRsZURheUNsaWNrIiwiaGFuZGxlQmx1ciIsImhhbmRsZUZvY3VzIiwiZGF5UGlja2VyUHJvcHMiLCJpbnB1dFByb3BzIiwicGxhY2Vob2xkZXIiLCJpc0RheVBpY2tlckRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-day-picker/dist/index.esm.js\n");

/***/ })

};
;